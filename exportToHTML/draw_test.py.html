<html>
<head>
<title>draw_test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
draw_test.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">unittest</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame </span><span class="s0">import </span><span class="s1">draw</span>
<span class="s0">from </span><span class="s1">pygame </span><span class="s0">import </span><span class="s1">draw_py</span>
<span class="s0">from </span><span class="s1">pygame.locals </span><span class="s0">import </span><span class="s1">SRCALPHA</span>
<span class="s0">from </span><span class="s1">pygame.tests </span><span class="s0">import </span><span class="s1">test_utils</span>
<span class="s0">from </span><span class="s1">pygame.math </span><span class="s0">import </span><span class="s1">Vector2</span>


<span class="s1">RED = BG_RED = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
<span class="s1">GREEN = FG_GREEN = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>

<span class="s3"># Clockwise from the top left corner and ending with the center point.</span>
<span class="s1">RECT_POSITION_ATTRIBUTES = (</span>
    <span class="s2">&quot;topleft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;midtop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;topright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;midright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bottomright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;midbottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bottomleft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;midleft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;center&quot;</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">get_border_values(surface</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height):</span>
    <span class="s4">&quot;&quot;&quot;Returns a list containing lists with the values of the surface's 
    borders. 
    &quot;&quot;&quot;</span>
    <span class="s1">border_top = [surface.get_at((x</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)]</span>
    <span class="s1">border_left = [surface.get_at((</span><span class="s5">0</span><span class="s0">, </span><span class="s1">y)) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height)]</span>
    <span class="s1">border_right = [surface.get_at((width - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">y)) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height)]</span>
    <span class="s1">border_bottom = [surface.get_at((x</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">1</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)]</span>

    <span class="s0">return </span><span class="s1">[border_top</span><span class="s0">, </span><span class="s1">border_left</span><span class="s0">, </span><span class="s1">border_right</span><span class="s0">, </span><span class="s1">border_bottom]</span>


<span class="s0">def </span><span class="s1">corners(surface):</span>
    <span class="s4">&quot;&quot;&quot;Returns a tuple with the corner positions of the given surface. 
 
    Clockwise from the top left corner. 
    &quot;&quot;&quot;</span>
    <span class="s1">width</span><span class="s0">, </span><span class="s1">height = surface.get_size()</span>
    <span class="s0">return </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">rect_corners_mids_and_center(rect):</span>
    <span class="s4">&quot;&quot;&quot;Returns a tuple with each corner, mid, and the center for a given rect. 
 
    Clockwise from the top left corner and ending with the center point. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">(</span>
        <span class="s1">rect.topleft</span><span class="s0">,</span>
        <span class="s1">rect.midtop</span><span class="s0">,</span>
        <span class="s1">rect.topright</span><span class="s0">,</span>
        <span class="s1">rect.midright</span><span class="s0">,</span>
        <span class="s1">rect.bottomright</span><span class="s0">,</span>
        <span class="s1">rect.midbottom</span><span class="s0">,</span>
        <span class="s1">rect.bottomleft</span><span class="s0">,</span>
        <span class="s1">rect.midleft</span><span class="s0">,</span>
        <span class="s1">rect.center</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">border_pos_and_color(surface):</span>
    <span class="s4">&quot;&quot;&quot;Yields each border position and its color for a given surface. 
 
    Clockwise from the top left corner. 
    &quot;&quot;&quot;</span>
    <span class="s1">width</span><span class="s0">, </span><span class="s1">height = surface.get_size()</span>
    <span class="s1">right</span><span class="s0">, </span><span class="s1">bottom = width - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">1</span>

    <span class="s3"># Top edge.</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
        <span class="s1">pos = (x</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>

    <span class="s3"># Right edge.</span>
    <span class="s3"># Top right done in top edge loop.</span>
    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">height):</span>
        <span class="s1">pos = (right</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>

    <span class="s3"># Bottom edge.</span>
    <span class="s3"># Bottom right done in right edge loop.</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(right - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">pos = (x</span><span class="s0">, </span><span class="s1">bottom)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>

    <span class="s3"># Left edge.</span>
    <span class="s3"># Bottom left done in bottom edge loop. Top left done in top edge loop.</span>
    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(bottom - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">pos = (</span><span class="s5">0</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">yield </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">surface.get_at(pos)</span>


<span class="s0">def </span><span class="s1">get_color_points(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">bounds_rect=</span><span class="s0">None, </span><span class="s1">match_color=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Get all the points of a given color on the surface within the given 
    bounds. 
 
    If bounds_rect is None the full surface is checked. 
    If match_color is True, all points matching the color are returned, 
        otherwise all points not matching the color are returned. 
    &quot;&quot;&quot;</span>
    <span class="s1">get_at = surface.get_at  </span><span class="s3"># For possible speed up.</span>

    <span class="s0">if </span><span class="s1">bounds_rect </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">x_range = range(surface.get_width())</span>
        <span class="s1">y_range = range(surface.get_height())</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">x_range = range(bounds_rect.left</span><span class="s0">, </span><span class="s1">bounds_rect.right)</span>
        <span class="s1">y_range = range(bounds_rect.top</span><span class="s0">, </span><span class="s1">bounds_rect.bottom)</span>

    <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

    <span class="s0">if </span><span class="s1">match_color:</span>
        <span class="s1">pts = [(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">x_range </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">y_range </span><span class="s0">if </span><span class="s1">get_at((x</span><span class="s0">, </span><span class="s1">y)) == color]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">pts = [(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">x_range </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">y_range </span><span class="s0">if </span><span class="s1">get_at((x</span><span class="s0">, </span><span class="s1">y)) != color]</span>

    <span class="s1">surface.unlock()</span>
    <span class="s0">return </span><span class="s1">pts</span>


<span class="s0">def </span><span class="s1">create_bounding_rect(surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">default_pos):</span>
    <span class="s4">&quot;&quot;&quot;Create a rect to bound all the pixels that don't match surf_color. 
 
    The default_pos parameter is used to position the bounding rect for the 
    case where all pixels match the surf_color. 
    &quot;&quot;&quot;</span>
    <span class="s1">width</span><span class="s0">, </span><span class="s1">height = surface.get_clip().size</span>
    <span class="s1">xmin</span><span class="s0">, </span><span class="s1">ymin = width</span><span class="s0">, </span><span class="s1">height</span>
    <span class="s1">xmax</span><span class="s0">, </span><span class="s1">ymax = -</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span>
    <span class="s1">get_at = surface.get_at  </span><span class="s3"># For possible speed up.</span>

    <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height):</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
            <span class="s0">if </span><span class="s1">get_at((x</span><span class="s0">, </span><span class="s1">y)) != surf_color:</span>
                <span class="s1">xmin = min(x</span><span class="s0">, </span><span class="s1">xmin)</span>
                <span class="s1">xmax = max(x</span><span class="s0">, </span><span class="s1">xmax)</span>
                <span class="s1">ymin = min(y</span><span class="s0">, </span><span class="s1">ymin)</span>
                <span class="s1">ymax = max(y</span><span class="s0">, </span><span class="s1">ymax)</span>

    <span class="s1">surface.unlock()</span>

    <span class="s0">if </span><span class="s1">-</span><span class="s5">1 </span><span class="s1">== xmax:</span>
        <span class="s3"># No points means a 0 sized rect positioned at default_pos.</span>
        <span class="s0">return </span><span class="s1">pygame.Rect(default_pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s0">return </span><span class="s1">pygame.Rect((xmin</span><span class="s0">, </span><span class="s1">ymin)</span><span class="s0">, </span><span class="s1">(xmax - xmin + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">ymax - ymin + </span><span class="s5">1</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">InvalidBool:</span>
    <span class="s4">&quot;&quot;&quot;To help test invalid bool values.&quot;&quot;&quot;</span>

    <span class="s1">__bool__ = </span><span class="s0">None</span>


<span class="s0">class </span><span class="s1">DrawTestCase(unittest.TestCase):</span>
    <span class="s4">&quot;&quot;&quot;Base class to test draw module functions.&quot;&quot;&quot;</span>

    <span class="s1">draw_rect = staticmethod(draw.rect)</span>
    <span class="s1">draw_polygon = staticmethod(draw.polygon)</span>
    <span class="s1">draw_circle = staticmethod(draw.circle)</span>
    <span class="s1">draw_ellipse = staticmethod(draw.ellipse)</span>
    <span class="s1">draw_arc = staticmethod(draw.arc)</span>
    <span class="s1">draw_line = staticmethod(draw.line)</span>
    <span class="s1">draw_lines = staticmethod(draw.lines)</span>
    <span class="s1">draw_aaline = staticmethod(draw.aaline)</span>
    <span class="s1">draw_aalines = staticmethod(draw.aalines)</span>


<span class="s0">class </span><span class="s1">PythonDrawTestCase(unittest.TestCase):</span>
    <span class="s4">&quot;&quot;&quot;Base class to test draw_py module functions.&quot;&quot;&quot;</span>

    <span class="s3"># draw_py is currently missing some functions.</span>
    <span class="s3"># draw_rect    = staticmethod(draw_py.draw_rect)</span>
    <span class="s1">draw_polygon = staticmethod(draw_py.draw_polygon)</span>
    <span class="s3"># draw_circle  = staticmethod(draw_py.draw_circle)</span>
    <span class="s3"># draw_ellipse = staticmethod(draw_py.draw_ellipse)</span>
    <span class="s3"># draw_arc     = staticmethod(draw_py.draw_arc)</span>
    <span class="s1">draw_line = staticmethod(draw_py.draw_line)</span>
    <span class="s1">draw_lines = staticmethod(draw_py.draw_lines)</span>
    <span class="s1">draw_aaline = staticmethod(draw_py.draw_aaline)</span>
    <span class="s1">draw_aalines = staticmethod(draw_py.draw_aalines)</span>


<span class="s3">### Ellipse Testing ###########################################################</span>


<span class="s0">class </span><span class="s1">DrawEllipseMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing ellipses. 
 
    This class contains all the general ellipse drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_ellipse__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_ellipse(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__args_without_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts the args without a width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_ellipse(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">99</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__args_with_negative_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts the args with negative width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_ellipse(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.Rect((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>
        <span class="s1">self.assertEqual(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_ellipse__args_with_width_gt_radius(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts the args with 
        width &gt; rect.w // 2 and width &gt; rect.h // 2. 
        &quot;&quot;&quot;</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">bounds_rect = self.draw_ellipse(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">rect.w // </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

        <span class="s1">bounds_rect = self.draw_ellipse(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">rect.h // </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts the correct kwargs 
        with and without a width arg. 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_ellipse(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_ellipse(</span>
            <span class="s1">color=(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">rect=pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_ellipse(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_ellipse()</span>

    <span class="s0">def </span><span class="s1">test_ellipse__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;rect&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_ellipse(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid width.</span>
            <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid rect.</span>
            <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_ellipse(rect</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,  </span><span class="s3"># Invalid surface.</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,  </span><span class="s3"># Invalid color.</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid rect.</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1.1</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]  </span><span class="s3"># Invalid width.</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_ellipse(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">, </span><span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_ellipse(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">width = </span><span class="s5">0</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: width}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;rect&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__valid_width_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts different width values.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">1000</span><span class="s0">, </span><span class="s1">-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">1000</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width</span>
            <span class="s1">expected_color = color </span><span class="s0">if </span><span class="s1">width &gt;= </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_ellipse(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__valid_rect_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts different rect formats.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s1">}</span>
        <span class="s1">rects = (pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(pos[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">rect </span><span class="s0">in </span><span class="s1">rects:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;rect&quot;</span><span class="s1">] = rect</span>

            <span class="s1">bounds_rect = self.draw_ellipse(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">reds = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">reds:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_ellipse(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">surface):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_ellipse(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_ellipse(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests ellipses of differing sizes on surfaces of differing sizes. 
 
        Checks if the number of sides touching the border of the surface is 
        correct. 
        &quot;&quot;&quot;</span>
        <span class="s1">left_top = [(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)]</span>
        <span class="s1">sizes = [(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)]</span>
        <span class="s1">color = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">13</span><span class="s0">, </span><span class="s5">24</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width):</span>
            <span class="s4">&quot;&quot;&quot;Test for ellipses with the same size as the surface.&quot;&quot;&quot;</span>
            <span class="s1">surface = pygame.Surface((width</span><span class="s0">, </span><span class="s1">height))</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">border_width)</span>

            <span class="s3"># For each of the four borders check if it contains the color</span>
            <span class="s1">borders = get_border_values(surface</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span>
            <span class="s0">for </span><span class="s1">border </span><span class="s0">in </span><span class="s1">borders:</span>
                <span class="s1">self.assertTrue(color </span><span class="s0">in </span><span class="s1">border)</span>

        <span class="s0">def </span><span class="s1">not_same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">top):</span>
            <span class="s4">&quot;&quot;&quot;Test for ellipses that aren't the same size as the surface.&quot;&quot;&quot;</span>
            <span class="s1">surface = pygame.Surface((width</span><span class="s0">, </span><span class="s1">height))</span>

            <span class="s1">self.draw_ellipse(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(left</span><span class="s0">, </span><span class="s1">top</span><span class="s0">, </span><span class="s1">width - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">border_width</span>
            <span class="s1">)</span>

            <span class="s1">borders = get_border_values(surface</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span>

            <span class="s3"># Check if two sides of the ellipse are touching the border</span>
            <span class="s1">sides_touching = [color </span><span class="s0">in </span><span class="s1">border </span><span class="s0">for </span><span class="s1">border </span><span class="s0">in </span><span class="s1">borders].count(</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(sides_touching</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s0">for </span><span class="s1">border_width </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width)</span>
                <span class="s0">for </span><span class="s1">left</span><span class="s0">, </span><span class="s1">top </span><span class="s0">in </span><span class="s1">left_top:</span>
                    <span class="s1">not_same_size(width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">border_width</span><span class="s0">, </span><span class="s1">left</span><span class="s0">, </span><span class="s1">top)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__big_ellipse(self):</span>
        <span class="s4">&quot;&quot;&quot;Test for big ellipse that could overflow in algorithm&quot;&quot;&quot;</span>
        <span class="s1">width = </span><span class="s5">1025</span>
        <span class="s1">height = </span><span class="s5">1025</span>
        <span class="s1">border = </span><span class="s5">1</span>
        <span class="s1">x_value_test = int(</span><span class="s5">0.4 </span><span class="s1">* height)</span>
        <span class="s1">y_value_test = int(</span><span class="s5">0.4 </span><span class="s1">* height)</span>
        <span class="s1">surface = pygame.Surface((width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">border)</span>
        <span class="s1">colored_pixels = </span><span class="s5">0</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height):</span>
            <span class="s0">if </span><span class="s1">surface.get_at((x_value_test</span><span class="s0">, </span><span class="s1">y)) == (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s1">colored_pixels += </span><span class="s5">1</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
            <span class="s0">if </span><span class="s1">surface.get_at((x</span><span class="s0">, </span><span class="s1">y_value_test)) == (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s1">colored_pixels += </span><span class="s5">1</span>
        <span class="s1">self.assertEqual(colored_pixels</span><span class="s0">, </span><span class="s1">border * </span><span class="s5">4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__thick_line(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures a thick lined ellipse is drawn correctly.&quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">40</span><span class="s0">, </span><span class="s5">40</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">31</span><span class="s0">, </span><span class="s5">23</span><span class="s1">))</span>
        <span class="s1">rect.center = surface.get_rect().center</span>

        <span class="s3"># As the lines get thicker the internals of the ellipse are not</span>
        <span class="s3"># cleanly defined. So only test up to a few thicknesses before the</span>
        <span class="s3"># maximum thickness.</span>
        <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">min(*rect.size) // </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

            <span class="s3"># Check vertical thickness on the ellipse's top.</span>
            <span class="s1">x = rect.centerx</span>
            <span class="s1">y_start = rect.top</span>
            <span class="s1">y_end = rect.top + thickness - </span><span class="s5">1</span>

            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(y_start</span><span class="s0">, </span><span class="s1">y_end + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s3"># Check pixels above and below this line.</span>
            <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y_start - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>
            <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y_end + </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s3"># Check vertical thickness on the ellipse's bottom.</span>
            <span class="s1">x = rect.centerx</span>
            <span class="s1">y_start = rect.bottom - thickness</span>
            <span class="s1">y_end = rect.bottom - </span><span class="s5">1</span>

            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(y_start</span><span class="s0">, </span><span class="s1">y_end + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s3"># Check pixels above and below this line.</span>
            <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y_start - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>
            <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y_end + </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s3"># Check horizontal thickness on the ellipse's left.</span>
            <span class="s1">x_start = rect.left</span>
            <span class="s1">x_end = rect.left + thickness - </span><span class="s5">1</span>
            <span class="s1">y = rect.centery</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(x_start</span><span class="s0">, </span><span class="s1">x_end + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s3"># Check pixels to the left and right of this line.</span>
            <span class="s1">self.assertEqual(surface.get_at((x_start - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>
            <span class="s1">self.assertEqual(surface.get_at((x_end + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s3"># Check horizontal thickness on the ellipse's right.</span>
            <span class="s1">x_start = rect.right - thickness</span>
            <span class="s1">x_end = rect.right - </span><span class="s5">1</span>
            <span class="s1">y = rect.centery</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(x_start</span><span class="s0">, </span><span class="s1">x_end + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s3"># Check pixels to the left and right of this line.</span>
            <span class="s1">self.assertEqual(surface.get_at((x_start - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>
            <span class="s1">self.assertEqual(surface.get_at((x_end + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s1">surface.unlock()</span>

    <span class="s0">def </span><span class="s1">test_ellipse__no_holes(self):</span>
        <span class="s1">width = </span><span class="s5">80</span>
        <span class="s1">height = </span><span class="s5">70</span>
        <span class="s1">surface = pygame.Surface((width + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">height))</span>
        <span class="s1">rect = pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">37</span><span class="s0">, </span><span class="s5">5</span><span class="s1">):</span>
            <span class="s1">surface.fill(</span><span class="s2">&quot;BLACK&quot;</span><span class="s1">)</span>
            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s2">&quot;RED&quot;</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">thickness)</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height):</span>
                <span class="s1">number_of_changes = </span><span class="s5">0</span>
                <span class="s1">drawn_pixel = </span><span class="s0">False</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width + </span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s0">if </span><span class="s1">(</span>
                        <span class="s0">not </span><span class="s1">drawn_pixel</span>
                        <span class="s0">and </span><span class="s1">surface.get_at((x</span><span class="s0">, </span><span class="s1">y)) == pygame.Color(</span><span class="s2">&quot;RED&quot;</span><span class="s1">)</span>
                        <span class="s0">or </span><span class="s1">drawn_pixel</span>
                        <span class="s0">and </span><span class="s1">surface.get_at((x</span><span class="s0">, </span><span class="s1">y)) == pygame.Color(</span><span class="s2">&quot;BLACK&quot;</span><span class="s1">)</span>
                    <span class="s1">):</span>
                        <span class="s1">drawn_pixel = </span><span class="s0">not </span><span class="s1">drawn_pixel</span>
                        <span class="s1">number_of_changes += </span><span class="s5">1</span>
                <span class="s0">if </span><span class="s1">y &lt; thickness </span><span class="s0">or </span><span class="s1">y &gt; height - thickness - </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">self.assertEqual(number_of_changes</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.assertEqual(number_of_changes</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__max_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with max width (and greater) is drawn correctly.&quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">40</span><span class="s0">, </span><span class="s5">40</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">31</span><span class="s0">, </span><span class="s5">21</span><span class="s1">))</span>
        <span class="s1">rect.center = surface.get_rect().center</span>
        <span class="s1">max_thickness = (min(*rect.size) + </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span>

        <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(max_thickness</span><span class="s0">, </span><span class="s1">max_thickness + </span><span class="s5">3</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

            <span class="s3"># Check vertical thickness.</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(rect.top</span><span class="s0">, </span><span class="s1">rect.bottom):</span>
                <span class="s1">self.assertEqual(surface.get_at((rect.centerx</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">ellipse_color)</span>

            <span class="s3"># Check horizontal thickness.</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(rect.left</span><span class="s0">, </span><span class="s1">rect.right):</span>
                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">rect.centery))</span><span class="s0">, </span><span class="s1">ellipse_color)</span>

            <span class="s3"># Check pixels above and below ellipse.</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">surface.get_at((rect.centerx</span><span class="s0">, </span><span class="s1">rect.top - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">surface_color</span>
            <span class="s1">)</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">surface.get_at((rect.centerx</span><span class="s0">, </span><span class="s1">rect.bottom + </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">surface_color</span>
            <span class="s1">)</span>

            <span class="s3"># Check pixels to the left and right of the ellipse.</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">surface.get_at((rect.left - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect.centery))</span><span class="s0">, </span><span class="s1">surface_color</span>
            <span class="s1">)</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">surface.get_at((rect.right + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect.centery))</span><span class="s0">, </span><span class="s1">surface_color</span>
            <span class="s1">)</span>

            <span class="s1">surface.unlock()</span>

    <span class="s0">def </span><span class="s1">_check_1_pixel_sized_ellipse(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">surface</span><span class="s0">, </span><span class="s1">collide_rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color</span>
    <span class="s1">):</span>
        <span class="s3"># Helper method to check the surface for 1 pixel wide and/or high</span>
        <span class="s3"># ellipses.</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = surface.get_size()</span>

        <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surf_h) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surf_w)):</span>
            <span class="s3"># Since the ellipse is just a line we can use a rect to help find</span>
            <span class="s3"># where it is expected to be drawn.</span>
            <span class="s0">if </span><span class="s1">collide_rect.collidepoint(pos):</span>
                <span class="s1">expected_color = ellipse_color</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = surface_color</span>

            <span class="s1">self.assertEqual(</span>
                <span class="s1">surface.get_at(pos)</span><span class="s0">,</span>
                <span class="s1">expected_color</span><span class="s0">,</span>
                <span class="s2">f&quot;collide_rect=</span><span class="s0">{</span><span class="s1">collide_rect</span><span class="s0">}</span><span class="s2">, pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">surface.unlock()</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a width of 1 is drawn correctly. 
 
        An ellipse with a width of 1 pixel is a vertical line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">collide_rect = rect.copy()</span>

        <span class="s3"># Calculate some positions.</span>
        <span class="s1">off_left = -</span><span class="s5">1</span>
        <span class="s1">off_right = surf_w</span>
        <span class="s1">off_bottom = surf_h</span>
        <span class="s1">center_x = surf_w // </span><span class="s5">2</span>
        <span class="s1">center_y = surf_h // </span><span class="s5">2</span>

        <span class="s3"># Test some even and odd heights.</span>
        <span class="s0">for </span><span class="s1">ellipse_h </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">collide_rect.h = ellipse_h</span>
            <span class="s1">rect.h = ellipse_h</span>

            <span class="s3"># Calculate some variable positions.</span>
            <span class="s1">off_top = -(ellipse_h + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">half_off_top = -(ellipse_h // </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">half_off_bottom = surf_h - (ellipse_h // </span><span class="s5">2</span><span class="s1">)</span>

            <span class="s3"># Draw the ellipse in different positions: fully on-surface,</span>
            <span class="s3"># partially off-surface, and fully off-surface.</span>
            <span class="s1">positions = (</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">half_off_top)</span><span class="s0">,</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">half_off_bottom)</span><span class="s0">,</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">half_off_top)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">half_off_bottom)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">half_off_top)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">half_off_bottom)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear before each draw.</span>
                <span class="s1">rect.topleft = rect_pos</span>
                <span class="s1">collide_rect.topleft = rect_pos</span>

                <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

                <span class="s1">self._check_1_pixel_sized_ellipse(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">collide_rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_width_spanning_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a width of 1 is drawn correctly 
        when spanning the height of the surface. 
 
        An ellipse with a width of 1 pixel is a vertical line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">surf_h + </span><span class="s5">2</span><span class="s1">))  </span><span class="s3"># Longer than the surface.</span>

        <span class="s3"># Draw the ellipse in different positions: on-surface and off-surface.</span>
        <span class="s1">positions = (</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (off_left,   off_top)</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (left_edge,  off_top)</span>
            <span class="s1">(surf_w // </span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (center_x,   off_top)</span>
            <span class="s1">(surf_w - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (right_edge, off_top)</span>
            <span class="s1">(surf_w</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># (off_right,  off_top)</span>

        <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear before each draw.</span>
            <span class="s1">rect.topleft = rect_pos</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

            <span class="s1">self._check_1_pixel_sized_ellipse(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_height(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a height of 1 is drawn correctly. 
 
        An ellipse with a height of 1 pixel is a horizontal line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s5">20</span><span class="s0">, </span><span class="s5">10</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">collide_rect = rect.copy()</span>

        <span class="s3"># Calculate some positions.</span>
        <span class="s1">off_right = surf_w</span>
        <span class="s1">off_top = -</span><span class="s5">1</span>
        <span class="s1">off_bottom = surf_h</span>
        <span class="s1">center_x = surf_w // </span><span class="s5">2</span>
        <span class="s1">center_y = surf_h // </span><span class="s5">2</span>

        <span class="s3"># Test some even and odd widths.</span>
        <span class="s0">for </span><span class="s1">ellipse_w </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">collide_rect.w = ellipse_w</span>
            <span class="s1">rect.w = ellipse_w</span>

            <span class="s3"># Calculate some variable positions.</span>
            <span class="s1">off_left = -(ellipse_w + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">half_off_left = -(ellipse_w // </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">half_off_right = surf_w - (ellipse_w // </span><span class="s5">2</span><span class="s1">)</span>

            <span class="s3"># Draw the ellipse in different positions: fully on-surface,</span>
            <span class="s3"># partially off-surface, and fully off-surface.</span>
            <span class="s1">positions = (</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(half_off_left</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(half_off_right</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(half_off_left</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(half_off_right</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
                <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                <span class="s1">(half_off_left</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                <span class="s1">(half_off_right</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
                <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear before each draw.</span>
                <span class="s1">rect.topleft = rect_pos</span>
                <span class="s1">collide_rect.topleft = rect_pos</span>

                <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

                <span class="s1">self._check_1_pixel_sized_ellipse(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">collide_rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_height_spanning_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a height of 1 is drawn correctly 
        when spanning the width of the surface. 
 
        An ellipse with a height of 1 pixel is a horizontal line. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s5">20</span><span class="s0">, </span><span class="s5">10</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(surf_w + </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))  </span><span class="s3"># Wider than the surface.</span>

        <span class="s3"># Draw the ellipse in different positions: on-surface and off-surface.</span>
        <span class="s1">positions = (</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (off_left, off_top)</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (off_left, top_edge)</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">surf_h // </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (off_left, center_y)</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">surf_h - </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># (off_left, bottom_edge)</span>
            <span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">surf_h)</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># (off_left, off_bottom)</span>

        <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear before each draw.</span>
            <span class="s1">rect.topleft = rect_pos</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

            <span class="s1">self._check_1_pixel_sized_ellipse(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__1_pixel_width_and_height(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an ellipse with a width and height of 1 is drawn correctly. 
 
        An ellipse with a width and height of 1 pixel is a single pixel. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surf_w</span><span class="s0">, </span><span class="s1">surf_h = </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span>

        <span class="s1">surface = pygame.Surface((surf_w</span><span class="s0">, </span><span class="s1">surf_h))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s3"># Calculate some positions.</span>
        <span class="s1">off_left = -</span><span class="s5">1</span>
        <span class="s1">off_right = surf_w</span>
        <span class="s1">off_top = -</span><span class="s5">1</span>
        <span class="s1">off_bottom = surf_h</span>
        <span class="s1">left_edge = </span><span class="s5">0</span>
        <span class="s1">right_edge = surf_w - </span><span class="s5">1</span>
        <span class="s1">top_edge = </span><span class="s5">0</span>
        <span class="s1">bottom_edge = surf_h - </span><span class="s5">1</span>
        <span class="s1">center_x = surf_w // </span><span class="s5">2</span>
        <span class="s1">center_y = surf_h // </span><span class="s5">2</span>

        <span class="s3"># Draw the ellipse in different positions: center surface,</span>
        <span class="s3"># top/bottom/left/right edges, and off-surface.</span>
        <span class="s1">positions = (</span>
            <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
            <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
            <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
            <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
            <span class="s1">(off_left</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
            <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
            <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
            <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
            <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
            <span class="s1">(left_edge</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
            <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
            <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
            <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
            <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
            <span class="s1">(center_x</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
            <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
            <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
            <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
            <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
            <span class="s1">(right_edge</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
            <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_top)</span><span class="s0">,</span>
            <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">top_edge)</span><span class="s0">,</span>
            <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">center_y)</span><span class="s0">,</span>
            <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">bottom_edge)</span><span class="s0">,</span>
            <span class="s1">(off_right</span><span class="s0">, </span><span class="s1">off_bottom)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">rect_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear before each draw.</span>
            <span class="s1">rect.topleft = rect_pos</span>

            <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">rect)</span>

            <span class="s1">self._check_1_pixel_sized_ellipse(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">ellipse_color</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse returns the correct bounding rect. 
 
        Tests ellipses on and off the surface and a range of width/thickness 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">min_width = min_height = </span><span class="s5">5</span>
        <span class="s1">max_width = max_height = </span><span class="s5">7</span>
        <span class="s1">sizes = ((min_width</span><span class="s0">, </span><span class="s1">min_height)</span><span class="s0">, </span><span class="s1">(max_width</span><span class="s0">, </span><span class="s1">max_height))</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
        <span class="s1">surf_rect = surface.get_rect()</span>
        <span class="s3"># Make a rect that is bigger than the surface to help test drawing</span>
        <span class="s3"># ellipses off and partially off the surface.</span>
        <span class="s1">big_rect = surf_rect.inflate(min_width * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s1">min_height * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(</span>
            <span class="s1">surf_rect</span>
        <span class="s1">) + rect_corners_mids_and_center(big_rect):</span>
            <span class="s3"># Each of the ellipse's rect position attributes will be set to</span>
            <span class="s3"># the pos value.</span>
            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">RECT_POSITION_ATTRIBUTES:</span>
                <span class="s3"># Test using different rect sizes and thickness values.</span>
                <span class="s0">for </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height </span><span class="s0">in </span><span class="s1">sizes:</span>
                    <span class="s1">ellipse_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>
                    <span class="s1">setattr(ellipse_rect</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">pos)</span>

                    <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">min(width</span><span class="s0">, </span><span class="s1">height)):</span>
                        <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                        <span class="s1">bounding_rect = self.draw_ellipse(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">ellipse_rect</span><span class="s0">, </span><span class="s1">thickness</span>
                        <span class="s1">)</span>

                        <span class="s3"># Calculating the expected_rect after the ellipse</span>
                        <span class="s3"># is drawn (it uses what is actually drawn).</span>
                        <span class="s1">expected_rect = create_bounding_rect(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">ellipse_rect.topleft</span>
                        <span class="s1">)</span>

                        <span class="s1">self.assertEqual(bounding_rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_ellipse__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw ellipse respects a surface's clip area. 
 
        Tests drawing the ellipse filled and unfilled. 
        &quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">ellipse_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">11</span><span class="s0">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">pos_rect = clip_rect.copy()  </span><span class="s3"># Manages the ellipse's pos.</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):  </span><span class="s3"># Filled and unfilled.</span>
            <span class="s3"># Test centering the ellipse along the clip rect's edge.</span>
            <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
                <span class="s3"># Get the expected points by drawing the ellipse without the</span>
                <span class="s3"># clip area set.</span>
                <span class="s1">pos_rect.center = center</span>
                <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">pos_rect</span><span class="s0">, </span><span class="s1">width)</span>
                <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">clip_rect)</span>

                <span class="s3"># Clear the surface and set the clip area. Redraw the ellipse</span>
                <span class="s3"># and check that only the clip area is modified.</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">surface.set_clip(clip_rect)</span>

                <span class="s1">self.draw_ellipse(surface</span><span class="s0">, </span><span class="s1">ellipse_color</span><span class="s0">, </span><span class="s1">pos_rect</span><span class="s0">, </span><span class="s1">width)</span>

                <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                <span class="s3"># Check all the surface points to ensure only the expected_pts</span>
                <span class="s3"># are the ellipse_color.</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                    <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                        <span class="s1">expected_color = ellipse_color</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_color = surface_color</span>

                    <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pt)</span>

                <span class="s1">surface.unlock()</span>


<span class="s0">class </span><span class="s1">DrawEllipseTest(DrawEllipseMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function ellipse. 
 
    This class inherits the general tests from DrawEllipseMixin. It is also 
    the class to add any draw.ellipse specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever properly supports drawing ellipses.</span>
<span class="s3"># @unittest.skip('draw_py.draw_ellipse not supported yet')</span>
<span class="s3"># class PythonDrawEllipseTest(DrawEllipseMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function draw_ellipse.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from DrawEllipseMixin. It is also</span>
<span class="s3">#    the class to add any draw_py.draw_ellipse specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s3">### Line/Lines/AALine/AALines Testing #########################################</span>


<span class="s0">class </span><span class="s1">BaseLineMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin base for drawing various lines. 
 
    This class contains general helper methods and setup for testing the 
    different types of lines. 
    &quot;&quot;&quot;</span>

    <span class="s1">COLORS = (</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_create_surfaces():</span>
        <span class="s3"># Create some surfaces with different sizes, depths, and flags.</span>
        <span class="s1">surfaces = []</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s5">49</span><span class="s0">, </span><span class="s5">49</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)):</span>
            <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s5">8</span><span class="s0">, </span><span class="s5">16</span><span class="s0">, </span><span class="s5">24</span><span class="s0">, </span><span class="s5">32</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">flags </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">SRCALPHA):</span>
                    <span class="s1">surface = pygame.display.set_mode(size</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">depth)</span>
                    <span class="s1">surfaces.append(surface)</span>
                    <span class="s1">surfaces.append(surface.convert_alpha())</span>
        <span class="s0">return </span><span class="s1">surfaces</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_rect_lines(rect):</span>
        <span class="s3"># Yields pairs of end points and their reverse (to test symmetry).</span>
        <span class="s3"># Uses a rect with the points radiating from its midleft.</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(rect):</span>
            <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">[rect.midleft</span><span class="s0">, </span><span class="s1">rect.center]:</span>
                <span class="s3"># Don't bother with these points.</span>
                <span class="s0">continue</span>
            <span class="s0">yield </span><span class="s1">(rect.midleft</span><span class="s0">, </span><span class="s1">pt)</span>
            <span class="s0">yield </span><span class="s1">(pt</span><span class="s0">, </span><span class="s1">rect.midleft)</span>


<span class="s3">### Line Testing ##############################################################</span>


<span class="s0">class </span><span class="s1">LineMixin(BaseLineMixin):</span>
    <span class="s4">&quot;&quot;&quot;Mixin test for drawing a single line. 
 
    This class contains all the general single line drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_line__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_line(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__args_without_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts the args without a width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_line(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts the correct kwargs 
        with and without a width arg. 
        &quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_line(</span>
            <span class="s1">start_pos=(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">end_pos=(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">color=(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_line(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_line()</span>

    <span class="s0">def </span><span class="s1">test_line__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;end_pos&quot;</span><span class="s0">, </span><span class="s2">&quot;start_pos&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_line(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_line__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid width.</span>
            <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid end_pos.</span>
            <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid start_pos.</span>
            <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end_pos)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_line((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos)</span>

    <span class="s0">def </span><span class="s1">test_line__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">width = </span><span class="s5">1</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,  </span><span class="s3"># Invalid surface.</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,  </span><span class="s3"># Invalid color.</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid start_pos.</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid end_pos.</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1.2</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]  </span><span class="s3"># Invalid width.</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_line__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_line__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">width = </span><span class="s5">0</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;start_pos&quot;</span><span class="s0">, </span><span class="s2">&quot;end_pos&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;start_pos&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_line(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;end_pos&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_line(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_line(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__valid_width_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts different width values.&quot;&quot;&quot;</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: line_color</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: pos</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">100</span><span class="s0">, </span><span class="s1">-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">100</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width</span>
            <span class="s1">expected_color = line_color </span><span class="s0">if </span><span class="s1">width &gt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__valid_start_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts different start_pos formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1  </span><span class="s3"># start position</span>

        <span class="s3"># The point values can be ints or floats.</span>
        <span class="s0">for </span><span class="s1">start_pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.1</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.1</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.1</span><span class="s1">)):</span>
            <span class="s3"># The point type can be a tuple/list/Vector2.</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">Vector2):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;start_pos&quot;</span><span class="s1">] = seq_type(start_pos)</span>

                <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">expected_color)</span>
                <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__valid_end_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts different end_pos formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2  </span><span class="s3"># end position</span>

        <span class="s3"># The point values can be ints or floats.</span>
        <span class="s0">for </span><span class="s1">end_pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.2</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.2</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.2</span><span class="s1">)):</span>
            <span class="s3"># The point type can be a tuple/list/Vector2.</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">Vector2):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;end_pos&quot;</span><span class="s1">] = seq_type(end_pos)</span>

                <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">expected_color)</span>
                <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__invalid_start_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line handles invalid start_pos formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">start_pos_fmts = (</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too few coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too many coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">{</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">dict(((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Wrong type.</span>

        <span class="s0">for </span><span class="s1">start_pos </span><span class="s0">in </span><span class="s1">start_pos_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;start_pos&quot;</span><span class="s1">] = start_pos</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_line__invalid_end_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line handles invalid end_pos formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">end_pos_fmts = (</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too few coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too many coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">{</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">dict(((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Wrong type.</span>

        <span class="s0">for </span><span class="s1">end_pos </span><span class="s0">in </span><span class="s1">end_pos_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;end_pos&quot;</span><span class="s1">] = end_pos</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_line__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: pos</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">3</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">greens = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">greens:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_line__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_line(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_line__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the line drawn is the correct color.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self.COLORS:</span>
                <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line__color_with_thickness(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures a thick line is drawn using the correct color.&quot;&quot;&quot;</span>
        <span class="s1">from_x = </span><span class="s5">5</span>
        <span class="s1">to_x = </span><span class="s5">10</span>
        <span class="s1">y = </span><span class="s5">5</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self.COLORS:</span>
                <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">(from_x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(to_x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y + i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">(from_x</span><span class="s0">, </span><span class="s1">to_x)):</span>
                    <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the line drawn contains any gaps.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s1">width = surface.get_width()</span>
            <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
                <span class="s1">pos = (x</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line__gaps_with_thickness(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures a thick line is drawn without any gaps.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">thickness = </span><span class="s5">5</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s1">width = surface.get_width() - </span><span class="s5">1</span>
            <span class="s1">h = width // </span><span class="s5">5</span>
            <span class="s1">w = h * </span><span class="s5">5</span>
            <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(w</span><span class="s0">, </span><span class="s5">5 </span><span class="s1">+ h)</span><span class="s0">, </span><span class="s1">thickness)</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(w + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">):</span>
                    <span class="s1">pos = (x</span><span class="s0">, </span><span class="s1">y + ((x + </span><span class="s5">2</span><span class="s1">) // </span><span class="s5">5</span><span class="s1">))</span>
                    <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line returns the correct bounding rect. 
 
        Tests lines with endpoints on and off the surface and a range of 
        width/thickness values. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">PythonDrawTestCase):</span>
            <span class="s1">self.skipTest(</span><span class="s2">&quot;bounding rects not supported in draw_py.draw_line&quot;</span><span class="s1">)</span>

        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">width = height = </span><span class="s5">30</span>
        <span class="s3"># Using a rect to help manage where the lines are drawn.</span>
        <span class="s1">helper_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s3"># Testing surfaces of different sizes. One larger than the helper_rect</span>
        <span class="s3"># and one smaller (to test lines that span the surface).</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((width + </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height + </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">5</span><span class="s1">)):</span>
            <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
            <span class="s1">surf_rect = surface.get_rect()</span>

            <span class="s3"># Move the helper rect to different positions to test line</span>
            <span class="s3"># endpoints on and off the surface.</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(surf_rect):</span>
                <span class="s1">helper_rect.center = pos</span>

                <span class="s3"># Draw using different thicknesses.</span>
                <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s1">):</span>
                    <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end </span><span class="s0">in </span><span class="s1">self._rect_lines(helper_rect):</span>
                        <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                        <span class="s1">bounding_rect = self.draw_line(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">thickness</span>
                        <span class="s1">)</span>

                        <span class="s0">if </span><span class="s5">0 </span><span class="s1">&lt; thickness:</span>
                            <span class="s3"># Calculating the expected_rect after the line is</span>
                            <span class="s3"># drawn (it uses what is actually drawn).</span>
                            <span class="s1">expected_rect = create_bounding_rect(</span>
                                <span class="s1">surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">start</span>
                            <span class="s1">)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s3"># Nothing drawn.</span>
                            <span class="s1">expected_rect = pygame.Rect(start</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

                        <span class="s1">self.assertEqual(</span>
                            <span class="s1">bounding_rect</span><span class="s0">,</span>
                            <span class="s1">expected_rect</span><span class="s0">,</span>
                            <span class="s2">&quot;start={}, end={}, size={}, thickness={}&quot;</span><span class="s1">.format(</span>
                                <span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">thickness</span>
                            <span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw line respects a surface's clip area.&quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">11</span><span class="s0">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">pos_rect = clip_rect.copy()  </span><span class="s3"># Manages the line's pos.</span>

        <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">):  </span><span class="s3"># Test different line widths.</span>
            <span class="s3"># Test centering the line along the clip rect's edge.</span>
            <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
                <span class="s3"># Get the expected points by drawing the line without the</span>
                <span class="s3"># clip area set.</span>
                <span class="s1">pos_rect.center = center</span>
                <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">self.draw_line(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.midbottom</span><span class="s0">, </span><span class="s1">thickness</span>
                <span class="s1">)</span>
                <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">clip_rect)</span>

                <span class="s3"># Clear the surface and set the clip area. Redraw the line</span>
                <span class="s3"># and check that only the clip area is modified.</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">surface.set_clip(clip_rect)</span>

                <span class="s1">self.draw_line(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.midbottom</span><span class="s0">, </span><span class="s1">thickness</span>
                <span class="s1">)</span>

                <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                <span class="s3"># Check all the surface points to ensure only the expected_pts</span>
                <span class="s3"># are the line_color.</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                    <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                        <span class="s1">expected_color = line_color</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_color = surface_color</span>

                    <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pt)</span>

                <span class="s1">surface.unlock()</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever fully supports drawing single lines.</span>
<span class="s3"># @unittest.skip('draw_py.draw_line not fully supported yet')</span>
<span class="s3"># class PythonDrawLineTest(LineMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function line.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from LineMixin. It is also the class</span>
<span class="s3">#    to add any draw_py.draw_line specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">DrawLineTest(LineMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function line. 
 
    This class inherits the general tests from LineMixin. It is also the class 
    to add any draw.line specific tests to. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_line_endianness(self):</span>
        <span class="s4">&quot;&quot;&quot;test color component order&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s5">24</span><span class="s0">, </span><span class="s5">32</span><span class="s1">):</span>
            <span class="s1">surface = pygame.Surface((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">depth)</span>
            <span class="s1">surface.fill(pygame.Color(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s1">self.assertGreater(surface.get_at((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)).r</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">&quot;there should be red here&quot;</span><span class="s1">)</span>

            <span class="s1">surface.fill(pygame.Color(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">self.draw_line(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s1">self.assertGreater(surface.get_at((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)).b</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">&quot;there should be blue here&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_line(self):</span>
        <span class="s3"># (l, t), (l, t)</span>
        <span class="s1">self.surf_size = (</span><span class="s5">320</span><span class="s0">, </span><span class="s5">200</span><span class="s1">)</span>
        <span class="s1">self.surf = pygame.Surface(self.surf_size</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA)</span>
        <span class="s1">self.color = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">13</span><span class="s0">, </span><span class="s5">24</span><span class="s0">, </span><span class="s5">205</span><span class="s1">)</span>

        <span class="s1">drawn = draw.line(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">200</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">drawn.right</span><span class="s0">, </span><span class="s5">201</span><span class="s0">, </span><span class="s2">&quot;end point arg should be (or at least was) inclusive&quot;</span>
        <span class="s1">)</span>

        <span class="s3"># Should be colored where it's supposed to be</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(drawn):</span>
            <span class="s1">self.assertEqual(self.surf.get_at(pt)</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s3"># And not where it shouldn't</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_outer_bounds(drawn):</span>
            <span class="s1">self.assertNotEqual(self.surf.get_at(pt)</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s3"># Line width greater that 1</span>
        <span class="s1">line_width = </span><span class="s5">2</span>
        <span class="s1">offset = </span><span class="s5">5</span>
        <span class="s1">a = (offset</span><span class="s0">, </span><span class="s1">offset)</span>
        <span class="s1">b = (self.surf_size[</span><span class="s5">0</span><span class="s1">] - offset</span><span class="s0">, </span><span class="s1">a[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">c = (a[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.surf_size[</span><span class="s5">1</span><span class="s1">] - offset)</span>
        <span class="s1">d = (b[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">e = (a[</span><span class="s5">0</span><span class="s1">] + offset</span><span class="s0">, </span><span class="s1">c[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">f = (b[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">lines = [</span>
            <span class="s1">(a</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">,</span>
            <span class="s1">(b</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">,</span>
            <span class="s1">(c</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
            <span class="s1">(d</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
            <span class="s1">(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
            <span class="s1">(b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
            <span class="s1">(a</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">,</span>
            <span class="s1">(c</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
            <span class="s1">(a</span><span class="s0">, </span><span class="s1">e)</span><span class="s0">,</span>
            <span class="s1">(e</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
            <span class="s1">(a</span><span class="s0">, </span><span class="s1">f)</span><span class="s0">,</span>
            <span class="s1">(f</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
            <span class="s1">(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">p2 </span><span class="s0">in </span><span class="s1">lines:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">p1</span><span class="s0">} </span><span class="s2">- </span><span class="s0">{</span><span class="s1">p2</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s0">if </span><span class="s1">p1[</span><span class="s5">0</span><span class="s1">] &lt;= p2[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s1">plow = p1</span>
                <span class="s1">phigh = p2</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">plow = p2</span>
                <span class="s1">phigh = p1</span>

            <span class="s1">self.surf.fill((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">rec = draw.line(self.surf</span><span class="s0">, </span><span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">p1</span><span class="s0">, </span><span class="s1">p2</span><span class="s0">, </span><span class="s1">line_width)</span>
            <span class="s1">xinc = yinc = </span><span class="s5">0</span>

            <span class="s0">if </span><span class="s1">abs(p1[</span><span class="s5">0</span><span class="s1">] - p2[</span><span class="s5">0</span><span class="s1">]) &gt; abs(p1[</span><span class="s5">1</span><span class="s1">] - p2[</span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s1">yinc = </span><span class="s5">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">xinc = </span><span class="s5">1</span>

            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(line_width):</span>
                <span class="s1">p = (p1[</span><span class="s5">0</span><span class="s1">] + xinc * i</span><span class="s0">, </span><span class="s1">p1[</span><span class="s5">1</span><span class="s1">] + yinc * i)</span>
                <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>

                <span class="s1">p = (p2[</span><span class="s5">0</span><span class="s1">] + xinc * i</span><span class="s0">, </span><span class="s1">p2[</span><span class="s5">1</span><span class="s1">] + yinc * i)</span>
                <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s1">p = (plow[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">plow[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s1">p = (plow[</span><span class="s5">0</span><span class="s1">] + xinc * line_width</span><span class="s0">, </span><span class="s1">plow[</span><span class="s5">1</span><span class="s1">] + yinc * line_width)</span>
            <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s1">p = (phigh[</span><span class="s5">0</span><span class="s1">] + xinc * line_width</span><span class="s0">, </span><span class="s1">phigh[</span><span class="s5">1</span><span class="s1">] + yinc * line_width)</span>
            <span class="s1">self.assertEqual(self.surf.get_at(p)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s0">if </span><span class="s1">p1[</span><span class="s5">0</span><span class="s1">] &lt; p2[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s1">rx = p1[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">rx = p2[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">p1[</span><span class="s5">1</span><span class="s1">] &lt; p2[</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s1">ry = p1[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ry = p2[</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s1">w = abs(p2[</span><span class="s5">0</span><span class="s1">] - p1[</span><span class="s5">0</span><span class="s1">]) + </span><span class="s5">1 </span><span class="s1">+ xinc * (line_width - </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">h = abs(p2[</span><span class="s5">1</span><span class="s1">] - p1[</span><span class="s5">1</span><span class="s1">]) + </span><span class="s5">1 </span><span class="s1">+ yinc * (line_width - </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">msg += </span><span class="s2">f&quot;, </span><span class="s0">{</span><span class="s1">rec</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">self.assertEqual(rec</span><span class="s0">, </span><span class="s1">(rx</span><span class="s0">, </span><span class="s1">ry</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">h)</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_line_for_gaps(self):</span>
        <span class="s3"># This checks bug Thick Line Bug #448</span>

        <span class="s1">width = </span><span class="s5">200</span>
        <span class="s1">height = </span><span class="s5">200</span>
        <span class="s1">surf = pygame.Surface((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA)</span>

        <span class="s0">def </span><span class="s1">white_surrounded_pixels(x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s1">offsets = [(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)]</span>
            <span class="s1">WHITE = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">len(</span>
                <span class="s1">[</span><span class="s5">1 </span><span class="s0">for </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy </span><span class="s0">in </span><span class="s1">offsets </span><span class="s0">if </span><span class="s1">surf.get_at((x + dx</span><span class="s0">, </span><span class="s1">y + dy)) == WHITE]</span>
            <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">check_white_line(start</span><span class="s0">, </span><span class="s1">end):</span>
            <span class="s1">surf.fill((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">pygame.draw.line(surf</span><span class="s0">, </span><span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span>

            <span class="s1">BLACK = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">width - </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s0">if </span><span class="s1">surf.get_at((x</span><span class="s0">, </span><span class="s1">y)) == BLACK:</span>
                        <span class="s1">self.assertTrue(white_surrounded_pixels(x</span><span class="s0">, </span><span class="s1">y) &lt; </span><span class="s5">3</span><span class="s1">)</span>

        <span class="s1">check_white_line((</span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">140</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">check_white_line((</span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">120</span><span class="s1">))</span>
        <span class="s1">check_white_line((</span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">199</span><span class="s0">, </span><span class="s5">198</span><span class="s1">))</span>


<span class="s3">### Lines Testing #############################################################</span>


<span class="s0">class </span><span class="s1">LinesMixin(BaseLineMixin):</span>
    <span class="s4">&quot;&quot;&quot;Mixin test for drawing lines. 
 
    This class contains all the general lines drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_lines__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_lines(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, False, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__args_without_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts the args without a width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_lines(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, False, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts the correct kwargs 
        with and without a width arg. 
        &quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">points = ((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False, </span><span class="s2">&quot;points&quot;</span><span class="s1">: points}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_lines(</span>
            <span class="s1">closed=</span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">points=((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">color=(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_lines(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_lines()</span>

    <span class="s0">def </span><span class="s1">test_lines__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;points&quot;</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_lines(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_lines__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">closed = </span><span class="s5">0</span>
        <span class="s1">points = ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid width.</span>
            <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid points.</span>
            <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid closed.</span>
            <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">InvalidBool()</span><span class="s0">, </span><span class="s1">points)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_lines((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points)</span>

    <span class="s0">def </span><span class="s1">test_lines__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">valid_kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">invalid_kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: InvalidBool()</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1.2</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">kwarg </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs = dict(valid_kwargs)</span>
            <span class="s1">kwargs[kwarg] = invalid_kwargs[kwarg]</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_lines__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">closed = </span><span class="s5">1</span>
        <span class="s1">points = ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;closed&quot;</span><span class="s1">: closed</span><span class="s0">,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;closed&quot;</span><span class="s1">: closed</span><span class="s0">,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_lines__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">closed = </span><span class="s5">0</span>
        <span class="s1">points = ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">width = </span><span class="s5">1</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: closed</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;closed&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;points&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_lines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_lines(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__valid_width_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts different width values.&quot;&quot;&quot;</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: line_color</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: (pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">100</span><span class="s0">, </span><span class="s1">-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">100</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width</span>
            <span class="s1">expected_color = line_color </span><span class="s0">if </span><span class="s1">width &gt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__valid_points_format(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts different points formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># The point type can be a tuple/list/Vector2.</span>
        <span class="s1">point_types = (</span>
            <span class="s1">(tuple</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">tuple)</span><span class="s0">,  </span><span class="s3"># all tuples</span>
            <span class="s1">(list</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">list)</span><span class="s0">,  </span><span class="s3"># all lists</span>
            <span class="s1">(Vector2</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">Vector2)</span><span class="s0">,  </span><span class="s3"># all Vector2s</span>
            <span class="s1">(list</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">Vector2)</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># mix</span>

        <span class="s3"># The point values can be ints or floats.</span>
        <span class="s1">point_values = (</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.1</span><span class="s0">, </span><span class="s5">2.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2.1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># Each sequence of points can be a tuple or a list.</span>
        <span class="s1">seq_types = (tuple</span><span class="s0">, </span><span class="s1">list)</span>

        <span class="s0">for </span><span class="s1">point_type </span><span class="s0">in </span><span class="s1">point_types:</span>
            <span class="s0">for </span><span class="s1">values </span><span class="s0">in </span><span class="s1">point_values:</span>
                <span class="s1">check_pos = values[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">points = [point_type[i](pt) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">enumerate(values)]</span>

                <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">seq_types:</span>
                    <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                    <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = seq_type(points)</span>

                    <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

                    <span class="s1">self.assertEqual(surface.get_at(check_pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
                    <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__invalid_points_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines handles invalid points formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">points_fmts = (</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Too few coords.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Too many coords.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">})</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dict(((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))))</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">{(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)}</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">dict(((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Wrong type.</span>

        <span class="s0">for </span><span class="s1">points </span><span class="s0">in </span><span class="s1">points_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = points</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_lines__invalid_points_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines handles invalid points values correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">points </span><span class="s0">in </span><span class="s1">([]</span><span class="s0">, </span><span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)):  </span><span class="s3"># Too few points.</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list):  </span><span class="s3"># Test as tuples and lists.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = seq_type(points)</span>

                <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                    <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_lines__valid_closed_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts different closed values.&quot;&quot;&quot;</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: line_color</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">true_values = (-</span><span class="s5">7</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s5">3.1</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">5</span><span class="s1">]</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">false_values = (</span><span class="s0">None, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">closed </span><span class="s0">in </span><span class="s1">true_values + false_values:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;closed&quot;</span><span class="s1">] = closed</span>
            <span class="s1">expected_color = line_color </span><span class="s0">if </span><span class="s1">closed </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: (pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">3</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">greens = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">greens:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_lines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_lines__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the lines drawn are the correct color. 
 
        Draws lines around the border of the given surface and checks if all 
        borders of the surface only contain the given color. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self.COLORS:</span>
                <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">corners(surface))</span>

                <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                    <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_lines__color_with_thickness(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures thick lines are drawn using the correct color.&quot;&quot;&quot;</span>
        <span class="s1">x_left = y_top = </span><span class="s5">5</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s1">x_right = surface.get_width() - </span><span class="s5">5</span>
            <span class="s1">y_bottom = surface.get_height() - </span><span class="s5">5</span>
            <span class="s1">endpoints = (</span>
                <span class="s1">(x_left</span><span class="s0">, </span><span class="s1">y_top)</span><span class="s0">,</span>
                <span class="s1">(x_right</span><span class="s0">, </span><span class="s1">y_top)</span><span class="s0">,</span>
                <span class="s1">(x_right</span><span class="s0">, </span><span class="s1">y_bottom)</span><span class="s0">,</span>
                <span class="s1">(x_left</span><span class="s0">, </span><span class="s1">y_bottom)</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self.COLORS:</span>
                <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">endpoints</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>

                <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(x_left</span><span class="s0">, </span><span class="s1">x_right + </span><span class="s5">1</span><span class="s1">):</span>
                        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">(y_top</span><span class="s0">, </span><span class="s1">y_bottom):</span>
                            <span class="s1">pos = (x</span><span class="s0">, </span><span class="s1">y + t)</span>
                            <span class="s1">self.assertEqual(</span>
                                <span class="s1">surface.get_at(pos)</span><span class="s0">,</span>
                                <span class="s1">expected_color</span><span class="s0">,</span>
                                <span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
                            <span class="s1">)</span>
                    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(y_top</span><span class="s0">, </span><span class="s1">y_bottom + </span><span class="s5">1</span><span class="s1">):</span>
                        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">(x_left</span><span class="s0">, </span><span class="s1">x_right):</span>
                            <span class="s1">pos = (x + t</span><span class="s0">, </span><span class="s1">y)</span>
                            <span class="s1">self.assertEqual(</span>
                                <span class="s1">surface.get_at(pos)</span><span class="s0">,</span>
                                <span class="s1">expected_color</span><span class="s0">,</span>
                                <span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
                            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_lines__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the lines drawn contain any gaps. 
 
        Draws lines around the border of the given surface and checks if 
        all borders of the surface contain any gaps. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">corners(surface))</span>

            <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_lines__gaps_with_thickness(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures thick lines are drawn without any gaps.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">x_left = y_top = </span><span class="s5">5</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s1">h = (surface.get_width() - </span><span class="s5">11</span><span class="s1">) // </span><span class="s5">5</span>
            <span class="s1">w = h * </span><span class="s5">5</span>
            <span class="s1">x_right = x_left + w</span>
            <span class="s1">y_bottom = y_top + h</span>
            <span class="s1">endpoints = ((x_left</span><span class="s0">, </span><span class="s1">y_top)</span><span class="s0">, </span><span class="s1">(x_right</span><span class="s0">, </span><span class="s1">y_top)</span><span class="s0">, </span><span class="s1">(x_right</span><span class="s0">, </span><span class="s1">y_bottom))</span>
            <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">endpoints</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(x_left</span><span class="s0">, </span><span class="s1">x_right + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s1">pos = (x</span><span class="s0">, </span><span class="s1">y_top + t)</span>
                    <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
                    <span class="s1">pos = (x</span><span class="s0">, </span><span class="s1">y_top + t + ((x - </span><span class="s5">3</span><span class="s1">) // </span><span class="s5">5</span><span class="s1">))</span>
                    <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(y_top</span><span class="s0">, </span><span class="s1">y_bottom + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s1">pos = (x_right + t</span><span class="s0">, </span><span class="s1">y)</span>
                    <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_lines__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines returns the correct bounding rect. 
 
        Tests lines with endpoints on and off the surface and a range of 
        width/thickness values. 
        &quot;&quot;&quot;</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">width = height = </span><span class="s5">30</span>
        <span class="s3"># Using a rect to help manage where the lines are drawn.</span>
        <span class="s1">pos_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s3"># Testing surfaces of different sizes. One larger than the pos_rect</span>
        <span class="s3"># and one smaller (to test lines that span the surface).</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((width + </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height + </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">5</span><span class="s1">)):</span>
            <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
            <span class="s1">surf_rect = surface.get_rect()</span>

            <span class="s3"># Move pos_rect to different positions to test line endpoints on</span>
            <span class="s3"># and off the surface.</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(surf_rect):</span>
                <span class="s1">pos_rect.center = pos</span>
                <span class="s3"># Shape: Triangle (if closed), ^ caret (if not closed).</span>
                <span class="s1">pts = (pos_rect.midleft</span><span class="s0">, </span><span class="s1">pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.midright)</span>
                <span class="s1">pos = pts[</span><span class="s5">0</span><span class="s1">]  </span><span class="s3"># Rect position if nothing drawn.</span>

                <span class="s3"># Draw using different thickness and closed values.</span>
                <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s1">):</span>
                    <span class="s0">for </span><span class="s1">closed </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                        <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                        <span class="s1">bounding_rect = self.draw_lines(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">pts</span><span class="s0">, </span><span class="s1">thickness</span>
                        <span class="s1">)</span>

                        <span class="s0">if </span><span class="s5">0 </span><span class="s1">&lt; thickness:</span>
                            <span class="s3"># Calculating the expected_rect after the lines are</span>
                            <span class="s3"># drawn (it uses what is actually drawn).</span>
                            <span class="s1">expected_rect = create_bounding_rect(</span>
                                <span class="s1">surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">pos</span>
                            <span class="s1">)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s3"># Nothing drawn.</span>
                            <span class="s1">expected_rect = pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

                        <span class="s1">self.assertEqual(bounding_rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_lines__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw lines respects a surface's clip area.&quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">11</span><span class="s0">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">pos_rect = clip_rect.copy()  </span><span class="s3"># Manages the lines's pos.</span>

        <span class="s3"># Test centering the pos_rect along the clip rect's edge to allow for</span>
        <span class="s3"># drawing the lines over the clip_rect's bounds.</span>
        <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
            <span class="s1">pos_rect.center = center</span>
            <span class="s1">pts = (pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.center</span><span class="s0">, </span><span class="s1">pos_rect.midbottom)</span>

            <span class="s0">for </span><span class="s1">closed </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):  </span><span class="s3"># Test closed and not closed.</span>
                <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">):  </span><span class="s3"># Test different line widths.</span>
                    <span class="s3"># Get the expected points by drawing the lines without the</span>
                    <span class="s3"># clip area set.</span>
                    <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                    <span class="s1">surface.fill(surface_color)</span>
                    <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">pts</span><span class="s0">, </span><span class="s1">thickness)</span>
                    <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">clip_rect)</span>

                    <span class="s3"># Clear the surface and set the clip area. Redraw the lines</span>
                    <span class="s3"># and check that only the clip area is modified.</span>
                    <span class="s1">surface.fill(surface_color)</span>
                    <span class="s1">surface.set_clip(clip_rect)</span>

                    <span class="s1">self.draw_lines(surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">pts</span><span class="s0">, </span><span class="s1">thickness)</span>

                    <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                    <span class="s3"># Check all the surface points to ensure only the</span>
                    <span class="s3"># expected_pts are the line_color.</span>
                    <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                        <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                            <span class="s1">expected_color = line_color</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">expected_color = surface_color</span>

                        <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pt)</span>

                    <span class="s1">surface.unlock()</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever fully supports drawing lines.</span>
<span class="s3"># class PythonDrawLinesTest(LinesMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function lines.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from LinesMixin. It is also the</span>
<span class="s3">#    class to add any draw_py.draw_lines specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">DrawLinesTest(LinesMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function lines. 
 
    This class inherits the general tests from LinesMixin. It is also the class 
    to add any draw.lines specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s3">### AALine Testing ############################################################</span>


<span class="s0">class </span><span class="s1">AALineMixin(BaseLineMixin):</span>
    <span class="s4">&quot;&quot;&quot;Mixin test for drawing a single aaline. 
 
    This class contains all the general single aaline drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_aaline__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_aaline(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aaline__args_without_blend(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline accepts the args without a blend.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_aaline(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aaline__blend_warning(self):</span>
        <span class="s4">&quot;&quot;&quot;From pygame 2, blend=False should raise DeprecationWarning.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s3"># Cause all warnings to always be triggered.</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s3"># Trigger DeprecationWarning.</span>
            <span class="s1">self.draw_aaline(</span>
                <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, False</span>
            <span class="s1">)</span>
            <span class="s3"># Check if there is only one warning and is a DeprecationWarning.</span>
            <span class="s1">self.assertEqual(len(w)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.assertTrue(issubclass(w[-</span><span class="s5">1</span><span class="s1">].category</span><span class="s0">, </span><span class="s1">DeprecationWarning))</span>

    <span class="s0">def </span><span class="s1">test_aaline__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline accepts the correct kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aaline__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_aaline(</span>
            <span class="s1">start_pos=(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">end_pos=(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">color=(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aaline__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aaline(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aaline()</span>

    <span class="s0">def </span><span class="s1">test_aaline__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;end_pos&quot;</span><span class="s0">, </span><span class="s2">&quot;start_pos&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aaline(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aaline__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid end_pos.</span>
            <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid start_pos.</span>
            <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">end_pos)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s2">&quot;invalid-color&quot;</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_aaline((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos)</span>

    <span class="s0">def </span><span class="s1">test_aaline__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,  </span><span class="s3"># Invalid surface.</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,  </span><span class="s3"># Invalid color.</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid start_pos.</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid end_pos.</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aaline__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
                <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aaline__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">start_pos = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">end_pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: start_pos</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: end_pos</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;start_pos&quot;</span><span class="s0">, </span><span class="s2">&quot;end_pos&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;start_pos&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;end_pos&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aaline(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_aaline(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">start_pos</span><span class="s0">, </span><span class="s1">end_pos</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aaline__valid_start_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline accepts different start_pos formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1  </span><span class="s3"># start position</span>
        <span class="s1">positions = ((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.01</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.01</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.01</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.01</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">start_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">Vector2):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;start_pos&quot;</span><span class="s1">] = seq_type(start_pos)</span>

                <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

                <span class="s1">color = surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">sub_color </span><span class="s0">in </span><span class="s1">enumerate(expected_color):</span>
                    <span class="s3"># The color could be slightly off the expected color due to</span>
                    <span class="s3"># any fractional position arguments.</span>
                    <span class="s1">self.assertGreaterEqual(color[i] + </span><span class="s5">6</span><span class="s0">, </span><span class="s1">sub_color</span><span class="s0">, </span><span class="s1">start_pos)</span>
                <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect</span><span class="s0">, </span><span class="s1">start_pos)</span>

    <span class="s0">def </span><span class="s1">test_aaline__valid_end_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline accepts different end_pos formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2  </span><span class="s3"># end position</span>
        <span class="s1">positions = ((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.02</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.02</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.02</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.02</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">end_pos </span><span class="s0">in </span><span class="s1">positions:</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">Vector2):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;end_pos&quot;</span><span class="s1">] = seq_type(end_pos)</span>

                <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

                <span class="s1">color = surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">sub_color </span><span class="s0">in </span><span class="s1">enumerate(expected_color):</span>
                    <span class="s3"># The color could be slightly off the expected color due to</span>
                    <span class="s3"># any fractional position arguments.</span>
                    <span class="s1">self.assertGreaterEqual(color[i] + </span><span class="s5">15</span><span class="s0">, </span><span class="s1">sub_color</span><span class="s0">, </span><span class="s1">end_pos)</span>
                <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect</span><span class="s0">, </span><span class="s1">end_pos)</span>

    <span class="s0">def </span><span class="s1">test_aaline__invalid_start_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline handles invalid start_pos formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">start_pos_fmts = (</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too few coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too many coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">{</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">dict(((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Wrong type.</span>

        <span class="s0">for </span><span class="s1">start_pos </span><span class="s0">in </span><span class="s1">start_pos_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;start_pos&quot;</span><span class="s1">] = start_pos</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aaline__invalid_end_pos_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline handles invalid end_pos formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s1">end_pos_fmts = (</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too few coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too many coords.</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">{</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">dict(((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Wrong type.</span>

        <span class="s0">for </span><span class="s1">end_pos </span><span class="s0">in </span><span class="s1">end_pos_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;end_pos&quot;</span><span class="s1">] = end_pos</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aaline__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: pos</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">greens = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">greens:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aaline__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;start_pos&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;end_pos&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aaline(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aaline__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aaline drawn is the correct color.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self.COLORS:</span>
                <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_aaline__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aaline drawn contains any gaps. 
 
        See: #512 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s1">width = surface.get_width()</span>
            <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
                <span class="s1">pos = (x</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_aaline__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline returns the correct bounding rect. 
 
        Tests lines with endpoints on and off the surface. 
        &quot;&quot;&quot;</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">width = height = </span><span class="s5">30</span>
        <span class="s3"># Using a rect to help manage where the lines are drawn.</span>
        <span class="s1">helper_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s3"># Testing surfaces of different sizes. One larger than the helper_rect</span>
        <span class="s3"># and one smaller (to test lines that span the surface).</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((width + </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height + </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">5</span><span class="s1">)):</span>
            <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
            <span class="s1">surf_rect = surface.get_rect()</span>

            <span class="s3"># Move the helper rect to different positions to test line</span>
            <span class="s3"># endpoints on and off the surface.</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(surf_rect):</span>
                <span class="s1">helper_rect.center = pos</span>

                <span class="s0">for </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end </span><span class="s0">in </span><span class="s1">self._rect_lines(helper_rect):</span>
                    <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                    <span class="s1">bounding_rect = self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>

                    <span class="s3"># Calculating the expected_rect after the line is</span>
                    <span class="s3"># drawn (it uses what is actually drawn).</span>
                    <span class="s1">expected_rect = create_bounding_rect(surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">start)</span>

                    <span class="s1">self.assertEqual(bounding_rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_aaline__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aaline respects a surface's clip area.&quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">aaline_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">11</span><span class="s0">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">pos_rect = clip_rect.copy()  </span><span class="s3"># Manages the aaline's pos.</span>

        <span class="s3"># Test centering the pos_rect along the clip rect's edge to allow for</span>
        <span class="s3"># drawing the aaline over the clip_rect's bounds.</span>
        <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
            <span class="s1">pos_rect.center = center</span>

            <span class="s3"># Get the expected points by drawing the aaline without the</span>
            <span class="s3"># clip area set.</span>
            <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">surface.fill(surface_color)</span>
            <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">aaline_color</span><span class="s0">, </span><span class="s1">pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.midbottom)</span>

            <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">clip_rect</span><span class="s0">, False</span><span class="s1">)</span>

            <span class="s3"># Clear the surface and set the clip area. Redraw the aaline</span>
            <span class="s3"># and check that only the clip area is modified.</span>
            <span class="s1">surface.fill(surface_color)</span>
            <span class="s1">surface.set_clip(clip_rect)</span>

            <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">aaline_color</span><span class="s0">, </span><span class="s1">pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.midbottom)</span>

            <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

            <span class="s3"># Check all the surface points to ensure the expected_pts</span>
            <span class="s3"># are not surface_color.</span>
            <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                    <span class="s1">self.assertNotEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">pt)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">pt)</span>

            <span class="s1">surface.unlock()</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever fully supports drawing single aalines.</span>
<span class="s3"># class PythonDrawAALineTest(AALineMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function aaline.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from AALineMixin. It is also the</span>
<span class="s3">#    class to add any draw_py.draw_aaline specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">DrawAALineTest(AALineMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function aaline. 
 
    This class inherits the general tests from AALineMixin. It is also the 
    class to add any draw.aaline specific tests to. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_aaline_endianness(self):</span>
        <span class="s4">&quot;&quot;&quot;test color component order&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s5">24</span><span class="s0">, </span><span class="s5">32</span><span class="s1">):</span>
            <span class="s1">surface = pygame.Surface((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">depth)</span>
            <span class="s1">surface.fill(pygame.Color(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s1">self.assertGreater(surface.get_at((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)).r</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">&quot;there should be red here&quot;</span><span class="s1">)</span>

            <span class="s1">surface.fill(pygame.Color(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s1">self.draw_aaline(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s1">self.assertGreater(surface.get_at((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)).b</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">&quot;there should be blue here&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_check_antialiasing(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">, </span><span class="s1">should</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">True</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;Draw a line between two points and check colors of check_points.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">set_endpoints:</span>
            <span class="s1">should[from_point] = should[to_point] = FG_GREEN</span>

        <span class="s0">def </span><span class="s1">check_one_direction(from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">, </span><span class="s1">should):</span>
            <span class="s1">self.draw_aaline(self.surface</span><span class="s0">, </span><span class="s1">FG_GREEN</span><span class="s0">, </span><span class="s1">from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">, True</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">check_points:</span>
                <span class="s1">color = should.get(pt</span><span class="s0">, </span><span class="s1">BG_RED)</span>
                <span class="s0">with </span><span class="s1">self.subTest(from_pt=from_point</span><span class="s0">, </span><span class="s1">pt=pt</span><span class="s0">, </span><span class="s1">to=to_point):</span>
                    <span class="s1">self.assertEqual(self.surface.get_at(pt)</span><span class="s0">, </span><span class="s1">color)</span>

            <span class="s3"># reset</span>
            <span class="s1">draw.rect(self.surface</span><span class="s0">, </span><span class="s1">BG_RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># it is important to test also opposite direction, the algorithm</span>
        <span class="s3"># is (#512) or was not symmetric</span>
        <span class="s1">check_one_direction(from_point</span><span class="s0">, </span><span class="s1">to_point</span><span class="s0">, </span><span class="s1">should)</span>
        <span class="s0">if </span><span class="s1">from_point != to_point:</span>
            <span class="s1">check_one_direction(to_point</span><span class="s0">, </span><span class="s1">from_point</span><span class="s0">, </span><span class="s1">should)</span>

    <span class="s0">def </span><span class="s1">test_short_non_antialiased_lines(self):</span>
        <span class="s4">&quot;&quot;&quot;test very short not anti aliased lines in all directions.&quot;&quot;&quot;</span>

        <span class="s3"># Horizontal, vertical and diagonal lines should not be anti-aliased,</span>
        <span class="s3"># even with draw.aaline ...</span>
        <span class="s1">self.surface = pygame.Surface((</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">draw.rect(self.surface</span><span class="s0">, </span><span class="s1">BG_RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">check_both_directions(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">other_points):</span>
            <span class="s1">should = {pt: FG_GREEN </span><span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">other_points}</span>
            <span class="s1">self._check_antialiasing(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">should</span><span class="s0">, </span><span class="s1">check_points)</span>

        <span class="s3"># 0. one point</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s3"># 1. horizontal</span>
        <span class="s1">check_both_directions((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)])</span>

        <span class="s3"># 2. vertical</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)])</span>
        <span class="s3"># 3. diagonals</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)])</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">check_both_directions((</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)])</span>

    <span class="s0">def </span><span class="s1">test_short_line_anti_aliasing(self):</span>

        <span class="s1">self.surface = pygame.Surface((</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">draw.rect(self.surface</span><span class="s0">, </span><span class="s1">BG_RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">check_both_directions(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">should):</span>
            <span class="s1">self._check_antialiasing(from_pt</span><span class="s0">, </span><span class="s1">to_pt</span><span class="s0">, </span><span class="s1">should</span><span class="s0">, </span><span class="s1">check_points)</span>

        <span class="s1">brown = (</span><span class="s5">127</span><span class="s0">, </span><span class="s5">127</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">reddish = (</span><span class="s5">191</span><span class="s0">, </span><span class="s5">63</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">greenish = (</span><span class="s5">63</span><span class="s0">, </span><span class="s5">191</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># lets say dx = abs(x0 - x1) ; dy = abs(y0 - y1)</span>

        <span class="s3"># dy / dx = 0.5</span>
        <span class="s1">check_both_directions((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown})</span>
        <span class="s1">check_both_directions((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown})</span>

        <span class="s3"># dy / dx = 2</span>
        <span class="s1">check_both_directions((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown})</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown})</span>

        <span class="s3"># some little longer lines; so we need to check more points:</span>
        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">9</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">9</span><span class="s1">)]</span>
        <span class="s3"># dy / dx = 0.25</span>
        <span class="s1">should = {</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): greenish</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">check_both_directions((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>

        <span class="s1">should = {</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): reddish</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">check_both_directions((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>

        <span class="s3"># dy / dx = 4</span>
        <span class="s1">should = {</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">6</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">): greenish</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">check_both_directions((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>

        <span class="s1">should = {</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">6</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s1">): reddish</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">check_both_directions((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">should)</span>

    <span class="s0">def </span><span class="s1">test_anti_aliasing_float_coordinates(self):</span>
        <span class="s4">&quot;&quot;&quot;Float coordinates should be blended smoothly.&quot;&quot;&quot;</span>

        <span class="s1">self.surface = pygame.Surface((</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">draw.rect(self.surface</span><span class="s0">, </span><span class="s1">BG_RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">)]</span>
        <span class="s1">brown = (</span><span class="s5">127</span><span class="s0">, </span><span class="s5">127</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">reddish = (</span><span class="s5">191</span><span class="s0">, </span><span class="s5">63</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">greenish = (</span><span class="s5">63</span><span class="s0">, </span><span class="s5">191</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># 0. identical point : current implementation does no smoothing...</span>
        <span class="s1">expected = {(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): FG_GREEN}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): FG_GREEN}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">2.49</span><span class="s0">, </span><span class="s5">2.7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.49</span><span class="s0">, </span><span class="s5">2.7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>

        <span class="s3"># 1. horizontal lines</span>
        <span class="s3">#  a) blend endpoints</span>
        <span class="s1">expected = {(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): FG_GREEN}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): FG_GREEN}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): greenish}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1.75</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>

        <span class="s3">#  b) blend y-coordinate</span>
        <span class="s1">expected = {(x</span><span class="s0">, </span><span class="s1">y): brown </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>

        <span class="s3"># 2. vertical lines</span>
        <span class="s3">#  a) blend endpoints</span>
        <span class="s1">expected = {(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): greenish}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1.75</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s3">#  b) blend x-coordinate</span>
        <span class="s1">expected = {(x</span><span class="s0">, </span><span class="s1">y): brown </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s3"># 3. diagonal lines</span>
        <span class="s3">#  a) blend endpoints</span>
        <span class="s1">expected = {(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s1">expected = {(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): FG_GREEN</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">2.5</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s3">#  b) blend sidewards</span>
        <span class="s1">expected = {(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): brown</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): brown}</span>
        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>

        <span class="s1">expected = {</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): reddish</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">self._check_antialiasing(</span>
            <span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1.25</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3.25</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points</span><span class="s0">, </span><span class="s1">set_endpoints=</span><span class="s0">False</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_anti_aliasing_at_and_outside_the_border(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures antialiasing works correct at a surface's borders.&quot;&quot;&quot;</span>

        <span class="s1">self.surface = pygame.Surface((</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">draw.rect(self.surface</span><span class="s0">, </span><span class="s1">BG_RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">check_points = [(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">)]</span>

        <span class="s1">reddish = (</span><span class="s5">191</span><span class="s0">, </span><span class="s5">63</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">brown = (</span><span class="s5">127</span><span class="s0">, </span><span class="s5">127</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">greenish = (</span><span class="s5">63</span><span class="s0">, </span><span class="s5">191</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">from_point</span><span class="s0">, </span><span class="s1">to_point = (</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">should = {</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): greenish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">3</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): reddish</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): brown</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">): greenish</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s1">(-</span><span class="s5">4</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># moved to left and right borders</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">4</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># upper border</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">7</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># lower border</span>
            <span class="s1">(-</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">4</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(-</span><span class="s5">4</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(-</span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">4</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">):  </span><span class="s3"># upper left corner</span>
            <span class="s1">first = from_point[</span><span class="s5">0</span><span class="s1">] + dx</span><span class="s0">, </span><span class="s1">from_point[</span><span class="s5">1</span><span class="s1">] + dy</span>
            <span class="s1">second = to_point[</span><span class="s5">0</span><span class="s1">] + dx</span><span class="s0">, </span><span class="s1">to_point[</span><span class="s5">1</span><span class="s1">] + dy</span>
            <span class="s1">expected = {(x + dx</span><span class="s0">, </span><span class="s1">y + dy): color </span><span class="s0">for </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">should.items()}</span>

            <span class="s1">self._check_antialiasing(first</span><span class="s0">, </span><span class="s1">second</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_points)</span>


<span class="s3">### AALines Testing ###########################################################</span>


<span class="s0">class </span><span class="s1">AALinesMixin(BaseLineMixin):</span>
    <span class="s4">&quot;&quot;&quot;Mixin test for drawing aalines. 
 
    This class contains all the general aalines drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_aalines__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_aalines(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, False, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__args_without_blend(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines accepts the args without a blend.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_aalines(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, False, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__blend_warning(self):</span>
        <span class="s4">&quot;&quot;&quot;From pygame 2, blend=False should raise DeprecationWarning.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s3"># Cause all warnings to always be triggered.</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s3"># Trigger DeprecationWarning.</span>
            <span class="s1">self.draw_aalines(</span>
                <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, False, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, False</span>
            <span class="s1">)</span>
            <span class="s3"># Check if there is only one warning and is a DeprecationWarning.</span>
            <span class="s1">self.assertEqual(len(w)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.assertTrue(issubclass(w[-</span><span class="s5">1</span><span class="s1">].category</span><span class="s0">, </span><span class="s1">DeprecationWarning))</span>

    <span class="s0">def </span><span class="s1">test_aalines__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines accepts the correct kwargs.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">points = ((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False, </span><span class="s2">&quot;points&quot;</span><span class="s1">: points}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_aalines(</span>
            <span class="s1">closed=</span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">points=((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">color=(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aalines(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_aalines()</span>

    <span class="s0">def </span><span class="s1">test_aalines__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;points&quot;</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aalines(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aalines__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">closed = </span><span class="s5">0</span>
        <span class="s1">points = ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid blend.</span>
            <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid points.</span>
            <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid closed.</span>
            <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">InvalidBool()</span><span class="s0">, </span><span class="s1">points)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_aalines((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points)</span>

    <span class="s0">def </span><span class="s1">test_aalines__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">valid_kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">invalid_kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: InvalidBool()</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">kwarg </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs = dict(valid_kwargs)</span>
            <span class="s1">kwargs[kwarg] = invalid_kwargs[kwarg]</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aalines__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">closed = </span><span class="s5">1</span>
        <span class="s1">points = ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;closed&quot;</span><span class="s1">: closed</span><span class="s0">,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;closed&quot;</span><span class="s1">: closed</span><span class="s0">,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aalines__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">closed = </span><span class="s5">0</span>
        <span class="s1">points = ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: closed</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;closed&quot;</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;closed&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;points&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_aalines(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_aalines(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__valid_points_format(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines accepts different points formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s3"># The point type can be a tuple/list/Vector2.</span>
        <span class="s1">point_types = (</span>
            <span class="s1">(tuple</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">tuple)</span><span class="s0">,  </span><span class="s3"># all tuples</span>
            <span class="s1">(list</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">list)</span><span class="s0">,  </span><span class="s3"># all lists</span>
            <span class="s1">(Vector2</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">Vector2)</span><span class="s0">,  </span><span class="s3"># all Vector2s</span>
            <span class="s1">(list</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">Vector2)</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># mix</span>

        <span class="s3"># The point values can be ints or floats.</span>
        <span class="s1">point_values = (</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.1</span><span class="s0">, </span><span class="s5">2.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2.1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># Each sequence of points can be a tuple or a list.</span>
        <span class="s1">seq_types = (tuple</span><span class="s0">, </span><span class="s1">list)</span>

        <span class="s0">for </span><span class="s1">point_type </span><span class="s0">in </span><span class="s1">point_types:</span>
            <span class="s0">for </span><span class="s1">values </span><span class="s0">in </span><span class="s1">point_values:</span>
                <span class="s1">check_pos = values[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">points = [point_type[i](pt) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">enumerate(values)]</span>

                <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">seq_types:</span>
                    <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                    <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = seq_type(points)</span>

                    <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

                    <span class="s1">self.assertEqual(surface.get_at(check_pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
                    <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__invalid_points_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines handles invalid points formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s1">points_fmts = (</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Too few coords.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Too many coords.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">})</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dict(((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))))</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">{(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)}</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">dict(((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Wrong type.</span>

        <span class="s0">for </span><span class="s1">points </span><span class="s0">in </span><span class="s1">points_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = points</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aalines__invalid_points_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines handles invalid points values correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">points </span><span class="s0">in </span><span class="s1">([]</span><span class="s0">, </span><span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)):  </span><span class="s3"># Too few points.</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list):  </span><span class="s3"># Test as tuples and lists.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = seq_type(points)</span>

                <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                    <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aalines__valid_closed_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines accepts different closed values.&quot;&quot;&quot;</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: line_color</span><span class="s0">,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">true_values = (-</span><span class="s5">7</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s5">3.1</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">5</span><span class="s1">]</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">false_values = (</span><span class="s0">None, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">closed </span><span class="s0">in </span><span class="s1">true_values + false_values:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;closed&quot;</span><span class="s1">] = closed</span>
            <span class="s1">expected_color = line_color </span><span class="s0">if </span><span class="s1">closed </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: (pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">greens = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">greens:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;closed&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_aalines(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_aalines__color(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aalines drawn are the correct color. 
 
        Draws aalines around the border of the given surface and checks if all 
        borders of the surface only contain the given color. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">self.COLORS:</span>
                <span class="s1">self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">corners(surface))</span>

                <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                    <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_aalines__gaps(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests if the aalines drawn contain any gaps. 
 
        Draws aalines around the border of the given surface and checks if 
        all borders of the surface contain any gaps. 
 
        See: #512 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">surface </span><span class="s0">in </span><span class="s1">self._create_surfaces():</span>
            <span class="s1">self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, True, </span><span class="s1">corners(surface))</span>

            <span class="s0">for </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">border_pos_and_color(surface):</span>
                <span class="s1">self.assertEqual(color</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_aalines__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines returns the correct bounding rect. 
 
        Tests lines with endpoints on and off the surface and blending 
        enabled and disabled. 
        &quot;&quot;&quot;</span>
        <span class="s1">line_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">width = height = </span><span class="s5">30</span>
        <span class="s3"># Using a rect to help manage where the lines are drawn.</span>
        <span class="s1">pos_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s3"># Testing surfaces of different sizes. One larger than the pos_rect</span>
        <span class="s3"># and one smaller (to test lines that span the surface).</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((width + </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height + </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s5">5</span><span class="s0">, </span><span class="s1">height - </span><span class="s5">5</span><span class="s1">)):</span>
            <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
            <span class="s1">surf_rect = surface.get_rect()</span>

            <span class="s3"># Move pos_rect to different positions to test line endpoints on</span>
            <span class="s3"># and off the surface.</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(surf_rect):</span>
                <span class="s1">pos_rect.center = pos</span>
                <span class="s3"># Shape: Triangle (if closed), ^ caret (if not closed).</span>
                <span class="s1">pts = (pos_rect.midleft</span><span class="s0">, </span><span class="s1">pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.midright)</span>
                <span class="s1">pos = pts[</span><span class="s5">0</span><span class="s1">]  </span><span class="s3"># Rect position if nothing drawn.</span>

                <span class="s0">for </span><span class="s1">closed </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                    <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                    <span class="s1">bounding_rect = self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">line_color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">pts)</span>

                    <span class="s3"># Calculating the expected_rect after the lines are</span>
                    <span class="s3"># drawn (it uses what is actually drawn).</span>
                    <span class="s1">expected_rect = create_bounding_rect(surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">pos)</span>

                    <span class="s1">self.assertEqual(bounding_rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_aalines__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw aalines respects a surface's clip area.&quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">aaline_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">11</span><span class="s0">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">pos_rect = clip_rect.copy()  </span><span class="s3"># Manages the aalines's pos.</span>

        <span class="s3"># Test centering the pos_rect along the clip rect's edge to allow for</span>
        <span class="s3"># drawing the aalines over the clip_rect's bounds.</span>
        <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
            <span class="s1">pos_rect.center = center</span>
            <span class="s1">pts = (pos_rect.midtop</span><span class="s0">, </span><span class="s1">pos_rect.center</span><span class="s0">, </span><span class="s1">pos_rect.midbottom)</span>
            <span class="s0">for </span><span class="s1">closed </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):  </span><span class="s3"># Test closed and not closed.</span>
                <span class="s3"># Get the expected points by drawing the aalines without</span>
                <span class="s3"># the clip area set.</span>
                <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">aaline_color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">pts)</span>

                <span class="s1">expected_pts = get_color_points(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">clip_rect</span><span class="s0">, False</span>
                <span class="s1">)</span>

                <span class="s3"># Clear the surface and set the clip area. Redraw the</span>
                <span class="s3"># aalines and check that only the clip area is modified.</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">surface.set_clip(clip_rect)</span>

                <span class="s1">self.draw_aalines(surface</span><span class="s0">, </span><span class="s1">aaline_color</span><span class="s0">, </span><span class="s1">closed</span><span class="s0">, </span><span class="s1">pts)</span>

                <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                <span class="s3"># Check all the surface points to ensure the expected_pts</span>
                <span class="s3"># are not surface_color.</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                    <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                        <span class="s1">self.assertNotEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">pt)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">pt)</span>

                <span class="s1">surface.unlock()</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever fully supports drawing aalines.</span>
<span class="s3"># class PythonDrawAALinesTest(AALinesMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function aalines.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from AALinesMixin. It is also the</span>
<span class="s3">#    class to add any draw_py.draw_aalines specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">DrawAALinesTest(AALinesMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function aalines. 
 
    This class inherits the general tests from AALinesMixin. It is also the 
    class to add any draw.aalines specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s3">### Polygon Testing ###########################################################</span>

<span class="s1">SQUARE = ([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])</span>
<span class="s1">DIAMOND = [(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">5</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)]</span>
<span class="s1">CROSS = (</span>
    <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">6</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">6</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">class </span><span class="s1">DrawPolygonMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing polygons. 
 
    This class contains all the general polygon drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setUp(self):</span>
        <span class="s1">self.surface = pygame.Surface((</span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_polygon__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_polygon(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__args_without_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon accepts the args without a width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_polygon(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon accepts the correct kwargs 
        with and without a width arg. 
        &quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">points = ((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s1">: points}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_polygon(</span>
            <span class="s1">color=(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">points=((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_polygon(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_polygon()</span>

    <span class="s0">def </span><span class="s1">test_polygon__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;points&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_polygon(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_polygon__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">points = ((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid width.</span>
            <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid points.</span>
            <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">points)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_polygon((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">points)</span>

    <span class="s0">def </span><span class="s1">test_polygon__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">points = ((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">width = </span><span class="s5">1</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,  </span><span class="s3"># Invalid surface.</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,  </span><span class="s3"># Invalid color.</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Invalid points.</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1.2</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]  </span><span class="s3"># Invalid width.</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_polygon__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">points = ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">, </span><span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_polygon__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">points = ((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">width = </span><span class="s5">0</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s1">: points</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: width}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;points&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;points&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__valid_width_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon accepts different width values.&quot;&quot;&quot;</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>
        <span class="s1">pos = kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">100</span><span class="s0">, </span><span class="s1">-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">100</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width</span>
            <span class="s1">expected_color = color </span><span class="s0">if </span><span class="s1">width &gt;= </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__valid_points_format(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon accepts different points formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s3"># The point type can be a tuple/list/Vector2.</span>
        <span class="s1">point_types = (</span>
            <span class="s1">(tuple</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">tuple)</span><span class="s0">,  </span><span class="s3"># all tuples</span>
            <span class="s1">(list</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">list)</span><span class="s0">,  </span><span class="s3"># all lists</span>
            <span class="s1">(Vector2</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">Vector2)</span><span class="s0">,  </span><span class="s3"># all Vector2s</span>
            <span class="s1">(list</span><span class="s0">, </span><span class="s1">Vector2</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">Vector2)</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># mix</span>

        <span class="s3"># The point values can be ints or floats.</span>
        <span class="s1">point_values = (</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.1</span><span class="s0">, </span><span class="s5">2.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2.1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># Each sequence of points can be a tuple or a list.</span>
        <span class="s1">seq_types = (tuple</span><span class="s0">, </span><span class="s1">list)</span>

        <span class="s0">for </span><span class="s1">point_type </span><span class="s0">in </span><span class="s1">point_types:</span>
            <span class="s0">for </span><span class="s1">values </span><span class="s0">in </span><span class="s1">point_values:</span>
                <span class="s1">check_pos = values[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">points = [point_type[i](pt) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">enumerate(values)]</span>

                <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">seq_types:</span>
                    <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                    <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = seq_type(points)</span>

                    <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

                    <span class="s1">self.assertEqual(surface.get_at(check_pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
                    <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__invalid_points_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon handles invalid points formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">points_fmts = (</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Too few coords.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Too many coords.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">))</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">})</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dict(((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))))</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">{(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)}</span><span class="s0">,  </span><span class="s3"># Wrong type.</span>
            <span class="s1">dict(((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Wrong type.</span>

        <span class="s0">for </span><span class="s1">points </span><span class="s0">in </span><span class="s1">points_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = points</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_polygon__invalid_points_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon handles invalid points values correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">points_fmts = (</span>
            <span class="s1">tuple()</span><span class="s0">,  </span><span class="s3"># Too few points.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Too few points.</span>
            <span class="s1">((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># Too few points.</span>

        <span class="s0">for </span><span class="s1">points </span><span class="s0">in </span><span class="s1">points_fmts:</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list):  </span><span class="s3"># Test as tuples and lists.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">] = seq_type(points)</span>

                <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                    <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_polygon__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">pos = kwargs[</span><span class="s2">&quot;points&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">greens = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">greens:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_polygon__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;points&quot;</span><span class="s1">: ((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_polygon(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_draw_square(self):</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">SQUARE</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># note : there is a discussion (#234) if draw.polygon should include or</span>
        <span class="s3"># not the right or lower border; here we stick with current behavior,</span>
        <span class="s3"># eg include those borders ...</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

    <span class="s0">def </span><span class="s1">test_draw_diamond(self):</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">DIAMOND</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># this diamond shape is equivalent to its four corners, plus inner square</span>
        <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">DIAMOND:</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">msg=str((x</span><span class="s0">, </span><span class="s1">y)))</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>

    <span class="s0">def </span><span class="s1">test_1_pixel_high_or_wide_shapes(self):</span>
        <span class="s3"># 1. one-pixel-high, filled</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(x</span><span class="s0">, </span><span class="s5">2</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">_y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">cross_size = </span><span class="s5">6  </span><span class="s3"># the maximum x or y coordinate of the cross</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># 2. one-pixel-high, not filled</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(x</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">_y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span><span class="s0">, </span><span class="s1">RED)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># 3. one-pixel-wide, filled</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">3</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">_x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s5">2</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s5">3</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s5">4</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># 4. one-pixel-wide, not filled</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[(</span><span class="s5">4</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">_x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">CROSS]</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(cross_size + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s5">3</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s5">4</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>
            <span class="s1">self.assertEqual(self.surface.get_at((</span><span class="s5">5</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

    <span class="s0">def </span><span class="s1">test_draw_symetric_cross(self):</span>
        <span class="s4">&quot;&quot;&quot;non-regression on issue #234 : x and y where handled inconsistently. 
 
        Also, the result is/was different whether we fill or not the polygon. 
        &quot;&quot;&quot;</span>
        <span class="s3"># 1. case width = 1 (not filled: `polygon` calls  internally the `lines` function)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">CROSS</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">inside = [(x</span><span class="s0">, </span><span class="s5">3</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)] + [(</span><span class="s5">3</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">in </span><span class="s1">inside:</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>
                <span class="s0">elif </span><span class="s1">(x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">y &lt; </span><span class="s5">7</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">x &lt; </span><span class="s5">7</span><span class="s1">):</span>
                    <span class="s3"># we are on the border of the cross:</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># we are outside</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

        <span class="s3"># 2. case width = 0 (filled; this is the example from #234)</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">CROSS</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">inside = [(x</span><span class="s0">, </span><span class="s5">3</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)] + [(</span><span class="s5">3</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">(x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">y &lt; </span><span class="s5">7</span><span class="s1">) </span><span class="s0">or </span><span class="s1">(y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">) </span><span class="s0">and </span><span class="s1">x &lt; </span><span class="s5">7</span><span class="s1">):</span>
                    <span class="s3"># we are on the border of the cross:</span>
                    <span class="s1">self.assertEqual(</span>
                        <span class="s1">self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">msg=str((x</span><span class="s0">, </span><span class="s1">y))</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># we are outside</span>
                    <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">RED)</span>

    <span class="s0">def </span><span class="s1">test_illumine_shape(self):</span>
        <span class="s4">&quot;&quot;&quot;non-regression on issue #313&quot;&quot;&quot;</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">))</span>
        <span class="s1">path_data = [</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(rect.width - </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># upper border</span>
            <span class="s1">(rect.width - </span><span class="s5">5</span><span class="s0">, </span><span class="s5">5 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">5 </span><span class="s1">- </span><span class="s5">1</span><span class="s0">, </span><span class="s5">5 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># upper inner</span>
            <span class="s1">(</span><span class="s5">5 </span><span class="s1">- </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect.height - </span><span class="s5">5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">rect.height - </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]  </span><span class="s3"># lower diagonal</span>
        <span class="s3"># The shape looks like this (the numbers are the indices of path_data)</span>

        <span class="s3"># 0**********************1              &lt;-- upper border</span>
        <span class="s3"># ***********************</span>
        <span class="s3"># **********************</span>
        <span class="s3"># *********************</span>
        <span class="s3"># ****3**************2                  &lt;-- upper inner border</span>
        <span class="s3"># *****</span>
        <span class="s3"># *****                   (more lines here)</span>
        <span class="s3"># *****</span>
        <span class="s3"># ****4</span>
        <span class="s3"># ****</span>
        <span class="s3"># ***</span>
        <span class="s3"># **</span>
        <span class="s3"># 5</span>
        <span class="s3">#</span>

        <span class="s3"># the current bug is that the &quot;upper inner&quot; line is not drawn, but only</span>
        <span class="s3"># if 4 or some lower corner exists</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># 1. First without the corners 4 &amp; 5</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">path_data[:</span><span class="s5">4</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)  </span><span class="s3"># upper border</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s0">, </span><span class="s1">rect.width - </span><span class="s5">5 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)  </span><span class="s3"># upper inner</span>

        <span class="s3"># 2. with the corners 4 &amp; 5</span>
        <span class="s1">pygame.draw.rect(self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.draw_polygon(self.surface</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">path_data</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s0">, </span><span class="s1">rect.width - </span><span class="s5">5 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">self.assertEqual(self.surface.get_at((x</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">GREEN)  </span><span class="s3"># upper inner</span>

    <span class="s0">def </span><span class="s1">test_invalid_points(self):</span>
        <span class="s1">self.assertRaises(</span>
            <span class="s1">TypeError</span><span class="s0">,</span>
            <span class="s0">lambda</span><span class="s1">: self.draw_polygon(</span>
                <span class="s1">self.surface</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_polygon__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon returns the correct bounding rect. 
 
        Tests polygons on and off the surface and a range of width/thickness 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s1">polygon_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">min_width = min_height = </span><span class="s5">5</span>
        <span class="s1">max_width = max_height = </span><span class="s5">7</span>
        <span class="s1">sizes = ((min_width</span><span class="s0">, </span><span class="s1">min_height)</span><span class="s0">, </span><span class="s1">(max_width</span><span class="s0">, </span><span class="s1">max_height))</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
        <span class="s1">surf_rect = surface.get_rect()</span>
        <span class="s3"># Make a rect that is bigger than the surface to help test drawing</span>
        <span class="s3"># polygons off and partially off the surface.</span>
        <span class="s1">big_rect = surf_rect.inflate(min_width * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s1">min_height * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(</span>
            <span class="s1">surf_rect</span>
        <span class="s1">) + rect_corners_mids_and_center(big_rect):</span>
            <span class="s3"># A rect (pos_rect) is used to help create and position the</span>
            <span class="s3"># polygon. Each of this rect's position attributes will be set to</span>
            <span class="s3"># the pos value.</span>
            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">RECT_POSITION_ATTRIBUTES:</span>
                <span class="s3"># Test using different rect sizes and thickness values.</span>
                <span class="s0">for </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height </span><span class="s0">in </span><span class="s1">sizes:</span>
                    <span class="s1">pos_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>
                    <span class="s1">setattr(pos_rect</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">pos)</span>
                    <span class="s3"># Points form a triangle with no fully</span>
                    <span class="s3"># horizontal/vertical lines.</span>
                    <span class="s1">vertices = (</span>
                        <span class="s1">pos_rect.midleft</span><span class="s0">,</span>
                        <span class="s1">pos_rect.midtop</span><span class="s0">,</span>
                        <span class="s1">pos_rect.bottomright</span><span class="s0">,</span>
                    <span class="s1">)</span>

                    <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">):</span>
                        <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                        <span class="s1">bounding_rect = self.draw_polygon(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">polygon_color</span><span class="s0">, </span><span class="s1">vertices</span><span class="s0">, </span><span class="s1">thickness</span>
                        <span class="s1">)</span>

                        <span class="s3"># Calculating the expected_rect after the polygon</span>
                        <span class="s3"># is drawn (it uses what is actually drawn).</span>
                        <span class="s1">expected_rect = create_bounding_rect(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">vertices[</span><span class="s5">0</span><span class="s1">]</span>
                        <span class="s1">)</span>

                        <span class="s1">self.assertEqual(</span>
                            <span class="s1">bounding_rect</span><span class="s0">,</span>
                            <span class="s1">expected_rect</span><span class="s0">,</span>
                            <span class="s2">f&quot;thickness=</span><span class="s0">{</span><span class="s1">thickness</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
                        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_polygon__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw polygon respects a surface's clip area. 
 
        Tests drawing the polygon filled and unfilled. 
        &quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">polygon_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">8</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">pos_rect = clip_rect.copy()  </span><span class="s3"># Manages the polygon's pos.</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):  </span><span class="s3"># Filled and unfilled.</span>
            <span class="s3"># Test centering the polygon along the clip rect's edge.</span>
            <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
                <span class="s3"># Get the expected points by drawing the polygon without the</span>
                <span class="s3"># clip area set.</span>
                <span class="s1">pos_rect.center = center</span>
                <span class="s1">vertices = (</span>
                    <span class="s1">pos_rect.topleft</span><span class="s0">,</span>
                    <span class="s1">pos_rect.topright</span><span class="s0">,</span>
                    <span class="s1">pos_rect.bottomright</span><span class="s0">,</span>
                    <span class="s1">pos_rect.bottomleft</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">polygon_color</span><span class="s0">, </span><span class="s1">vertices</span><span class="s0">, </span><span class="s1">width)</span>
                <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">polygon_color</span><span class="s0">, </span><span class="s1">clip_rect)</span>

                <span class="s3"># Clear the surface and set the clip area. Redraw the polygon</span>
                <span class="s3"># and check that only the clip area is modified.</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">surface.set_clip(clip_rect)</span>

                <span class="s1">self.draw_polygon(surface</span><span class="s0">, </span><span class="s1">polygon_color</span><span class="s0">, </span><span class="s1">vertices</span><span class="s0">, </span><span class="s1">width)</span>

                <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                <span class="s3"># Check all the surface points to ensure only the expected_pts</span>
                <span class="s3"># are the polygon_color.</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                    <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                        <span class="s1">expected_color = polygon_color</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_color = surface_color</span>

                    <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pt)</span>

                <span class="s1">surface.unlock()</span>


<span class="s0">class </span><span class="s1">DrawPolygonTest(DrawPolygonMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function polygon. 
 
    This class inherits the general tests from DrawPolygonMixin. It is also 
    the class to add any draw.polygon specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever fully supports drawing polygons.</span>
<span class="s3"># @unittest.skip('draw_py.draw_polygon not fully supported yet')</span>
<span class="s3"># class PythonDrawPolygonTest(DrawPolygonMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function draw_polygon.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from DrawPolygonMixin. It is also</span>
<span class="s3">#    the class to add any draw_py.draw_polygon specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s3">### Rect Testing ##############################################################</span>


<span class="s0">class </span><span class="s1">DrawRectMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing rects. 
 
    This class contains all the general rect drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_rect__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_rect(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">20</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">150</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s5">2</span><span class="s0">,</span>
            <span class="s5">1</span><span class="s0">,</span>
            <span class="s5">2</span><span class="s0">,</span>
            <span class="s5">3</span><span class="s0">,</span>
            <span class="s5">4</span><span class="s0">,</span>
            <span class="s5">5</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__args_without_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect accepts the args without a width and borders.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_rect(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect accepts the correct kwargs 
        with and without a width and border_radius arg. 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">100</span><span class="s0">, </span><span class="s5">200</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_rect(</span>
            <span class="s1">color=(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">border_radius=</span><span class="s5">10</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">border_top_left_radius=</span><span class="s5">5</span><span class="s0">,</span>
            <span class="s1">width=-</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">border_top_right_radius=</span><span class="s5">20</span><span class="s0">,</span>
            <span class="s1">border_bottom_right_radius=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">rect=pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">border_bottom_left_radius=</span><span class="s5">15</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_rect(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_rect()</span>

    <span class="s0">def </span><span class="s1">test_rect__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
            <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
            <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
            <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
            <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
            <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;rect&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_rect(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_rect__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid border_bottom_right_radius.</span>
            <span class="s1">bounds_rect = self.draw_rect(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">border_bottom_right_radius=</span><span class="s2">&quot;rad&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid border_bottom_left_radius.</span>
            <span class="s1">bounds_rect = self.draw_rect(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">border_bottom_left_radius=</span><span class="s2">&quot;rad&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid border_top_right_radius.</span>
            <span class="s1">bounds_rect = self.draw_rect(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">border_top_right_radius=</span><span class="s2">&quot;rad&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid border_top_left_radius.</span>
            <span class="s1">bounds_rect = self.draw_rect(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s1">border_top_left_radius=</span><span class="s2">&quot;draw&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid border_radius.</span>
            <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;rad&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid width.</span>
            <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid rect.</span>
            <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_rect(rect</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rect__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,  </span><span class="s3"># Invalid surface.</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,  </span><span class="s3"># Invalid color.</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid rect.</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1.1</span><span class="s0">,  </span><span class="s3"># Invalid width.</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10.5</span><span class="s0">,  </span><span class="s3"># Invalid border_radius.</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5.5</span><span class="s0">,  </span><span class="s3"># Invalid top_left_radius.</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s2">&quot;a&quot;</span><span class="s0">,  </span><span class="s3"># Invalid top_right_radius.</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s2">&quot;c&quot;</span><span class="s0">,  </span><span class="s3"># Invalid bottom_left_radius</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s2">&quot;d&quot;</span><span class="s0">,  </span><span class="s3"># Invalid bottom_right.</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_rect__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;border_radius&quot;</span><span class="s1">: </span><span class="s5">10</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_left_radius&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
                <span class="s2">&quot;border_top_right_radius&quot;</span><span class="s1">: </span><span class="s5">20</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_left_radius&quot;</span><span class="s1">: </span><span class="s5">15</span><span class="s0">,</span>
                <span class="s2">&quot;border_bottom_right_radius&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">, </span><span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_rect__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
        <span class="s1">width = </span><span class="s5">0</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">: width}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;rect&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_rect(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__valid_width_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect accepts different width values.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">1000</span><span class="s0">, </span><span class="s1">-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">1000</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width</span>
            <span class="s1">expected_color = color </span><span class="s0">if </span><span class="s1">width &gt;= </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__valid_rect_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect accepts different rect formats.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s1">: </span><span class="s0">None, </span><span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s1">}</span>
        <span class="s1">rects = (</span>
            <span class="s1">pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(pos[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">[pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2.1</span><span class="s0">, </span><span class="s5">2.2</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">rect </span><span class="s0">in </span><span class="s1">rects:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;rect&quot;</span><span class="s1">] = rect</span>

            <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__invalid_rect_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect handles invalid rect formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">invalid_fmts = (</span>
            <span class="s1">[]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s2">&quot;4&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">rect </span><span class="s0">in </span><span class="s1">invalid_fmts:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;rect&quot;</span><span class="s1">] = rect</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_rect__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">red_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">3</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">reds = ((</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">surface.map_rgb(red_color)</span><span class="s0">, </span><span class="s1">red_color)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">reds:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = red_color</span>

            <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_rect__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_rect(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_rect__fill(self):</span>
        <span class="s1">self.surf_w</span><span class="s0">, </span><span class="s1">self.surf_h = self.surf_size = (</span><span class="s5">320</span><span class="s0">, </span><span class="s5">200</span><span class="s1">)</span>
        <span class="s1">self.surf = pygame.Surface(self.surf_size</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA)</span>
        <span class="s1">self.color = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">13</span><span class="s0">, </span><span class="s5">24</span><span class="s0">, </span><span class="s5">205</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">25</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span>
        <span class="s1">drawn = self.draw_rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">rect)</span>

        <span class="s3"># Should be colored where it's supposed to be</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(rect):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>

            <span class="s1">self.assertEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s3"># And not where it shouldn't</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_outer_bounds(rect):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>

            <span class="s1">self.assertNotEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s3"># Issue #310: Cannot draw rectangles that are 1 pixel high</span>
        <span class="s1">bgcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">self.surf.fill(bgcolor)</span>
        <span class="s1">hrect = pygame.Rect(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">self.surf_w - </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">vrect = pygame.Rect(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">self.surf_h - </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s1">drawn = self.draw_rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">hrect</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">hrect)</span>

        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = hrect.topleft</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = hrect.size</span>

        <span class="s1">self.assertEqual(self.surf.get_at((x - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s1">self.assertEqual(self.surf.get_at((x + w</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(x</span><span class="s0">, </span><span class="s1">x + w):</span>
            <span class="s1">self.assertEqual(self.surf.get_at((i</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s1">drawn = self.draw_rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">vrect</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">vrect)</span>

        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = vrect.topleft</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = vrect.size</span>

        <span class="s1">self.assertEqual(self.surf.get_at((x</span><span class="s0">, </span><span class="s1">y - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s1">self.assertEqual(self.surf.get_at((x</span><span class="s0">, </span><span class="s1">y + h))</span><span class="s0">, </span><span class="s1">bgcolor)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(y</span><span class="s0">, </span><span class="s1">y + h):</span>
            <span class="s1">self.assertEqual(self.surf.get_at((x</span><span class="s0">, </span><span class="s1">i))</span><span class="s0">, </span><span class="s1">self.color)</span>

    <span class="s0">def </span><span class="s1">test_rect__one_pixel_lines(self):</span>
        <span class="s1">self.surf = pygame.Surface((</span><span class="s5">320</span><span class="s0">, </span><span class="s5">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.SRCALPHA)</span>
        <span class="s1">self.color = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">13</span><span class="s0">, </span><span class="s5">24</span><span class="s0">, </span><span class="s5">205</span><span class="s1">)</span>

        <span class="s1">rect = pygame.Rect(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">56</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span>

        <span class="s1">drawn = self.draw_rect(self.surf</span><span class="s0">, </span><span class="s1">self.color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(drawn</span><span class="s0">, </span><span class="s1">rect)</span>

        <span class="s3"># Should be colored where it's supposed to be</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_perimeter_pts(drawn):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>

            <span class="s1">self.assertEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

        <span class="s3"># And not where it shouldn't</span>
        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_outer_bounds(drawn):</span>
            <span class="s1">color_at_pt = self.surf.get_at(pt)</span>

            <span class="s1">self.assertNotEqual(color_at_pt</span><span class="s0">, </span><span class="s1">self.color)</span>

    <span class="s0">def </span><span class="s1">test_rect__draw_line_width(self):</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">100</span><span class="s0">, </span><span class="s5">100</span><span class="s1">))</span>
        <span class="s1">surface.fill(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">color = pygame.Color(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">rect_width = </span><span class="s5">80</span>
        <span class="s1">rect_height = </span><span class="s5">50</span>
        <span class="s1">line_width = </span><span class="s5">10</span>
        <span class="s1">pygame.draw.rect(</span>
            <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">rect_width</span><span class="s0">, </span><span class="s1">rect_height)</span><span class="s0">, </span><span class="s1">line_width</span>
        <span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(line_width):</span>
            <span class="s1">self.assertEqual(surface.get_at((i</span><span class="s0">, </span><span class="s1">i))</span><span class="s0">, </span><span class="s1">color)</span>
            <span class="s1">self.assertEqual(surface.get_at((rect_width - i - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">i))</span><span class="s0">, </span><span class="s1">color)</span>
            <span class="s1">self.assertEqual(surface.get_at((i</span><span class="s0">, </span><span class="s1">rect_height - i - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color)</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">surface.get_at((rect_width - i - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect_height - i - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">color</span>
            <span class="s1">)</span>
        <span class="s1">self.assertEqual(surface.get_at((line_width</span><span class="s0">, </span><span class="s1">line_width))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">surface.get_at((rect_width - line_width - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">line_width))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">surface.get_at((line_width</span><span class="s0">, </span><span class="s1">rect_height - line_width - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">surface.get_at((rect_width - line_width - </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect_height - line_width - </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rect__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect returns the correct bounding rect. 
 
        Tests rects on and off the surface and a range of width/thickness 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s1">rect_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">min_width = min_height = </span><span class="s5">5</span>
        <span class="s1">max_width = max_height = </span><span class="s5">7</span>
        <span class="s1">sizes = ((min_width</span><span class="s0">, </span><span class="s1">min_height)</span><span class="s0">, </span><span class="s1">(max_width</span><span class="s0">, </span><span class="s1">max_height))</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
        <span class="s1">surf_rect = surface.get_rect()</span>
        <span class="s3"># Make a rect that is bigger than the surface to help test drawing</span>
        <span class="s3"># rects off and partially off the surface.</span>
        <span class="s1">big_rect = surf_rect.inflate(min_width * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s1">min_height * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(</span>
            <span class="s1">surf_rect</span>
        <span class="s1">) + rect_corners_mids_and_center(big_rect):</span>
            <span class="s3"># Each of the rect's position attributes will be set to the pos</span>
            <span class="s3"># value.</span>
            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">RECT_POSITION_ATTRIBUTES:</span>
                <span class="s3"># Test using different rect sizes and thickness values.</span>
                <span class="s0">for </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height </span><span class="s0">in </span><span class="s1">sizes:</span>
                    <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>
                    <span class="s1">setattr(rect</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">pos)</span>

                    <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">):</span>
                        <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                        <span class="s1">bounding_rect = self.draw_rect(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">rect_color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">thickness</span>
                        <span class="s1">)</span>

                        <span class="s3"># Calculating the expected_rect after the rect is</span>
                        <span class="s3"># drawn (it uses what is actually drawn).</span>
                        <span class="s1">expected_rect = create_bounding_rect(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">rect.topleft</span>
                        <span class="s1">)</span>

                        <span class="s1">self.assertEqual(</span>
                            <span class="s1">bounding_rect</span><span class="s0">,</span>
                            <span class="s1">expected_rect</span><span class="s0">,</span>
                            <span class="s2">f&quot;thickness=</span><span class="s0">{</span><span class="s1">thickness</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
                        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_rect__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw rect respects a surface's clip area. 
 
        Tests drawing the rect filled and unfilled. 
        &quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">rect_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">8</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">test_rect = clip_rect.copy()  </span><span class="s3"># Manages the rect's pos.</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):  </span><span class="s3"># Filled and unfilled.</span>
            <span class="s3"># Test centering the rect along the clip rect's edge.</span>
            <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
                <span class="s3"># Get the expected points by drawing the rect without the</span>
                <span class="s3"># clip area set.</span>
                <span class="s1">test_rect.center = center</span>
                <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">self.draw_rect(surface</span><span class="s0">, </span><span class="s1">rect_color</span><span class="s0">, </span><span class="s1">test_rect</span><span class="s0">, </span><span class="s1">width)</span>
                <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">rect_color</span><span class="s0">, </span><span class="s1">clip_rect)</span>

                <span class="s3"># Clear the surface and set the clip area. Redraw the rect</span>
                <span class="s3"># and check that only the clip area is modified.</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">surface.set_clip(clip_rect)</span>

                <span class="s1">self.draw_rect(surface</span><span class="s0">, </span><span class="s1">rect_color</span><span class="s0">, </span><span class="s1">test_rect</span><span class="s0">, </span><span class="s1">width)</span>

                <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                <span class="s3"># Check all the surface points to ensure only the expected_pts</span>
                <span class="s3"># are the rect_color.</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                    <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                        <span class="s1">expected_color = rect_color</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_color = surface_color</span>

                    <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pt)</span>

                <span class="s1">surface.unlock()</span>


<span class="s0">class </span><span class="s1">DrawRectTest(DrawRectMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function rect. 
 
    This class inherits the general tests from DrawRectMixin. It is also the 
    class to add any draw.rect specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever properly supports drawing rects.</span>
<span class="s3"># @unittest.skip('draw_py.draw_rect not supported yet')</span>
<span class="s3"># class PythonDrawRectTest(DrawRectMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function draw_rect.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from DrawRectMixin. It is also the</span>
<span class="s3">#    class to add any draw_py.draw_rect specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s3">### Circle Testing ############################################################</span>


<span class="s0">class </span><span class="s1">DrawCircleMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing circles. 
 
    This class contains all the general circle drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_circle__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_circle(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__args_without_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts the args without a width and 
        quadrants.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_circle(pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__args_with_negative_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts the args with negative width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_circle(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>
        <span class="s1">self.assertEqual(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_circle__args_with_width_gt_radius(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts the args with width &gt; radius.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_circle(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>
        <span class="s1">self.assertEqual(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_circle__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts the correct kwargs 
        with and without a width and quadrant arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">False,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_circle(</span>
            <span class="s1">draw_top_right=</span><span class="s0">False,</span>
            <span class="s1">color=(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">draw_bottom_left=</span><span class="s0">False,</span>
            <span class="s1">center=(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">draw_bottom_right=</span><span class="s0">False,</span>
            <span class="s1">radius=</span><span class="s5">2</span><span class="s0">,</span>
            <span class="s1">draw_top_left=</span><span class="s0">True,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_circle(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_circle()</span>

    <span class="s0">def </span><span class="s1">test_circle__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;center&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">False,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;radius&quot;</span><span class="s0">, </span><span class="s2">&quot;center&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_circle(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_circle__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">center = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">1</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid draw_top_right.</span>
            <span class="s1">bounds_rect = self.draw_circle(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid draw_top_left.</span>
            <span class="s1">bounds_rect = self.draw_circle(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid draw_bottom_left.</span>
            <span class="s1">bounds_rect = self.draw_circle(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s5">1</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid draw_bottom_right.</span>
            <span class="s1">bounds_rect = self.draw_circle(</span>
                <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span>
            <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid width.</span>
            <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid radius.</span>
            <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid center.</span>
            <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">radius)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_circle((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius)</span>

    <span class="s0">def </span><span class="s1">test_circle__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">center = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">1</span>
        <span class="s1">width = </span><span class="s5">1</span>
        <span class="s1">quadrant = </span><span class="s5">1</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,  </span><span class="s3"># Invalid surface.</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,  </span><span class="s3"># Invalid color.</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid center.</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: </span><span class="s2">&quot;1&quot;</span><span class="s0">,  </span><span class="s3"># Invalid radius.</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1.2</span><span class="s0">,  </span><span class="s3"># Invalid width.</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s2">&quot;True&quot;</span><span class="s0">,  </span><span class="s3"># Invalid draw_top_right</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s2">&quot;True&quot;</span><span class="s0">,  </span><span class="s3"># Invalid draw_top_left</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s5">3.14</span><span class="s0">,  </span><span class="s3"># Invalid draw_bottom_left</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s2">&quot;quadrant&quot;</span><span class="s0">,  </span><span class="s3"># Invalid draw_bottom_right</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_circle__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">center = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">2</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;quadrant&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
                <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
                <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_circle__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">center = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">2</span>
        <span class="s1">width = </span><span class="s5">0</span>
        <span class="s1">draw_top_right = </span><span class="s0">True</span>
        <span class="s1">draw_top_left = </span><span class="s0">False</span>
        <span class="s1">draw_bottom_left = </span><span class="s0">False</span>
        <span class="s1">draw_bottom_right = </span><span class="s0">True</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s2">&quot;surface&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;center&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;center&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;radius&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;width&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s2">&quot;draw_top_right&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">draw_top_right</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s2">&quot;draw_top_left&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(</span>
                    <span class="s1">surface</span><span class="s0">,</span>
                    <span class="s1">color</span><span class="s0">,</span>
                    <span class="s1">center</span><span class="s0">,</span>
                    <span class="s1">radius</span><span class="s0">,</span>
                    <span class="s1">width</span><span class="s0">,</span>
                    <span class="s1">draw_top_right</span><span class="s0">,</span>
                    <span class="s1">draw_top_left</span><span class="s0">,</span>
                    <span class="s1">**kwargs</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s2">&quot;draw_bottom_left&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_circle(</span>
                    <span class="s1">surface</span><span class="s0">,</span>
                    <span class="s1">color</span><span class="s0">,</span>
                    <span class="s1">center</span><span class="s0">,</span>
                    <span class="s1">radius</span><span class="s0">,</span>
                    <span class="s1">width</span><span class="s0">,</span>
                    <span class="s1">draw_top_right</span><span class="s0">,</span>
                    <span class="s1">draw_top_left</span><span class="s0">,</span>
                    <span class="s1">draw_bottom_left</span><span class="s0">,</span>
                    <span class="s1">**kwargs</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_circle(</span>
                    <span class="s1">surface</span><span class="s0">,</span>
                    <span class="s1">color</span><span class="s0">,</span>
                    <span class="s1">center</span><span class="s0">,</span>
                    <span class="s1">radius</span><span class="s0">,</span>
                    <span class="s1">width</span><span class="s0">,</span>
                    <span class="s1">draw_top_right</span><span class="s0">,</span>
                    <span class="s1">draw_top_left</span><span class="s0">,</span>
                    <span class="s1">draw_bottom_left</span><span class="s0">,</span>
                    <span class="s1">draw_bottom_right</span><span class="s0">,</span>
                    <span class="s1">**kwargs</span><span class="s0">,</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__valid_width_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts different width values.&quot;&quot;&quot;</span>
        <span class="s1">center = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">1</span>
        <span class="s1">pos = (center[</span><span class="s5">0</span><span class="s1">] - radius</span><span class="s0">, </span><span class="s1">center[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">100</span><span class="s0">, </span><span class="s1">-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">100</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width</span>
            <span class="s1">expected_color = color </span><span class="s0">if </span><span class="s1">width &gt;= </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__valid_radius_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts different radius values.&quot;&quot;&quot;</span>
        <span class="s1">pos = center = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s0">, </span><span class="s5">30</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">radius </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;radius&quot;</span><span class="s1">] = radius</span>
            <span class="s1">expected_color = color </span><span class="s0">if </span><span class="s1">radius &gt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__valid_center_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts different center formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;center&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
        <span class="s1">}</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2  </span><span class="s3"># center position</span>

        <span class="s3"># The center values can be ints or floats.</span>
        <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.1</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(x + </span><span class="s5">0.1</span><span class="s0">, </span><span class="s1">y + </span><span class="s5">0.1</span><span class="s1">)):</span>
            <span class="s3"># The center type can be a tuple/list/Vector2.</span>
            <span class="s0">for </span><span class="s1">seq_type </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">Vector2):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;center&quot;</span><span class="s1">] = seq_type(center)</span>

                <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

                <span class="s1">self.assertEqual(surface.get_at((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">, </span><span class="s1">expected_color)</span>
                <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">center = (</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">1</span>
        <span class="s1">pos = (center[</span><span class="s5">0</span><span class="s1">] - radius</span><span class="s0">, </span><span class="s1">center[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;center&quot;</span><span class="s1">: center</span><span class="s0">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s1">: radius</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
        <span class="s1">}</span>
        <span class="s1">greens = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">greens:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_circle__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;center&quot;</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;radius&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s2">&quot;draw_top_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_top_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_left&quot;</span><span class="s1">: </span><span class="s0">True,</span>
            <span class="s2">&quot;draw_bottom_right&quot;</span><span class="s1">: </span><span class="s0">True,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_circle(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_circle__floats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure that floats are accepted.&quot;&quot;&quot;</span>
        <span class="s1">draw.circle(</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">color=(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">127</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">center=(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">radius=</span><span class="s5">1.3</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">draw_top_right=</span><span class="s0">True,</span>
            <span class="s1">draw_top_left=</span><span class="s0">True,</span>
            <span class="s1">draw_bottom_left=</span><span class="s0">True,</span>
            <span class="s1">draw_bottom_right=</span><span class="s0">True,</span>
        <span class="s1">)</span>

        <span class="s1">draw.circle(</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">color=(</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">127</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">center=Vector2(</span><span class="s5">1.5</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">radius=</span><span class="s5">1.3</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">0</span><span class="s0">,</span>
            <span class="s1">draw_top_right=</span><span class="s0">True,</span>
            <span class="s1">draw_top_left=</span><span class="s0">True,</span>
            <span class="s1">draw_bottom_left=</span><span class="s0">True,</span>
            <span class="s1">draw_bottom_right=</span><span class="s0">True,</span>
        <span class="s1">)</span>

        <span class="s1">draw.circle(pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1.3</span><span class="s0">, </span><span class="s5">1.3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1.2</span><span class="s1">)</span>

    <span class="s3"># def test_circle_clip(self):</span>
    <span class="s3">#     &quot;&quot;&quot; maybe useful to help work out circle clip algorithm.&quot;&quot;&quot;</span>
    <span class="s3">#     MAX = max</span>
    <span class="s3">#     MIN = min</span>
    <span class="s3">#     posx=30</span>
    <span class="s3">#     posy=15</span>
    <span class="s3">#     radius=1</span>
    <span class="s3">#     l=29</span>
    <span class="s3">#     t=14</span>
    <span class="s3">#     r=30</span>
    <span class="s3">#     b=16</span>
    <span class="s3">#     clip_rect_x=0</span>
    <span class="s3">#     clip_rect_y=0</span>
    <span class="s3">#     clip_rect_w=30</span>
    <span class="s3">#     clip_rect_h=30</span>

    <span class="s3">#     l = MAX(posx - radius, clip_rect_x)</span>
    <span class="s3">#     t = MAX(posy - radius, clip_rect_y)</span>
    <span class="s3">#     r = MIN(posx + radius, clip_rect_x + clip_rect_w)</span>
    <span class="s3">#     b = MIN(posy + radius, clip_rect_y + clip_rect_h)</span>

    <span class="s3">#     l, t, MAX(r - l, 0), MAX(b - t, 0)</span>

    <span class="s0">def </span><span class="s1">test_circle__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle returns the correct bounding rect. 
 
        Tests circles on and off the surface and a range of width/thickness 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s1">circle_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">max_radius = </span><span class="s5">3</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">30</span><span class="s0">, </span><span class="s5">30</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
        <span class="s1">surf_rect = surface.get_rect()</span>
        <span class="s3"># Make a rect that is bigger than the surface to help test drawing</span>
        <span class="s3"># circles off and partially off the surface. Make this rect such that</span>
        <span class="s3"># when centering the test circle on one of its corners, the circle is</span>
        <span class="s3"># drawn fully off the test surface, but a rect bounding the circle</span>
        <span class="s3"># would still overlap with the test surface.</span>
        <span class="s1">big_rect = surf_rect.inflate(max_radius * </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span><span class="s0">, </span><span class="s1">max_radius * </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(</span>
            <span class="s1">surf_rect</span>
        <span class="s1">) + rect_corners_mids_and_center(big_rect):</span>
            <span class="s3"># Test using different radius and thickness values.</span>
            <span class="s0">for </span><span class="s1">radius </span><span class="s0">in </span><span class="s1">range(max_radius + </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">range(radius + </span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                    <span class="s1">bounding_rect = self.draw_circle(</span>
                        <span class="s1">surface</span><span class="s0">, </span><span class="s1">circle_color</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">thickness</span>
                    <span class="s1">)</span>

                    <span class="s3"># Calculating the expected_rect after the circle is</span>
                    <span class="s3"># drawn (it uses what is actually drawn).</span>
                    <span class="s1">expected_rect = create_bounding_rect(surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">pos)</span>
                    <span class="s3"># print(&quot;pos:%s:, radius:%s:, thickness:%s:&quot; % (pos, radius, thickness))</span>
                    <span class="s1">self.assertEqual(bounding_rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_circle_negative_radius(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures negative radius circles return zero sized bounding rect.&quot;&quot;&quot;</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s5">200</span><span class="s0">, </span><span class="s5">200</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">center = surf.get_height() // </span><span class="s5">2</span><span class="s0">, </span><span class="s1">surf.get_height() // </span><span class="s5">2</span>

        <span class="s1">bounding_rect = self.draw_circle(surf</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius=-</span><span class="s5">1</span><span class="s0">, </span><span class="s1">width=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(bounding_rect.size</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_circle_zero_radius(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures zero radius circles does not draw a center pixel. 
 
        NOTE: This is backwards incompatible behaviour with 1.9.x. 
        &quot;&quot;&quot;</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s5">200</span><span class="s0">, </span><span class="s5">200</span><span class="s1">))</span>
        <span class="s1">circle_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">center = (</span><span class="s5">100</span><span class="s0">, </span><span class="s5">100</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">0</span>
        <span class="s1">width = </span><span class="s5">1</span>

        <span class="s1">bounding_rect = self.draw_circle(surf</span><span class="s0">, </span><span class="s1">circle_color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s1">expected_rect = create_bounding_rect(surf</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">center)</span>
        <span class="s1">self.assertEqual(bounding_rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>
        <span class="s1">self.assertEqual(bounding_rect</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">100</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_circle__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle respects a surface's clip area. 
 
        Tests drawing the circle filled and unfilled. 
        &quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">25</span>
        <span class="s1">circle_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">radius = clip_rect.w // </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">):  </span><span class="s3"># Filled and unfilled.</span>
            <span class="s3"># Test centering the circle along the clip rect's edge.</span>
            <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
                <span class="s3"># Get the expected points by drawing the circle without the</span>
                <span class="s3"># clip area set.</span>
                <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">self.draw_circle(surface</span><span class="s0">, </span><span class="s1">circle_color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">width)</span>
                <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">circle_color</span><span class="s0">, </span><span class="s1">clip_rect)</span>

                <span class="s3"># Clear the surface and set the clip area. Redraw the circle</span>
                <span class="s3"># and check that only the clip area is modified.</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">surface.set_clip(clip_rect)</span>

                <span class="s1">self.draw_circle(surface</span><span class="s0">, </span><span class="s1">circle_color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">width)</span>

                <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                <span class="s3"># Check all the surface points to ensure only the expected_pts</span>
                <span class="s3"># are the circle_color.</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                    <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                        <span class="s1">expected_color = circle_color</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_color = surface_color</span>

                    <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pt)</span>

                <span class="s1">surface.unlock()</span>

    <span class="s0">def </span><span class="s1">test_circle_shape(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures there are no holes in the circle, and no overdrawing. 
 
        Tests drawing a thick circle. 
        Measures the distance of the drawn pixels from the circle center. 
        &quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">100</span>
        <span class="s1">circle_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">(cx</span><span class="s0">, </span><span class="s1">cy) = center = (</span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">radius = </span><span class="s5">45</span>
        <span class="s1">width = </span><span class="s5">25</span>

        <span class="s1">dest_rect = self.draw_circle(surface</span><span class="s0">, </span><span class="s1">circle_color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">width)</span>

        <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">test_utils.rect_area_pts(dest_rect):</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = pt</span>
            <span class="s1">sqr_distance = (x - cx) ** </span><span class="s5">2 </span><span class="s1">+ (y - cy) ** </span><span class="s5">2</span>
            <span class="s0">if </span><span class="s1">(radius - width + </span><span class="s5">1</span><span class="s1">) ** </span><span class="s5">2 </span><span class="s1">&lt; sqr_distance &lt; (radius - </span><span class="s5">1</span><span class="s1">) ** </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">circle_color)</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">sqr_distance &lt; (radius - width - </span><span class="s5">1</span><span class="s1">) ** </span><span class="s5">2</span>
                <span class="s0">or </span><span class="s1">sqr_distance &gt; (radius + </span><span class="s5">1</span><span class="s1">) ** </span><span class="s5">2</span>
            <span class="s1">):</span>
                <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">surface_color)</span>

    <span class="s0">def </span><span class="s1">test_circle__diameter(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw circle is twice size of radius high and wide.&quot;&quot;&quot;</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s5">200</span><span class="s0">, </span><span class="s5">200</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">center = surf.get_height() // </span><span class="s5">2</span><span class="s0">, </span><span class="s1">surf.get_height() // </span><span class="s5">2</span>
        <span class="s1">width = </span><span class="s5">1</span>
        <span class="s1">radius = </span><span class="s5">6</span>
        <span class="s0">for </span><span class="s1">radius </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">65</span><span class="s1">):</span>
            <span class="s1">bounding_rect = self.draw_circle(surf</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">width)</span>
            <span class="s1">self.assertEqual(bounding_rect.width</span><span class="s0">, </span><span class="s1">radius * </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(bounding_rect.height</span><span class="s0">, </span><span class="s1">radius * </span><span class="s5">2</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">DrawCircleTest(DrawCircleMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function circle. 
 
    This class inherits the general tests from DrawCircleMixin. It is also 
    the class to add any draw.circle specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever properly supports drawing circles.</span>
<span class="s3"># @unittest.skip('draw_py.draw_circle not supported yet')</span>
<span class="s3"># class PythonDrawCircleTest(DrawCircleMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function draw_circle.&quot;</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from DrawCircleMixin. It is also</span>
<span class="s3">#    the class to add any draw_py.draw_circle specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s3">### Arc Testing ###############################################################</span>


<span class="s0">class </span><span class="s1">DrawArcMixin:</span>
    <span class="s4">&quot;&quot;&quot;Mixin tests for drawing arcs. 
 
    This class contains all the general arc drawing tests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_arc__args(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts the correct args.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_arc(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__args_without_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts the args without a width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_arc(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">99</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">, </span><span class="s5">1.1</span><span class="s0">, </span><span class="s5">2.1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__args_with_negative_width(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts the args with negative width.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_arc(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>
        <span class="s1">self.assertEqual(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_arc__args_with_width_gt_radius(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts the args with 
        width &gt; rect.w // 2 and width &gt; rect.h // 2. 
        &quot;&quot;&quot;</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">bounds_rect = self.draw_arc(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">45</span><span class="s0">, </span><span class="s1">rect.w // </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

        <span class="s1">bounds_rect = self.draw_arc(</span>
            <span class="s1">pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">50</span><span class="s0">, </span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">45</span><span class="s0">, </span><span class="s1">rect.h // </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts the correct kwargs 
        with and without a width arg. 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s5">0.5</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">3</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">3.1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc's kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">bounds_rect = self.draw_arc(</span>
            <span class="s1">stop_angle=</span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">start_angle=</span><span class="s5">2.2</span><span class="s0">,</span>
            <span class="s1">color=(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface=pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">rect=pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__args_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc detects any missing required args.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0.1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_arc(surface)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">bounds_rect = self.draw_arc()</span>

    <span class="s0">def </span><span class="s1">test_arc__kwargs_missing(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc detects any missing required kwargs.&quot;&quot;&quot;</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s5">0.1</span><span class="s0">,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">2</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;stop_angle&quot;</span><span class="s0">, </span><span class="s2">&quot;start_angle&quot;</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;surface&quot;</span><span class="s1">):</span>
            <span class="s1">invalid_kwargs = dict(kwargs)</span>
            <span class="s1">invalid_kwargs.pop(name)  </span><span class="s3"># Pop from a copy.</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_arc(**invalid_kwargs)</span>

    <span class="s0">def </span><span class="s1">test_arc__arg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc detects invalid arg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid width.</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid stop_angle.</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid start_angle.</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid rect.</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid color.</span>
            <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s3"># Invalid surface.</span>
            <span class="s1">bounds_rect = self.draw_arc(rect</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_arc__kwarg_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">start = </span><span class="s5">3</span>
        <span class="s1">stop = </span><span class="s5">4</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface</span><span class="s0">,  </span><span class="s3"># Invalid surface.</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s5">2.3</span><span class="s0">,  </span><span class="s3"># Invalid color.</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s3"># Invalid rect.</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s2">&quot;1&quot;</span><span class="s0">,  </span><span class="s3"># Invalid start_angle.</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s2">&quot;1&quot;</span><span class="s0">,  </span><span class="s3"># Invalid stop_angle.</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1.1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]  </span><span class="s3"># Invalid width.</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_arc__kwarg_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">color = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">start = </span><span class="s5">0.9</span>
        <span class="s1">stop = </span><span class="s5">2.3</span>
        <span class="s1">kwargs_list = [</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
                <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
                <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
                <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
                <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
                <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
                <span class="s2">&quot;invalid&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">kwargs_list:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_arc__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">color = (</span><span class="s5">255</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">start = </span><span class="s5">0.6</span>
        <span class="s1">stop = </span><span class="s5">2</span>
        <span class="s1">width = </span><span class="s5">1</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: color</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: start</span><span class="s0">,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: stop</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: width</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s2">&quot;rect&quot;</span><span class="s0">, </span><span class="s2">&quot;start_angle&quot;</span><span class="s0">, </span><span class="s2">&quot;stop_angle&quot;</span><span class="s1">):</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s0">if </span><span class="s2">&quot;surface&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;color&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;rect&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;start_angle&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">elif </span><span class="s2">&quot;stop_angle&quot; </span><span class="s1">== name:</span>
                <span class="s1">bounds_rect = self.draw_arc(surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">bounds_rect = self.draw_arc(</span>
                    <span class="s1">surface</span><span class="s0">, </span><span class="s1">color</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__valid_width_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts different width values.&quot;&quot;&quot;</span>
        <span class="s1">arc_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">rect.center = surface.get_rect().center</span>
        <span class="s1">pos = rect.centerx + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect.centery + </span><span class="s5">1</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: arc_color</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">7</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">50</span><span class="s0">, </span><span class="s1">-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">3</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">50</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;width=</span><span class="s0">{</span><span class="s1">width</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width</span>
            <span class="s1">expected_color = arc_color </span><span class="s0">if </span><span class="s1">width &gt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">surface_color</span>

            <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_arc__valid_stop_angle_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts different stop_angle values.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">rect.center = surface.get_rect().center</span>
        <span class="s1">pos = rect.centerx</span><span class="s0">, </span><span class="s1">rect.centery + </span><span class="s5">1</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: -</span><span class="s5">17</span><span class="s0">,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">stop_angle </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">10</span><span class="s0">, </span><span class="s1">-</span><span class="s5">5.5</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">5.5</span><span class="s0">, </span><span class="s5">10</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;stop_angle=</span><span class="s0">{</span><span class="s1">stop_angle</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;stop_angle&quot;</span><span class="s1">] = stop_angle</span>

            <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_arc__valid_start_angle_values(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts different start_angle values.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">rect.center = surface.get_rect().center</span>
        <span class="s1">pos = rect.centerx + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect.centery + </span><span class="s5">1</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">17</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">start_angle </span><span class="s0">in </span><span class="s1">(-</span><span class="s5">10.0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">5.5</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">5.5</span><span class="s0">, </span><span class="s5">10.0</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;start_angle=</span><span class="s0">{</span><span class="s1">start_angle</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;start_angle&quot;</span><span class="s1">] = start_angle</span>

            <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_arc__valid_rect_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts different rect formats.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">rect.center = surface.get_rect().center</span>
        <span class="s1">pos = rect.centerx + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect.centery + </span><span class="s5">1</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">7</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">rects = (rect</span><span class="s0">, </span><span class="s1">(rect.topleft</span><span class="s0">, </span><span class="s1">rect.size)</span><span class="s0">, </span><span class="s1">(rect.x</span><span class="s0">, </span><span class="s1">rect.y</span><span class="s0">, </span><span class="s1">rect.w</span><span class="s0">, </span><span class="s1">rect.h))</span>

        <span class="s0">for </span><span class="s1">rect </span><span class="s0">in </span><span class="s1">rects:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;rect&quot;</span><span class="s1">] = rect</span>

            <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__valid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc accepts different color formats.&quot;&quot;&quot;</span>
        <span class="s1">green_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">6</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">rect.center = surface.get_rect().center</span>
        <span class="s1">pos = rect.centerx + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">rect.centery + </span><span class="s5">1</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: rect</span><span class="s0">,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">7</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">greens = (</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(green_color)</span><span class="s0">,</span>
            <span class="s1">green_color</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">greens:</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s3"># Clear for each test.</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = color</span>

            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">expected_color = surface.unmap_rgb(color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = green_color</span>

            <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

            <span class="s1">self.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertIsInstance(bounds_rect</span><span class="s0">, </span><span class="s1">pygame.Rect)</span>

    <span class="s0">def </span><span class="s1">test_arc__invalid_color_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc handles invalid color formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">pos = (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;color&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;rect&quot;</span><span class="s1">: pygame.Rect(pos</span><span class="s0">, </span><span class="s1">(</span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;start_angle&quot;</span><span class="s1">: </span><span class="s5">5</span><span class="s0">,</span>
            <span class="s2">&quot;stop_angle&quot;</span><span class="s1">: </span><span class="s5">6.1</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">expected_color </span><span class="s0">in </span><span class="s1">(</span><span class="s5">2.3</span><span class="s0">, </span><span class="s1">self):</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = expected_color</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">bounds_rect = self.draw_arc(**kwargs)</span>

    <span class="s0">def </span><span class="s1">todo_test_arc(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure draw arc works correctly.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_arc__bounding_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc returns the correct bounding rect. 
 
        Tests arcs on and off the surface and a range of width/thickness 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s1">arc_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">min_width = min_height = </span><span class="s5">5</span>
        <span class="s1">max_width = max_height = </span><span class="s5">7</span>
        <span class="s1">sizes = ((min_width</span><span class="s0">, </span><span class="s1">min_height)</span><span class="s0">, </span><span class="s1">(max_width</span><span class="s0">, </span><span class="s1">max_height))</span>
        <span class="s1">surface = pygame.Surface((</span><span class="s5">20</span><span class="s0">, </span><span class="s5">20</span><span class="s1">)</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">32</span><span class="s1">)</span>
        <span class="s1">surf_rect = surface.get_rect()</span>
        <span class="s3"># Make a rect that is bigger than the surface to help test drawing</span>
        <span class="s3"># arcs off and partially off the surface.</span>
        <span class="s1">big_rect = surf_rect.inflate(min_width * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s1">min_height * </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s3"># Max angle allows for a full circle to be drawn.</span>
        <span class="s1">start_angle = </span><span class="s5">0</span>
        <span class="s1">stop_angles = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s1">math.ceil(</span><span class="s5">2 </span><span class="s1">* math.pi))</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(</span>
            <span class="s1">surf_rect</span>
        <span class="s1">) + rect_corners_mids_and_center(big_rect):</span>
            <span class="s3"># Each of the arc's rect position attributes will be set to the pos</span>
            <span class="s3"># value.</span>
            <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">RECT_POSITION_ATTRIBUTES:</span>
                <span class="s3"># Test using different rect sizes, thickness values and stop</span>
                <span class="s3"># angles.</span>
                <span class="s0">for </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height </span><span class="s0">in </span><span class="s1">sizes:</span>
                    <span class="s1">arc_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))</span>
                    <span class="s1">setattr(arc_rect</span><span class="s0">, </span><span class="s1">attr</span><span class="s0">, </span><span class="s1">pos)</span>

                    <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s1">min(width</span><span class="s0">, </span><span class="s1">height)):</span>
                        <span class="s0">for </span><span class="s1">stop_angle </span><span class="s0">in </span><span class="s1">stop_angles:</span>
                            <span class="s1">surface.fill(surf_color)  </span><span class="s3"># Clear for each test.</span>

                            <span class="s1">bounding_rect = self.draw_arc(</span>
                                <span class="s1">surface</span><span class="s0">,</span>
                                <span class="s1">arc_color</span><span class="s0">,</span>
                                <span class="s1">arc_rect</span><span class="s0">,</span>
                                <span class="s1">start_angle</span><span class="s0">,</span>
                                <span class="s1">stop_angle</span><span class="s0">,</span>
                                <span class="s1">thickness</span><span class="s0">,</span>
                            <span class="s1">)</span>

                            <span class="s3"># Calculating the expected_rect after the arc</span>
                            <span class="s3"># is drawn (it uses what is actually drawn).</span>
                            <span class="s1">expected_rect = create_bounding_rect(</span>
                                <span class="s1">surface</span><span class="s0">, </span><span class="s1">surf_color</span><span class="s0">, </span><span class="s1">arc_rect.topleft</span>
                            <span class="s1">)</span>

                            <span class="s1">self.assertEqual(</span>
                                <span class="s1">bounding_rect</span><span class="s0">,</span>
                                <span class="s1">expected_rect</span><span class="s0">,</span>
                                <span class="s2">f&quot;thickness=</span><span class="s0">{</span><span class="s1">thickness</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
                            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_arc__surface_clip(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw arc respects a surface's clip area.&quot;&quot;&quot;</span>
        <span class="s1">surfw = surfh = </span><span class="s5">30</span>
        <span class="s1">start = </span><span class="s5">0.1</span>
        <span class="s1">end = </span><span class="s5">0  </span><span class="s3"># end &lt; start so a full circle will be drawn</span>
        <span class="s1">arc_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface((surfw</span><span class="s0">, </span><span class="s1">surfh))</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">clip_rect = pygame.Rect((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">11</span><span class="s0">, </span><span class="s5">11</span><span class="s1">))</span>
        <span class="s1">clip_rect.center = surface.get_rect().center</span>
        <span class="s1">pos_rect = clip_rect.copy()  </span><span class="s3"># Manages the arc's pos.</span>

        <span class="s0">for </span><span class="s1">thickness </span><span class="s0">in </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">):  </span><span class="s3"># Different line widths.</span>
            <span class="s3"># Test centering the arc along the clip rect's edge.</span>
            <span class="s0">for </span><span class="s1">center </span><span class="s0">in </span><span class="s1">rect_corners_mids_and_center(clip_rect):</span>
                <span class="s3"># Get the expected points by drawing the arc without the</span>
                <span class="s3"># clip area set.</span>
                <span class="s1">pos_rect.center = center</span>
                <span class="s1">surface.set_clip(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">self.draw_arc(surface</span><span class="s0">, </span><span class="s1">arc_color</span><span class="s0">, </span><span class="s1">pos_rect</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">thickness)</span>
                <span class="s1">expected_pts = get_color_points(surface</span><span class="s0">, </span><span class="s1">arc_color</span><span class="s0">, </span><span class="s1">clip_rect)</span>

                <span class="s3"># Clear the surface and set the clip area. Redraw the arc</span>
                <span class="s3"># and check that only the clip area is modified.</span>
                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">surface.set_clip(clip_rect)</span>

                <span class="s1">self.draw_arc(surface</span><span class="s0">, </span><span class="s1">arc_color</span><span class="s0">, </span><span class="s1">pos_rect</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">thickness)</span>

                <span class="s1">surface.lock()  </span><span class="s3"># For possible speed up.</span>

                <span class="s3"># Check all the surface points to ensure only the expected_pts</span>
                <span class="s3"># are the arc_color.</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surfw) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surfh)):</span>
                    <span class="s0">if </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">expected_pts:</span>
                        <span class="s1">expected_color = arc_color</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_color = surface_color</span>

                    <span class="s1">self.assertEqual(surface.get_at(pt)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pt)</span>

                <span class="s1">surface.unlock()</span>


<span class="s0">class </span><span class="s1">DrawArcTest(DrawArcMixin</span><span class="s0">, </span><span class="s1">DrawTestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test draw module function arc. 
 
    This class inherits the general tests from DrawArcMixin. It is also the 
    class to add any draw.arc specific tests to. 
    &quot;&quot;&quot;</span>


<span class="s3"># Commented out to avoid cluttering the test output. Add back in if draw_py</span>
<span class="s3"># ever properly supports drawing arcs.</span>
<span class="s3"># @unittest.skip('draw_py.draw_arc not supported yet')</span>
<span class="s3"># class PythonDrawArcTest(DrawArcMixin, PythonDrawTestCase):</span>
<span class="s3">#    &quot;&quot;&quot;Test draw_py module function draw_arc.</span>
<span class="s3">#</span>
<span class="s3">#    This class inherits the general tests from DrawArcMixin. It is also the</span>
<span class="s3">#    class to add any draw_py.draw_arc specific tests to.</span>
<span class="s3">#    &quot;&quot;&quot;</span>


<span class="s3">### Draw Module Testing #######################################################</span>


<span class="s0">class </span><span class="s1">DrawModuleTest(unittest.TestCase):</span>
    <span class="s4">&quot;&quot;&quot;General draw module tests.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_path_data_validation(self):</span>
        <span class="s4">&quot;&quot;&quot;Test validation of multi-point drawing methods. 
 
        See bug #521 
        &quot;&quot;&quot;</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
        <span class="s1">rect = pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">bad_values = (</span>
            <span class="s2">&quot;text&quot;</span><span class="s0">,</span>
            <span class="s6">b&quot;bytes&quot;</span><span class="s0">,</span>
            <span class="s5">1 </span><span class="s1">+ </span><span class="s5">1j</span><span class="s0">,  </span><span class="s3"># string, bytes, complex,</span>
            <span class="s1">object()</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: x)</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s3"># object, function</span>
        <span class="s1">bad_points = list(bad_values) + [(</span><span class="s5">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)]  </span><span class="s3"># wrong tuple length</span>
        <span class="s1">bad_points.extend((</span><span class="s5">1</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">bad_values)  </span><span class="s3"># one wrong value</span>
        <span class="s1">good_path = [(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)]</span>
        <span class="s3"># A) draw.lines</span>
        <span class="s1">check_pts = [(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">)]</span>

        <span class="s0">for </span><span class="s1">method</span><span class="s0">, </span><span class="s1">is_polgon </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s1">(draw.lines</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(draw.aalines</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(draw.polygon</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">bad_values:</span>
                <span class="s3"># 1. at the beginning</span>
                <span class="s1">draw.rect(surf</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                    <span class="s0">if </span><span class="s1">is_polgon:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">[val] + good_path</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, True, </span><span class="s1">[val] + good_path)</span>

                <span class="s3"># make sure, nothing was drawn :</span>
                <span class="s1">self.assertTrue(all(surf.get_at(pt) == RED </span><span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">check_pts))</span>

                <span class="s3"># 2. not at the beginning (was not checked)</span>
                <span class="s1">draw.rect(surf</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s1">rect</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                    <span class="s1">path = good_path[:</span><span class="s5">2</span><span class="s1">] + [val] + good_path[</span><span class="s5">2</span><span class="s1">:]</span>
                    <span class="s0">if </span><span class="s1">is_polgon:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">method(surf</span><span class="s0">, </span><span class="s1">GREEN</span><span class="s0">, True, </span><span class="s1">path)</span>

                <span class="s3"># make sure, nothing was drawn :</span>
                <span class="s1">self.assertTrue(all(surf.get_at(pt) == RED </span><span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">check_pts))</span>

    <span class="s0">def </span><span class="s1">test_color_validation(self):</span>
        <span class="s1">surf = pygame.Surface((</span><span class="s5">10</span><span class="s0">, </span><span class="s5">10</span><span class="s1">))</span>
        <span class="s1">colors = </span><span class="s5">123456</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">RED</span><span class="s0">, </span><span class="s2">&quot;#ab12df&quot;</span><span class="s0">, </span><span class="s2">&quot;red&quot;</span>
        <span class="s1">points = ((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s3"># 1. valid colors</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">colors:</span>
            <span class="s1">draw.line(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">draw.aaline(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">draw.aalines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>
            <span class="s1">draw.lines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>
            <span class="s1">draw.arc(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">15</span><span class="s0">, </span><span class="s5">150</span><span class="s1">)</span>
            <span class="s1">draw.ellipse(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">draw.circle(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">draw.polygon(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># 2. invalid colors</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">(</span><span class="s5">1.256</span><span class="s0">, </span><span class="s1">object()</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.line(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.aaline(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.aalines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.lines(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, True, </span><span class="s1">points)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.arc(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">15</span><span class="s0">, </span><span class="s5">150</span><span class="s1">)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.ellipse(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">pygame.Rect(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">6</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.circle(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">(</span><span class="s5">7</span><span class="s0">, </span><span class="s5">3</span><span class="s1">)</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">draw.polygon(surf</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">###############################################################################</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s2">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">unittest.main()</span>
</pre>
</body>
</html>