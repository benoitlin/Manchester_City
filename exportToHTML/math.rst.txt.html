<html>
<head>
<title>math.rst.txt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
math.rst.txt</font>
</center></td></tr></table>
<pre><span class="s0">.. include:: common.txt</span>

<span class="s0">:mod:`pygame.math`</span>
<span class="s0">==================</span>

<span class="s0">.. module:: pygame.math</span>
   <span class="s0">:synopsis: pygame module for vector classes</span>

<span class="s0">| :sl:`pygame module for vector classes`</span>

<span class="s0">The pygame math module currently provides Vector classes in two and three</span>
<span class="s0">dimensions, ``Vector2`` and ``Vector3`` respectively.</span>

<span class="s0">They support the following numerical operations: ``vec+vec``, ``vec-vec``, </span>
<span class="s0">``vec*number``, ``number*vec``, ``vec/number``, ``vec//number``, ``vec+=vec``, </span>
<span class="s0">``vec-=vec``, ``vec*=number``, ``vec/=number``, ``vec//=number``. </span>

<span class="s0">All these operations will be performed elementwise.</span>
<span class="s0">In addition ``vec*vec`` will perform a scalar-product (a.k.a. dot-product). </span>
<span class="s0">If you want to multiply every element from vector v with every element from </span>
<span class="s0">vector w you can use the elementwise method: ``v.elementwise() * w``</span>

<span class="s0">The coordinates of a vector can be retrieved or set using attributes or</span>
<span class="s0">subscripts</span>

<span class="s0">::</span>

   <span class="s0">v = pygame.Vector3()</span>

   <span class="s0">v.x = 5</span>
   <span class="s0">v[1] = 2 * v.x</span>
   <span class="s0">print(v[1]) # 10</span>

   <span class="s0">v.x == v[0]</span>
   <span class="s0">v.y == v[1]</span>
   <span class="s0">v.z == v[2]</span>

<span class="s0">Multiple coordinates can be set using slices or swizzling</span>

<span class="s0">::</span>

   <span class="s0">v = pygame.Vector2()</span>
   <span class="s0">v.xy = 1, 2</span>
   <span class="s0">v[:] = 1, 2</span>

<span class="s0">.. versionadded:: 1.9.2pre</span>
<span class="s0">.. versionchanged:: 1.9.4 Removed experimental notice.</span>
<span class="s0">.. versionchanged:: 1.9.4 Allow scalar construction like GLSL Vector2(2) == Vector2(2.0, 2.0)</span>
<span class="s0">.. versionchanged:: 1.9.4 :mod:`pygame.math` required import. More convenient ``pygame.Vector2`` and ``pygame.Vector3``.</span>

<span class="s0">.. function:: clamp</span>

   <span class="s0">| :sl:`returns value clamped to min and max.`</span>
   <span class="s0">| :sg:`clamp(value, min, max) -&gt; float`</span>

   <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
   <span class="s0">`Please leave clamp feedback with authors &lt;https://github.com/pygame/pygame/pull/3326&gt;`_</span>

   <span class="s0">Clamps a numeric ``value`` so that it's no lower than ``min``, and no higher</span>
   <span class="s0">than ``max``.</span>

   <span class="s0">.. versionadded:: 2.1.3</span>

   <span class="s0">.. ## math.clamp ##</span>

<span class="s0">.. class:: Vector2</span>

   <span class="s0">| :sl:`a 2-Dimensional Vector`</span>
   <span class="s0">| :sg:`Vector2() -&gt; Vector2`</span>
   <span class="s0">| :sg:`Vector2(int) -&gt; Vector2`</span>
   <span class="s0">| :sg:`Vector2(float) -&gt; Vector2`</span>
   <span class="s0">| :sg:`Vector2(Vector2) -&gt; Vector2`</span>
   <span class="s0">| :sg:`Vector2(x, y) -&gt; Vector2`</span>
   <span class="s0">| :sg:`Vector2((x, y)) -&gt; Vector2`</span>

   <span class="s0">Some general information about the ``Vector2`` class.</span>

   <span class="s0">.. versionchanged:: 2.1.3 </span>
      <span class="s0">Inherited methods of vector subclasses now correctly return an instance of the </span>
      <span class="s0">subclass instead of the superclass</span>

   <span class="s0">.. method:: dot</span>

      <span class="s0">| :sl:`calculates the dot- or scalar-product with the other vector`</span>
      <span class="s0">| :sg:`dot(Vector2) -&gt; float`</span>

      <span class="s0">.. ## Vector2.dot ##</span>

   <span class="s0">.. method:: cross</span>

      <span class="s0">| :sl:`calculates the cross- or vector-product`</span>
      <span class="s0">| :sg:`cross(Vector2) -&gt; float`</span>

      <span class="s0">calculates the third component of the cross-product.</span>

      <span class="s0">.. ## Vector2.cross ##</span>

   <span class="s0">.. method:: magnitude</span>

      <span class="s0">| :sl:`returns the Euclidean magnitude of the vector.`</span>
      <span class="s0">| :sg:`magnitude() -&gt; float`</span>

      <span class="s0">calculates the magnitude of the vector which follows from the</span>
      <span class="s0">theorem: ``vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2)``</span>

      <span class="s0">.. ## Vector2.magnitude ##</span>

   <span class="s0">.. method:: magnitude_squared</span>

      <span class="s0">| :sl:`returns the squared magnitude of the vector.`</span>
      <span class="s0">| :sg:`magnitude_squared() -&gt; float`</span>

      <span class="s0">calculates the magnitude of the vector which follows from the</span>
      <span class="s0">theorem: ``vec.magnitude_squared() == vec.x**2 + vec.y**2``. This</span>
      <span class="s0">is faster than ``vec.magnitude()`` because it avoids the square root.</span>

      <span class="s0">.. ## Vector2.magnitude_squared ##</span>

   <span class="s0">.. method:: length</span>

      <span class="s0">| :sl:`returns the Euclidean length of the vector.`</span>
      <span class="s0">| :sg:`length() -&gt; float`</span>

      <span class="s0">calculates the Euclidean length of the vector which follows from the</span>
      <span class="s0">Pythagorean theorem: ``vec.length() == math.sqrt(vec.x**2 + vec.y**2)``</span>

      <span class="s0">.. ## Vector2.length ##</span>

   <span class="s0">.. method:: length_squared</span>

      <span class="s0">| :sl:`returns the squared Euclidean length of the vector.`</span>
      <span class="s0">| :sg:`length_squared() -&gt; float`</span>

      <span class="s0">calculates the Euclidean length of the vector which follows from the</span>
      <span class="s0">Pythagorean theorem: ``vec.length_squared() == vec.x**2 + vec.y**2``. </span>
      <span class="s0">This is faster than ``vec.length()`` because it avoids the square root.</span>

      <span class="s0">.. ## Vector2.length_squared ##</span>

   <span class="s0">.. method:: normalize</span>

      <span class="s0">| :sl:`returns a vector with the same direction but length 1.`</span>
      <span class="s0">| :sg:`normalize() -&gt; Vector2`</span>

      <span class="s0">Returns a new vector that has ``length`` equal to ``1`` and the same </span>
      <span class="s0">direction as self.</span>

      <span class="s0">.. ## Vector2.normalize ##</span>

   <span class="s0">.. method:: normalize_ip</span>

      <span class="s0">| :sl:`normalizes the vector in place so that its length is 1.`</span>
      <span class="s0">| :sg:`normalize_ip() -&gt; None`</span>

      <span class="s0">Normalizes the vector so that it has ``length`` equal to ``1``. </span>
      <span class="s0">The direction of the vector is not changed.</span>

      <span class="s0">.. ## Vector2.normalize_ip ##</span>

   <span class="s0">.. method:: is_normalized</span>

      <span class="s0">| :sl:`tests if the vector is normalized i.e. has length == 1.`</span>
      <span class="s0">| :sg:`is_normalized() -&gt; Bool`</span>

      <span class="s0">Returns True if the vector has ``length`` equal to ``1``. Otherwise </span>
      <span class="s0">it returns ``False``.</span>

      <span class="s0">.. ## Vector2.is_normalized ##</span>

   <span class="s0">.. method:: scale_to_length</span>

      <span class="s0">| :sl:`scales the vector to a given length.`</span>
      <span class="s0">| :sg:`scale_to_length(float) -&gt; None`</span>

      <span class="s0">Scales the vector so that it has the given length. The direction of the</span>
      <span class="s0">vector is not changed. You can also scale to length ``0``. If the vector </span>
      <span class="s0">is the zero vector (i.e. has length ``0`` thus no direction) a</span>
      <span class="s0">``ValueError`` is raised.</span>

      <span class="s0">.. ## Vector2.scale_to_length ##</span>

   <span class="s0">.. method:: reflect</span>

      <span class="s0">| :sl:`returns a vector reflected of a given normal.`</span>
      <span class="s0">| :sg:`reflect(Vector2) -&gt; Vector2`</span>

      <span class="s0">Returns a new vector that points in the direction as if self would bounce</span>
      <span class="s0">of a surface characterized by the given surface normal. The length of the</span>
      <span class="s0">new vector is the same as self's.</span>

      <span class="s0">.. ## Vector2.reflect ##</span>

   <span class="s0">.. method:: reflect_ip</span>

      <span class="s0">| :sl:`reflect the vector of a given normal in place.`</span>
      <span class="s0">| :sg:`reflect_ip(Vector2) -&gt; None`</span>

      <span class="s0">Changes the direction of self as if it would have been reflected of a</span>
      <span class="s0">surface with the given surface normal.</span>

      <span class="s0">.. ## Vector2.reflect_ip ##</span>

   <span class="s0">.. method:: distance_to</span>

      <span class="s0">| :sl:`calculates the Euclidean distance to a given vector.`</span>
      <span class="s0">| :sg:`distance_to(Vector2) -&gt; float`</span>

      <span class="s0">.. ## Vector2.distance_to ##</span>

   <span class="s0">.. method:: distance_squared_to</span>

      <span class="s0">| :sl:`calculates the squared Euclidean distance to a given vector.`</span>
      <span class="s0">| :sg:`distance_squared_to(Vector2) -&gt; float`</span>

      <span class="s0">.. ## Vector2.distance_squared_to ##</span>

   <span class="s0">.. method:: move_towards</span>

      <span class="s0">| :sl:`returns a vector moved toward the target by a given distance.`</span>
      <span class="s0">| :sg:`move_towards(Vector2, float) -&gt; Vector2`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave move_towards feedback with authors &lt;https://github.com/pygame/pygame/pull/2929&gt;`_</span>

      <span class="s0">Returns a Vector which is moved towards the given Vector by a given</span>
      <span class="s0">distance and does not overshoot past its target Vector.</span>
      <span class="s0">The first parameter determines the target Vector, while the second</span>
      <span class="s0">parameter determines the delta distance. If the distance is in the</span>
      <span class="s0">negatives, then it will move away from the target Vector.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector2.move_towards ##</span>

   <span class="s0">.. method:: move_towards_ip</span>

      <span class="s0">| :sl:`moves the vector toward its target at a given distance.`</span>
      <span class="s0">| :sg:`move_towards_ip(Vector2, float) -&gt; None`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave move_towards_ip feedback with authors &lt;https://github.com/pygame/pygame/pull/2929&gt;`_</span>

      <span class="s0">Moves itself toward the given Vector at a given distance and does not</span>
      <span class="s0">overshoot past its target Vector.</span>
      <span class="s0">The first parameter determines the target Vector, while the second</span>
      <span class="s0">parameter determines the delta distance. If the distance is in the</span>
      <span class="s0">negatives, then it will move away from the target Vector.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector2.move_towards_ip ##</span>

   <span class="s0">.. method:: lerp</span>

      <span class="s0">| :sl:`returns a linear interpolation to the given vector.`</span>
      <span class="s0">| :sg:`lerp(Vector2, float) -&gt; Vector2`</span>

      <span class="s0">Returns a Vector which is a linear interpolation between self and the</span>
      <span class="s0">given Vector. The second parameter determines how far between self and</span>
      <span class="s0">other the result is going to be. It must be a value between ``0`` and ``1`` </span>
      <span class="s0">where ``0`` means self and ``1`` means other will be returned.</span>

      <span class="s0">.. ## Vector2.lerp ##</span>

   <span class="s0">.. method:: slerp</span>

      <span class="s0">| :sl:`returns a spherical interpolation to the given vector.`</span>
      <span class="s0">| :sg:`slerp(Vector2, float) -&gt; Vector2`</span>

      <span class="s0">Calculates the spherical interpolation from self to the given Vector. The</span>
      <span class="s0">second argument - often called t - must be in the range ``[-1, 1]``. It</span>
      <span class="s0">parametrizes where - in between the two vectors - the result should be.</span>
      <span class="s0">If a negative value is given the interpolation will not take the</span>
      <span class="s0">complement of the shortest path.</span>

      <span class="s0">.. ## Vector2.slerp ##</span>

   <span class="s0">.. method:: elementwise</span>

      <span class="s0">| :sl:`The next operation will be performed elementwise.`</span>
      <span class="s0">| :sg:`elementwise() -&gt; VectorElementwiseProxy`</span>

      <span class="s0">Applies the following operation to each element of the vector.</span>

      <span class="s0">.. ## Vector2.elementwise ##</span>

   <span class="s0">.. method:: rotate</span>

      <span class="s0">| :sl:`rotates a vector by a given angle in degrees.`</span>
      <span class="s0">| :sg:`rotate(angle) -&gt; Vector2`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise by the given angle in degrees.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector2.rotate ##</span>

   <span class="s0">.. method:: rotate_rad</span>

      <span class="s0">| :sl:`rotates a vector by a given angle in radians.`</span>
      <span class="s0">| :sg:`rotate_rad(angle) -&gt; Vector2`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise by the given angle in radians.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.0.0</span>

      <span class="s0">.. ## Vector2.rotate_rad ##</span>

   <span class="s0">.. method:: rotate_ip</span>

      <span class="s0">| :sl:`rotates the vector by a given angle in degrees in place.`</span>
      <span class="s0">| :sg:`rotate_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise by the given angle in degrees. The</span>
      <span class="s0">length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector2.rotate_ip ##</span>

   <span class="s0">.. method:: rotate_ip_rad</span>

      <span class="s0">| :sl:`rotates the vector by a given angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_ip_rad(angle) -&gt; None`</span>

      <span class="s0">DEPRECATED: Use rotate_rad_ip() instead.</span>

      <span class="s0">.. versionadded:: 2.0.0</span>
      <span class="s0">.. deprecated:: 2.1.1</span>

      <span class="s0">.. ## Vector2.rotate_rad_ip ##</span>

   <span class="s0">.. method:: rotate_rad_ip</span>

      <span class="s0">| :sl:`rotates the vector by a given angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_rad_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise by the given angle in radians. The</span>
      <span class="s0">length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.1.1</span>

      <span class="s0">.. ## Vector2.rotate_rad_ip ##</span>

   <span class="s0">.. method:: angle_to</span>

      <span class="s0">| :sl:`calculates the angle to a given vector in degrees.`</span>
      <span class="s0">| :sg:`angle_to(Vector2) -&gt; float`</span>

      <span class="s0">Returns the angle from self to the passed ``Vector2`` that would rotate self</span>
      <span class="s0">to be aligned with the passed ``Vector2`` without crossing over the negative </span>
      <span class="s0">x-axis.</span>

      <span class="s0">.. figure:: code_examples/angle_to.png</span>
         <span class="s0">:alt: angle_to image</span>

         <span class="s0">Example demonstrating the angle returned</span>

      <span class="s0">.. ## Vector2.angle_to ##</span>

   <span class="s0">.. method:: as_polar</span>

      <span class="s0">| :sl:`returns a tuple with radial distance and azimuthal angle.`</span>
      <span class="s0">| :sg:`as_polar() -&gt; (r, phi)`</span>

      <span class="s0">Returns a tuple ``(r, phi)`` where r is the radial distance, and phi </span>
      <span class="s0">is the azimuthal angle.</span>

      <span class="s0">.. ## Vector2.as_polar ##</span>

   <span class="s0">.. method:: from_polar</span>

      <span class="s0">| :sl:`Sets x and y from a polar coordinates tuple.`</span>
      <span class="s0">| :sg:`from_polar((r, phi)) -&gt; None`</span>

      <span class="s0">Sets x and y from a tuple (r, phi) where r is the radial distance, and</span>
      <span class="s0">phi is the azimuthal angle.</span>

      <span class="s0">.. ## Vector2.from_polar ##</span>

   <span class="s0">.. method:: project</span>

      <span class="s0">| :sl:`projects a vector onto another.`</span>
      <span class="s0">| :sg:`project(Vector2) -&gt; Vector2`</span>

      <span class="s0">Returns the projected vector. This is useful for collision detection in finding the components in a certain direction (e.g. in direction of the wall). </span>
      <span class="s0">For a more detailed explanation see `Wikipedia &lt;https://en.wikipedia.org/wiki/Vector_projection&gt;`_.</span>

      <span class="s0">.. versionadded:: 2.0.2</span>

      <span class="s0">.. ## Vector2.project ##</span>

   
   <span class="s0">.. method:: copy</span>

      <span class="s0">| :sl:`Returns a copy of itself.`</span>
      <span class="s0">| :sg:`copy() -&gt; Vector2`</span>

      <span class="s0">Returns a new Vector2 having the same dimensions.</span>

      <span class="s0">.. versionadded:: 2.1.1</span>

      <span class="s0">.. ## Vector2.copy ##</span>
   

   <span class="s0">.. method:: clamp_magnitude</span>

      <span class="s0">| :sl:`Returns a copy of a vector with the magnitude clamped between max_length and min_length.`</span>
      <span class="s0">| :sg:`clamp_magnitude(max_length) -&gt; Vector2`</span>
      <span class="s0">| :sg:`clamp_magnitude(min_length, max_length) -&gt; Vector2`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave clamp_magnitude feedback with authors &lt;https://github.com/pygame/pygame/pull/2990&gt;`_</span>

      <span class="s0">Returns a new copy of a vector with the magnitude clamped between </span>
      <span class="s0">``max_length`` and ``min_length``. If only one argument is passed, it is </span>
      <span class="s0">taken to be the ``max_length``</span>

      <span class="s0">This function raises ``ValueError`` if ``min_length`` is greater than</span>
      <span class="s0">``max_length``, or if either of these values are negative.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector2.clamp_magnitude ##</span>
   

   <span class="s0">.. method:: clamp_magnitude_ip</span>

      <span class="s0">| :sl:`Clamps the vector's magnitude between max_length and min_length`</span>
      <span class="s0">| :sg:`clamp_magnitude_ip(max_length) -&gt; None`</span>
      <span class="s0">| :sg:`clamp_magnitude_ip(min_length, max_length) -&gt; None`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave clamp_magnitude_ip feedback with authors &lt;https://github.com/pygame/pygame/pull/2990&gt;`_</span>

      <span class="s0">Clamps the vector's magnitude between ``max_length`` and ``min_length``.</span>
      <span class="s0">If only one argument is passed, it is taken to be the ``max_length``</span>

      <span class="s0">This function raises ``ValueError`` if ``min_length`` is greater than</span>
      <span class="s0">``max_length``, or if either of these values are negative.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector2.clamp_magnitude_ip ##</span>


   <span class="s0">.. method:: update</span>

      <span class="s0">| :sl:`Sets the coordinates of the vector.`</span>
      <span class="s0">| :sg:`update() -&gt; None`</span>
      <span class="s0">| :sg:`update(int) -&gt; None`</span>
      <span class="s0">| :sg:`update(float) -&gt; None`</span>
      <span class="s0">| :sg:`update(Vector2) -&gt; None`</span>
      <span class="s0">| :sg:`update(x, y) -&gt; None`</span>
      <span class="s0">| :sg:`update((x, y)) -&gt; None`</span>

      <span class="s0">Sets coordinates x and y in place.</span>

      <span class="s0">.. versionadded:: 1.9.5</span>

      <span class="s0">.. ## Vector2.update ##</span>

   
   <span class="s0">.. attribute:: epsilon</span>
      
      <span class="s0">| :sl:`Determines the tolerance of vector calculations.`</span>
      
      <span class="s0">Both Vector classes have a value named ``epsilon`` that defaults to ``1e-6``.</span>
      <span class="s0">This value acts as a numerical margin in various methods to account for floating point</span>
      <span class="s0">arithmetic errors. Specifically, ``epsilon`` is used in the following places:</span>

         <span class="s0">* comparing Vectors (``==`` and ``!=``)</span>
         <span class="s0">* the ``is_normalized`` method (if the square of the length is within ``epsilon`` of 1, it's normalized)</span>
         <span class="s0">* slerping (a Vector with a length of ``&lt;epsilon`` is considered a zero vector, and can't slerp with that)</span>
         <span class="s0">* reflection (can't reflect over the zero vector)</span>
         <span class="s0">* projection (can't project onto the zero vector)</span>
         <span class="s0">* rotation (only used when rotating by a multiple of 90 degrees)</span>

      <span class="s0">While it's possible to change ``epsilon`` for a specific instance of a Vector, all the other Vectors</span>
      <span class="s0">will retain the default value. Changing ``epsilon`` on a specific instance however could lead to some</span>
      <span class="s0">asymmetric behavior where symmetry would be expected, such as</span>

      <span class="s0">::</span>

         <span class="s0">u = pygame.Vector2(0, 1)</span>
         <span class="s0">v = pygame.Vector2(0, 1.2)</span>
         <span class="s0">u.epsilon = 0.5 # don't set it nearly this large</span>

         <span class="s0">print(u == v) # &gt;&gt; True</span>
         <span class="s0">print(v == u) # &gt;&gt; False</span>

      <span class="s0">You'll probably never have to change ``epsilon`` from the default value, but in rare situations you might</span>
      <span class="s0">find that either the margin is too large or too small, in which case changing ``epsilon`` slightly </span>
      <span class="s0">might help you out.</span>


   <span class="s0">.. ## pygame.math.Vector2 ##</span>

<span class="s0">.. class:: Vector3</span>

   <span class="s0">| :sl:`a 3-Dimensional Vector`</span>
   <span class="s0">| :sg:`Vector3() -&gt; Vector3`</span>
   <span class="s0">| :sg:`Vector3(int) -&gt; Vector3`</span>
   <span class="s0">| :sg:`Vector3(float) -&gt; Vector3`</span>
   <span class="s0">| :sg:`Vector3(Vector3) -&gt; Vector3`</span>
   <span class="s0">| :sg:`Vector3(x, y, z) -&gt; Vector3`</span>
   <span class="s0">| :sg:`Vector3((x, y, z)) -&gt; Vector3`</span>

   <span class="s0">Some general information about the Vector3 class.</span>

   <span class="s0">.. versionchanged:: 2.1.3 </span>
      <span class="s0">Inherited methods of vector subclasses now correctly return an instance of the </span>
      <span class="s0">subclass instead of the superclass</span>

   <span class="s0">.. method:: dot</span>

      <span class="s0">| :sl:`calculates the dot- or scalar-product with the other vector`</span>
      <span class="s0">| :sg:`dot(Vector3) -&gt; float`</span>

      <span class="s0">.. ## Vector3.dot ##</span>

   <span class="s0">.. method:: cross</span>

      <span class="s0">| :sl:`calculates the cross- or vector-product`</span>
      <span class="s0">| :sg:`cross(Vector3) -&gt; Vector3`</span>

      <span class="s0">calculates the cross-product.</span>

      <span class="s0">.. ## Vector3.cross ##</span>

   <span class="s0">.. method:: magnitude</span>

      <span class="s0">| :sl:`returns the Euclidean magnitude of the vector.`</span>
      <span class="s0">| :sg:`magnitude() -&gt; float`</span>

      <span class="s0">calculates the magnitude of the vector which follows from the</span>
      <span class="s0">theorem: ``vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)``</span>

      <span class="s0">.. ## Vector3.magnitude ##</span>

   <span class="s0">.. method:: magnitude_squared</span>

      <span class="s0">| :sl:`returns the squared Euclidean magnitude of the vector.`</span>
      <span class="s0">| :sg:`magnitude_squared() -&gt; float`</span>

      <span class="s0">calculates the magnitude of the vector which follows from the</span>
      <span class="s0">theorem: </span>
      <span class="s0">``vec.magnitude_squared() == vec.x**2 + vec.y**2 + vec.z**2``.</span>
      <span class="s0">This is faster than ``vec.magnitude()`` because it avoids the</span>
      <span class="s0">square root.</span>

      <span class="s0">.. ## Vector3.magnitude_squared ##</span>

   <span class="s0">.. method:: length</span>

      <span class="s0">| :sl:`returns the Euclidean length of the vector.`</span>
      <span class="s0">| :sg:`length() -&gt; float`</span>

      <span class="s0">calculates the Euclidean length of the vector which follows from the</span>
      <span class="s0">Pythagorean theorem: </span>
      <span class="s0">``vec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)``</span>

      <span class="s0">.. ## Vector3.length ##</span>

   <span class="s0">.. method:: length_squared</span>

      <span class="s0">| :sl:`returns the squared Euclidean length of the vector.`</span>
      <span class="s0">| :sg:`length_squared() -&gt; float`</span>

      <span class="s0">calculates the Euclidean length of the vector which follows from the</span>
      <span class="s0">Pythagorean theorem: </span>
      <span class="s0">``vec.length_squared() == vec.x**2 + vec.y**2 + vec.z**2``. </span>
      <span class="s0">This is faster than ``vec.length()`` because it avoids the square root.</span>

      <span class="s0">.. ## Vector3.length_squared ##</span>

   <span class="s0">.. method:: normalize</span>

      <span class="s0">| :sl:`returns a vector with the same direction but length 1.`</span>
      <span class="s0">| :sg:`normalize() -&gt; Vector3`</span>

      <span class="s0">Returns a new vector that has ``length`` equal to ``1`` and the same </span>
      <span class="s0">direction as self.</span>

      <span class="s0">.. ## Vector3.normalize ##</span>

   <span class="s0">.. method:: normalize_ip</span>

      <span class="s0">| :sl:`normalizes the vector in place so that its length is 1.`</span>
      <span class="s0">| :sg:`normalize_ip() -&gt; None`</span>

      <span class="s0">Normalizes the vector so that it has ``length`` equal to ``1``. The </span>
      <span class="s0">direction of the vector is not changed.</span>

      <span class="s0">.. ## Vector3.normalize_ip ##</span>

   <span class="s0">.. method:: is_normalized</span>

      <span class="s0">| :sl:`tests if the vector is normalized i.e. has length == 1.`</span>
      <span class="s0">| :sg:`is_normalized() -&gt; Bool`</span>

      <span class="s0">Returns True if the vector has ``length`` equal to ``1``. Otherwise it </span>
      <span class="s0">returns ``False``.</span>

      <span class="s0">.. ## Vector3.is_normalized ##</span>

   <span class="s0">.. method:: scale_to_length</span>

      <span class="s0">| :sl:`scales the vector to a given length.`</span>
      <span class="s0">| :sg:`scale_to_length(float) -&gt; None`</span>

      <span class="s0">Scales the vector so that it has the given length. The direction of the</span>
      <span class="s0">vector is not changed. You can also scale to length ``0``. If the vector </span>
      <span class="s0">is the zero vector (i.e. has length ``0`` thus no direction) a</span>
      <span class="s0">``ValueError`` is raised.</span>

      <span class="s0">.. ## Vector3.scale_to_length ##</span>

   <span class="s0">.. method:: reflect</span>

      <span class="s0">| :sl:`returns a vector reflected of a given normal.`</span>
      <span class="s0">| :sg:`reflect(Vector3) -&gt; Vector3`</span>

      <span class="s0">Returns a new vector that points in the direction as if self would bounce</span>
      <span class="s0">of a surface characterized by the given surface normal. The length of the</span>
      <span class="s0">new vector is the same as self's.</span>

      <span class="s0">.. ## Vector3.reflect ##</span>

   <span class="s0">.. method:: reflect_ip</span>

      <span class="s0">| :sl:`reflect the vector of a given normal in place.`</span>
      <span class="s0">| :sg:`reflect_ip(Vector3) -&gt; None`</span>

      <span class="s0">Changes the direction of self as if it would have been reflected of a</span>
      <span class="s0">surface with the given surface normal.</span>

      <span class="s0">.. ## Vector3.reflect_ip ##</span>

   <span class="s0">.. method:: distance_to</span>

      <span class="s0">| :sl:`calculates the Euclidean distance to a given vector.`</span>
      <span class="s0">| :sg:`distance_to(Vector3) -&gt; float`</span>

      <span class="s0">.. ## Vector3.distance_to ##</span>

   <span class="s0">.. method:: distance_squared_to</span>

      <span class="s0">| :sl:`calculates the squared Euclidean distance to a given vector.`</span>
      <span class="s0">| :sg:`distance_squared_to(Vector3) -&gt; float`</span>

      <span class="s0">.. ## Vector3.distance_squared_to ##</span>

   <span class="s0">.. method:: move_towards</span>

      <span class="s0">| :sl:`returns a vector moved toward the target by a given distance.`</span>
      <span class="s0">| :sg:`move_towards(Vector3, float) -&gt; Vector3`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave move_towards feedback with authors &lt;https://github.com/pygame/pygame/pull/2929&gt;`_</span>

      <span class="s0">Returns a Vector which is moved towards the given Vector by a given</span>
      <span class="s0">distance and does not overshoot past its target Vector.</span>
      <span class="s0">The first parameter determines the target Vector, while the second</span>
      <span class="s0">parameter determines the delta distance. If the distance is in the</span>
      <span class="s0">negatives, then it will move away from the target Vector.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector3.move_towards ##</span>

   <span class="s0">.. method:: move_towards_ip</span>

      <span class="s0">| :sl:`moves the vector toward its target at a given distance.`</span>
      <span class="s0">| :sg:`move_towards_ip(Vector3, float) -&gt; None`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave move_towards_ip feedback with authors &lt;https://github.com/pygame/pygame/pull/2929&gt;`_</span>

      <span class="s0">Moves itself toward the given Vector at a given distance and does not</span>
      <span class="s0">overshoot past its target Vector.</span>
      <span class="s0">The first parameter determines the target Vector, while the second</span>
      <span class="s0">parameter determines the delta distance. If the distance is in the</span>
      <span class="s0">negatives, then it will move away from the target Vector.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector3.move_towards_ip ##</span>

   <span class="s0">.. method:: lerp</span>

      <span class="s0">| :sl:`returns a linear interpolation to the given vector.`</span>
      <span class="s0">| :sg:`lerp(Vector3, float) -&gt; Vector3`</span>

      <span class="s0">Returns a Vector which is a linear interpolation between self and the</span>
      <span class="s0">given Vector. The second parameter determines how far between self an</span>
      <span class="s0">other the result is going to be. It must be a value between ``0`` and </span>
      <span class="s0">``1``, where ``0`` means self and ``1`` means other will be returned.</span>

      <span class="s0">.. ## Vector3.lerp ##</span>

   <span class="s0">.. method:: slerp</span>

      <span class="s0">| :sl:`returns a spherical interpolation to the given vector.`</span>
      <span class="s0">| :sg:`slerp(Vector3, float) -&gt; Vector3`</span>

      <span class="s0">Calculates the spherical interpolation from self to the given Vector. The</span>
      <span class="s0">second argument - often called t - must be in the range ``[-1, 1]``. It</span>
      <span class="s0">parametrizes where - in between the two vectors - the result should be.</span>
      <span class="s0">If a negative value is given the interpolation will not take the</span>
      <span class="s0">complement of the shortest path.</span>

      <span class="s0">.. ## Vector3.slerp ##</span>

   <span class="s0">.. method:: elementwise</span>

      <span class="s0">| :sl:`The next operation will be performed elementwise.`</span>
      <span class="s0">| :sg:`elementwise() -&gt; VectorElementwiseProxy`</span>

      <span class="s0">Applies the following operation to each element of the vector.</span>

      <span class="s0">.. ## Vector3.elementwise ##</span>

   <span class="s0">.. method:: rotate</span>

      <span class="s0">| :sl:`rotates a vector by a given angle in degrees.`</span>
      <span class="s0">| :sg:`rotate(angle, Vector3) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise by the given angle in degrees around the given axis.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate ##</span>

   <span class="s0">.. method:: rotate_rad</span>

      <span class="s0">| :sl:`rotates a vector by a given angle in radians.`</span>
      <span class="s0">| :sg:`rotate_rad(angle, Vector3) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise by the given angle in radians around the given axis.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.0.0</span>

      <span class="s0">.. ## Vector3.rotate_rad ##</span>

   <span class="s0">.. method:: rotate_ip</span>

      <span class="s0">| :sl:`rotates the vector by a given angle in degrees in place.`</span>
      <span class="s0">| :sg:`rotate_ip(angle, Vector3) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the given axis by the given</span>
      <span class="s0">angle in degrees. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate_ip ##</span>

   <span class="s0">.. method:: rotate_ip_rad</span>

      <span class="s0">| :sl:`rotates the vector by a given angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_ip_rad(angle, Vector3) -&gt; None`</span>

      <span class="s0">DEPRECATED: Use rotate_rad_ip() instead.</span>

      <span class="s0">.. versionadded:: 2.0.0</span>
      <span class="s0">.. deprecated:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_ip_rad ##</span>

   <span class="s0">.. method:: rotate_rad_ip</span>

      <span class="s0">| :sl:`rotates the vector by a given angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_rad_ip(angle, Vector3) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the given axis by the given</span>
      <span class="s0">angle in radians. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_rad_ip ##</span>

   <span class="s0">.. method:: rotate_x</span>

      <span class="s0">| :sl:`rotates a vector around the x-axis by the angle in degrees.`</span>
      <span class="s0">| :sg:`rotate_x(angle) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise around the x-axis by the given angle in degrees.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate_x ##</span>

   <span class="s0">.. method:: rotate_x_rad</span>

      <span class="s0">| :sl:`rotates a vector around the x-axis by the angle in radians.`</span>
      <span class="s0">| :sg:`rotate_x_rad(angle) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise around the x-axis by the given angle in radians.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.0.0</span>

      <span class="s0">.. ## Vector3.rotate_x_rad ##</span>

   <span class="s0">.. method:: rotate_x_ip</span>

      <span class="s0">| :sl:`rotates the vector around the x-axis by the angle in degrees in place.`</span>
      <span class="s0">| :sg:`rotate_x_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the x-axis by the given angle</span>
      <span class="s0">in degrees. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate_x_ip ##</span>

   <span class="s0">.. method:: rotate_x_ip_rad</span>

      <span class="s0">| :sl:`rotates the vector around the x-axis by the angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_x_ip_rad(angle) -&gt; None`</span>

      <span class="s0">DEPRECATED: Use rotate_x_rad_ip() instead.</span>

      <span class="s0">.. versionadded:: 2.0.0</span>
      <span class="s0">.. deprecated:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_x_ip_rad ##</span>

   <span class="s0">.. method:: rotate_x_rad_ip</span>

      <span class="s0">| :sl:`rotates the vector around the x-axis by the angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_x_rad_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the x-axis by the given angle</span>
      <span class="s0">in radians. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_x_rad_ip ##</span>

   <span class="s0">.. method:: rotate_y</span>

      <span class="s0">| :sl:`rotates a vector around the y-axis by the angle in degrees.`</span>
      <span class="s0">| :sg:`rotate_y(angle) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise around the y-axis by the given angle in degrees.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate_y ##</span>

   <span class="s0">.. method:: rotate_y_rad</span>

      <span class="s0">| :sl:`rotates a vector around the y-axis by the angle in radians.`</span>
      <span class="s0">| :sg:`rotate_y_rad(angle) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise around the y-axis by the given angle in radians.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.0.0</span>

      <span class="s0">.. ## Vector3.rotate_y_rad ##</span>

   <span class="s0">.. method:: rotate_y_ip</span>

      <span class="s0">| :sl:`rotates the vector around the y-axis by the angle in degrees in place.`</span>
      <span class="s0">| :sg:`rotate_y_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the y-axis by the given angle</span>
      <span class="s0">in degrees. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate_y_ip ##</span>

   <span class="s0">.. method:: rotate_y_ip_rad</span>

      <span class="s0">| :sl:`rotates the vector around the y-axis by the angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_y_ip_rad(angle) -&gt; None`</span>

      <span class="s0">DEPRECATED: Use rotate_y_rad_ip() instead.</span>

      <span class="s0">.. versionadded:: 2.0.0</span>
      <span class="s0">.. deprecated:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_y_ip_rad ##</span>

   <span class="s0">.. method:: rotate_y_rad_ip</span>

      <span class="s0">| :sl:`rotates the vector around the y-axis by the angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_y_rad_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the y-axis by the given angle</span>
      <span class="s0">in radians. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_y_rad_ip ##</span>

   <span class="s0">.. method:: rotate_z</span>

      <span class="s0">| :sl:`rotates a vector around the z-axis by the angle in degrees.`</span>
      <span class="s0">| :sg:`rotate_z(angle) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise around the z-axis by the given angle in degrees.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate_z ##</span>

   <span class="s0">.. method:: rotate_z_rad</span>

      <span class="s0">| :sl:`rotates a vector around the z-axis by the angle in radians.`</span>
      <span class="s0">| :sg:`rotate_z_rad(angle) -&gt; Vector3`</span>

      <span class="s0">Returns a vector which has the same length as self but is rotated</span>
      <span class="s0">counterclockwise around the z-axis by the given angle in radians.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.0.0</span>

      <span class="s0">.. ## Vector3.rotate_z_rad ##</span>

   <span class="s0">.. method:: rotate_z_ip</span>

      <span class="s0">| :sl:`rotates the vector around the z-axis by the angle in degrees in place.`</span>
      <span class="s0">| :sg:`rotate_z_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the z-axis by the given angle</span>
      <span class="s0">in degrees. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. ## Vector3.rotate_z_ip ##</span>

   <span class="s0">.. method:: rotate_z_ip_rad</span>

      <span class="s0">| :sl:`rotates the vector around the z-axis by the angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_z_ip_rad(angle) -&gt; None`</span>

      <span class="s0">DEPRECATED: Use rotate_z_rad_ip() instead.</span>
      
      <span class="s0">.. deprecated:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_z_ip_rad ##</span>

   <span class="s0">.. method:: rotate_z_rad_ip</span>

      <span class="s0">| :sl:`rotates the vector around the z-axis by the angle in radians in place.`</span>
      <span class="s0">| :sg:`rotate_z_rad_ip(angle) -&gt; None`</span>

      <span class="s0">Rotates the vector counterclockwise around the z-axis by the given angle</span>
      <span class="s0">in radians. The length of the vector is not changed.</span>
      <span class="s0">(Note that due to pygame's inverted y coordinate system, the rotation</span>
      <span class="s0">will look clockwise if displayed).</span>

      <span class="s0">.. versionadded:: 2.1.1</span>

      <span class="s0">.. ## Vector3.rotate_z_rad_ip ##</span>

   <span class="s0">.. method:: angle_to</span>

      <span class="s0">| :sl:`calculates the angle to a given vector in degrees.`</span>
      <span class="s0">| :sg:`angle_to(Vector3) -&gt; float`</span>

      <span class="s0">Returns the angle between self and the given vector.</span>

      <span class="s0">.. ## Vector3.angle_to ##</span>

   <span class="s0">.. method:: as_spherical</span>

      <span class="s0">| :sl:`returns a tuple with radial distance, inclination and azimuthal angle.`</span>
      <span class="s0">| :sg:`as_spherical() -&gt; (r, theta, phi)`</span>

      <span class="s0">Returns a tuple ``(r, theta, phi)`` where r is the radial distance, theta is</span>
      <span class="s0">the inclination angle and phi is the azimuthal angle.</span>

      <span class="s0">.. ## Vector3.as_spherical ##</span>

   <span class="s0">.. method:: from_spherical</span>

      <span class="s0">| :sl:`Sets x, y and z from a spherical coordinates 3-tuple.`</span>
      <span class="s0">| :sg:`from_spherical((r, theta, phi)) -&gt; None`</span>

      <span class="s0">Sets x, y and z from a tuple ``(r, theta, phi)`` where r is the radial</span>
      <span class="s0">distance, theta is the inclination angle and phi is the azimuthal angle.</span>

      <span class="s0">.. ## Vector3.from_spherical ##</span>

   <span class="s0">.. method:: project</span>

      <span class="s0">| :sl:`projects a vector onto another.`</span>
      <span class="s0">| :sg:`project(Vector3) -&gt; Vector3`</span>

      <span class="s0">Returns the projected vector. This is useful for collision detection in finding the components in a certain direction (e.g. in direction of the wall). </span>
      <span class="s0">For a more detailed explanation see `Wikipedia &lt;https://en.wikipedia.org/wiki/Vector_projection&gt;`_.</span>

      <span class="s0">.. versionadded:: 2.0.2</span>

      <span class="s0">.. ## Vector3.project ##</span>
   
   <span class="s0">.. method:: copy</span>

      <span class="s0">| :sl:`Returns a copy of itself.`</span>
      <span class="s0">| :sg:`copy() -&gt; Vector3`</span>

      <span class="s0">Returns a new Vector3 having the same dimensions.</span>

      <span class="s0">.. versionadded:: 2.1.1</span>

      <span class="s0">.. ## Vector3.copy ##</span>


   <span class="s0">.. method:: clamp_magnitude</span>

      <span class="s0">| :sl:`Returns a copy of a vector with the magnitude clamped between max_length and min_length.`</span>
      <span class="s0">| :sg:`clamp_magnitude(max_length) -&gt; Vector3`</span>
      <span class="s0">| :sg:`clamp_magnitude(min_length, max_length) -&gt; Vector3`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave clamp_magnitude feedback with authors &lt;https://github.com/pygame/pygame/pull/2990&gt;`_</span>

      <span class="s0">Returns a new copy of a vector with the magnitude clamped between </span>
      <span class="s0">``max_length`` and ``min_length``. If only one argument is passed, it is </span>
      <span class="s0">taken to be the ``max_length``</span>

      <span class="s0">This function raises ``ValueError`` if ``min_length`` is greater than</span>
      <span class="s0">``max_length``, or if either of these values are negative.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector3.clamp_magnitude ##</span>
   

   <span class="s0">.. method:: clamp_magnitude_ip</span>

      <span class="s0">| :sl:`Clamps the vector's magnitude between max_length and min_length`</span>
      <span class="s0">| :sg:`clamp_magnitude_ip(max_length) -&gt; None`</span>
      <span class="s0">| :sg:`clamp_magnitude_ip(min_length, max_length) -&gt; None`</span>

      <span class="s0">**Experimental:** feature still in development available for testing and feedback. It may change.</span>
      <span class="s0">`Please leave clamp_magnitude_ip feedback with authors &lt;https://github.com/pygame/pygame/pull/2990&gt;`_</span>

      <span class="s0">Clamps the vector's magnitude between ``max_length`` and ``min_length``.</span>
      <span class="s0">If only one argument is passed, it is taken to be the ``max_length``</span>

      <span class="s0">This function raises ``ValueError`` if ``min_length`` is greater than</span>
      <span class="s0">``max_length``, or if either of these values are negative.</span>

      <span class="s0">.. versionadded:: 2.1.3</span>

      <span class="s0">.. ## Vector3.clamp_magnitude_ip ##</span>

   <span class="s0">.. method:: update</span>

      <span class="s0">| :sl:`Sets the coordinates of the vector.`</span>
      <span class="s0">| :sg:`update() -&gt; None`</span>
      <span class="s0">| :sg:`update(int) -&gt; None`</span>
      <span class="s0">| :sg:`update(float) -&gt; None`</span>
      <span class="s0">| :sg:`update(Vector3) -&gt; None`</span>
      <span class="s0">| :sg:`update(x, y, z) -&gt; None`</span>
      <span class="s0">| :sg:`update((x, y, z)) -&gt; None`</span>

      <span class="s0">Sets coordinates x, y, and z in place.</span>

      <span class="s0">.. versionadded:: 1.9.5</span>

      <span class="s0">.. ## Vector3.update ##</span>

   <span class="s0">.. attribute:: epsilon</span>

      <span class="s0">| :sl:`Determines the tolerance of vector calculations.`</span>
      
      <span class="s0">With lengths within this number, vectors are considered equal. For more information see :attr:`pygame.math.Vector2.epsilon`</span>
            
   <span class="s0">.. ##  ##</span>

   <span class="s0">.. ## pygame.math.Vector3 ##</span>

<span class="s0">.. ## pygame.math ##</span>
</pre>
</body>
</html>