<html>
<head>
<title>draw_py.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
draw_py.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Pygame Drawing algorithms written in Python. (Work in Progress) 
 
Implement Pygame's Drawing Algorithms in a Python version for testing 
and debugging. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">math </span><span class="s2">import </span><span class="s1">floor</span><span class="s2">, </span><span class="s1">ceil</span>


<span class="s3">#   H E L P E R   F U N C T I O N S    #</span>

<span class="s3"># fractional part of x</span>


<span class="s2">def </span><span class="s1">frac(value):</span>
    <span class="s0">&quot;&quot;&quot;return fractional part of x&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">value - floor(value)</span>


<span class="s2">def </span><span class="s1">inv_frac(value):</span>
    <span class="s0">&quot;&quot;&quot;return inverse fractional part of x&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s4">1 </span><span class="s1">- (value - floor(value))  </span><span class="s3"># eg, 1 - frac(x)</span>


<span class="s1">BoundingBox = namedtuple(</span><span class="s5">&quot;BoundingBox&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;top&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;bottom&quot;</span><span class="s1">])</span>
<span class="s1">Point = namedtuple(</span><span class="s5">&quot;Point&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;x&quot;</span><span class="s2">, </span><span class="s5">&quot;y&quot;</span><span class="s1">])</span>


<span class="s3">#   L O W   L E V E L   D R A W   F U N C T I O N S   #</span>
<span class="s3"># (They are too low-level to be translated into python, right?)</span>


<span class="s2">def </span><span class="s1">set_at(surf</span><span class="s2">, </span><span class="s1">in_x</span><span class="s2">, </span><span class="s1">in_y</span><span class="s2">, </span><span class="s1">color):</span>
    <span class="s0">&quot;&quot;&quot;Set the color of a pixel in a surface&quot;&quot;&quot;</span>
    <span class="s1">surf.set_at((in_x</span><span class="s2">, </span><span class="s1">in_y)</span><span class="s2">, </span><span class="s1">color)</span>


<span class="s2">def </span><span class="s1">draw_pixel(surf</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">bright</span><span class="s2">, </span><span class="s1">blend=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;draw one blended pixel with given brightness.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">other_col = surf.get_at(pos) </span><span class="s2">if </span><span class="s1">blend </span><span class="s2">else </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">IndexError:  </span><span class="s3"># pixel outside the surface</span>
        <span class="s2">return</span>
    <span class="s1">new_color = tuple(</span>
        <span class="s1">(bright * col + (</span><span class="s4">1 </span><span class="s1">- bright) * pix) </span><span class="s2">for </span><span class="s1">col</span><span class="s2">, </span><span class="s1">pix </span><span class="s2">in </span><span class="s1">zip(color</span><span class="s2">, </span><span class="s1">other_col)</span>
    <span class="s1">)</span>
    <span class="s3"># FIXME what should happen if only one, color or surf_col, has alpha?</span>
    <span class="s1">surf.set_at(pos</span><span class="s2">, </span><span class="s1">new_color)</span>


<span class="s2">def </span><span class="s1">_drawhorzline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">x_from</span><span class="s2">, </span><span class="s1">in_y</span><span class="s2">, </span><span class="s1">x_to):</span>
    <span class="s2">if </span><span class="s1">x_from == x_to:</span>
        <span class="s1">surf.set_at((x_from</span><span class="s2">, </span><span class="s1">in_y)</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s2">return</span>

    <span class="s1">start</span><span class="s2">, </span><span class="s1">end = (x_from</span><span class="s2">, </span><span class="s1">x_to) </span><span class="s2">if </span><span class="s1">x_from &lt;= x_to </span><span class="s2">else </span><span class="s1">(x_to</span><span class="s2">, </span><span class="s1">x_from)</span>
    <span class="s2">for </span><span class="s1">line_x </span><span class="s2">in </span><span class="s1">range(start</span><span class="s2">, </span><span class="s1">end + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">surf.set_at((line_x</span><span class="s2">, </span><span class="s1">in_y)</span><span class="s2">, </span><span class="s1">color)</span>


<span class="s2">def </span><span class="s1">_drawvertline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">in_x</span><span class="s2">, </span><span class="s1">y_from</span><span class="s2">, </span><span class="s1">y_to):</span>
    <span class="s2">if </span><span class="s1">y_from == y_to:</span>
        <span class="s1">surf.set_at((in_x</span><span class="s2">, </span><span class="s1">y_from)</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s2">return</span>

    <span class="s1">start</span><span class="s2">, </span><span class="s1">end = (y_from</span><span class="s2">, </span><span class="s1">y_to) </span><span class="s2">if </span><span class="s1">y_from &lt;= y_to </span><span class="s2">else </span><span class="s1">(y_to</span><span class="s2">, </span><span class="s1">y_from)</span>
    <span class="s2">for </span><span class="s1">line_y </span><span class="s2">in </span><span class="s1">range(start</span><span class="s2">, </span><span class="s1">end + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">surf.set_at((in_x</span><span class="s2">, </span><span class="s1">line_y)</span><span class="s2">, </span><span class="s1">color)</span>


<span class="s3">#    I N T E R N A L   D R A W   L I N E   F U N C T I O N S    #</span>


<span class="s2">def </span><span class="s1">_clip_and_draw_horizline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">x_from</span><span class="s2">, </span><span class="s1">in_y</span><span class="s2">, </span><span class="s1">x_to):</span>
    <span class="s0">&quot;&quot;&quot;draw clipped horizontal line.&quot;&quot;&quot;</span>
    <span class="s3"># check Y inside surf</span>
    <span class="s1">clip = surf.get_clip()</span>
    <span class="s2">if </span><span class="s1">in_y &lt; clip.y </span><span class="s2">or </span><span class="s1">in_y &gt;= clip.y + clip.h:</span>
        <span class="s2">return</span>

    <span class="s1">x_from = max(x_from</span><span class="s2">, </span><span class="s1">clip.x)</span>
    <span class="s1">x_to = min(x_to</span><span class="s2">, </span><span class="s1">clip.x + clip.w - </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3"># check any x inside surf</span>
    <span class="s2">if </span><span class="s1">x_to &lt; clip.x </span><span class="s2">or </span><span class="s1">x_from &gt;= clip.x + clip.w:</span>
        <span class="s2">return</span>

    <span class="s1">_drawhorzline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">x_from</span><span class="s2">, </span><span class="s1">in_y</span><span class="s2">, </span><span class="s1">x_to)</span>


<span class="s2">def </span><span class="s1">_clip_and_draw_vertline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">in_x</span><span class="s2">, </span><span class="s1">y_from</span><span class="s2">, </span><span class="s1">y_to):</span>
    <span class="s0">&quot;&quot;&quot;draw clipped vertical line.&quot;&quot;&quot;</span>
    <span class="s3"># check X inside surf</span>
    <span class="s1">clip = surf.get_clip()</span>

    <span class="s2">if </span><span class="s1">in_x &lt; clip.x </span><span class="s2">or </span><span class="s1">in_x &gt;= clip.x + clip.w:</span>
        <span class="s2">return</span>

    <span class="s1">y_from = max(y_from</span><span class="s2">, </span><span class="s1">clip.y)</span>
    <span class="s1">y_to = min(y_to</span><span class="s2">, </span><span class="s1">clip.y + clip.h - </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3"># check any y inside surf</span>
    <span class="s2">if </span><span class="s1">y_to &lt; clip.y </span><span class="s2">or </span><span class="s1">y_from &gt;= clip.y + clip.h:</span>
        <span class="s2">return</span>

    <span class="s1">_drawvertline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">in_x</span><span class="s2">, </span><span class="s1">y_from</span><span class="s2">, </span><span class="s1">y_to)</span>


<span class="s3"># These constants xxx_EDGE are &quot;outside-the-bounding-box&quot;-flags</span>
<span class="s1">LEFT_EDGE = </span><span class="s4">0x1</span>
<span class="s1">RIGHT_EDGE = </span><span class="s4">0x2</span>
<span class="s1">BOTTOM_EDGE = </span><span class="s4">0x4</span>
<span class="s1">TOP_EDGE = </span><span class="s4">0x8</span>


<span class="s2">def </span><span class="s1">encode(pos</span><span class="s2">, </span><span class="s1">b_box):</span>
    <span class="s0">&quot;&quot;&quot;returns a code that defines position with respect to a bounding box&quot;&quot;&quot;</span>
    <span class="s3"># we use the fact that python interprets booleans (the inequalities)</span>
    <span class="s3"># as 0/1, and then multiply them with the xxx_EDGE flags</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">(pos[</span><span class="s4">0</span><span class="s1">] &lt; b_box.left) * LEFT_EDGE</span>
        <span class="s1">+ (pos[</span><span class="s4">0</span><span class="s1">] &gt; b_box.right) * RIGHT_EDGE</span>
        <span class="s1">+ (pos[</span><span class="s4">1</span><span class="s1">] &lt; b_box.top) * TOP_EDGE</span>
        <span class="s1">+ (pos[</span><span class="s4">1</span><span class="s1">] &gt; b_box.bottom) * BOTTOM_EDGE</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">clip_line(line</span><span class="s2">, </span><span class="s1">b_box</span><span class="s2">, </span><span class="s1">use_float=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Algorithm to calculate the clipped line. 
 
    We calculate the coordinates of the part of the line segment within the 
    bounding box (defined by left, top, right, bottom). The we write 
    the coordinates of the line segment into &quot;line&quot;, much like the C-algorithm. 
    With `use_float` True, clip_line is usable for float-clipping. 
 
    Returns: true if the line segment cuts the bounding box (false otherwise) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">inside(code):</span>
        <span class="s2">return not </span><span class="s1">code</span>

    <span class="s2">def </span><span class="s1">accept(code_a</span><span class="s2">, </span><span class="s1">code_b):</span>
        <span class="s2">return not </span><span class="s1">(code_a </span><span class="s2">or </span><span class="s1">code_b)</span>

    <span class="s2">def </span><span class="s1">reject(code_a</span><span class="s2">, </span><span class="s1">code_b):</span>
        <span class="s2">return </span><span class="s1">code_a </span><span class="s2">and </span><span class="s1">code_b</span>

    <span class="s2">assert </span><span class="s1">isinstance(line</span><span class="s2">, </span><span class="s1">list)</span>
    <span class="s1">x_1</span><span class="s2">, </span><span class="s1">y_1</span><span class="s2">, </span><span class="s1">x_2</span><span class="s2">, </span><span class="s1">y_2 = line</span>
    <span class="s1">dtype = float </span><span class="s2">if </span><span class="s1">use_float </span><span class="s2">else </span><span class="s1">int</span>

    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s3"># the coordinates are progressively modified with the codes,</span>
        <span class="s3"># until they are either rejected or correspond to the final result.</span>
        <span class="s1">code1 = encode((x_1</span><span class="s2">, </span><span class="s1">y_1)</span><span class="s2">, </span><span class="s1">b_box)</span>
        <span class="s1">code2 = encode((x_2</span><span class="s2">, </span><span class="s1">y_2)</span><span class="s2">, </span><span class="s1">b_box)</span>

        <span class="s2">if </span><span class="s1">accept(code1</span><span class="s2">, </span><span class="s1">code2):</span>
            <span class="s3"># write coordinates into &quot;line&quot; !</span>
            <span class="s1">line[:] = x_1</span><span class="s2">, </span><span class="s1">y_1</span><span class="s2">, </span><span class="s1">x_2</span><span class="s2">, </span><span class="s1">y_2</span>
            <span class="s2">return True</span>
        <span class="s2">if </span><span class="s1">reject(code1</span><span class="s2">, </span><span class="s1">code2):</span>
            <span class="s2">return False</span>

        <span class="s3"># We operate on the (x_1, y_1) point,</span>
        <span class="s3"># and swap if it is inside the bbox:</span>
        <span class="s2">if </span><span class="s1">inside(code1):</span>
            <span class="s1">x_1</span><span class="s2">, </span><span class="s1">x_2 = x_2</span><span class="s2">, </span><span class="s1">x_1</span>
            <span class="s1">y_1</span><span class="s2">, </span><span class="s1">y_2 = y_2</span><span class="s2">, </span><span class="s1">y_1</span>
            <span class="s1">code1</span><span class="s2">, </span><span class="s1">code2 = code2</span><span class="s2">, </span><span class="s1">code1</span>
        <span class="s1">slope = (y_2 - y_1) / float(x_2 - x_1) </span><span class="s2">if </span><span class="s1">(x_2 != x_1) </span><span class="s2">else </span><span class="s4">1.0</span>
        <span class="s3"># Each case, if true, means that we are outside the border:</span>
        <span class="s3"># calculate x_1 and y_1 to be the &quot;first point&quot; inside the bbox...</span>
        <span class="s2">if </span><span class="s1">code1 &amp; LEFT_EDGE:</span>
            <span class="s1">y_1 += dtype((b_box.left - x_1) * slope)</span>
            <span class="s1">x_1 = b_box.left</span>
        <span class="s2">elif </span><span class="s1">code1 &amp; RIGHT_EDGE:</span>
            <span class="s1">y_1 += dtype((b_box.right - x_1) * slope)</span>
            <span class="s1">x_1 = b_box.right</span>
        <span class="s2">elif </span><span class="s1">code1 &amp; BOTTOM_EDGE:</span>
            <span class="s2">if </span><span class="s1">x_2 != x_1:</span>
                <span class="s1">x_1 += dtype((b_box.bottom - y_1) / slope)</span>
            <span class="s1">y_1 = b_box.bottom</span>
        <span class="s2">elif </span><span class="s1">code1 &amp; TOP_EDGE:</span>
            <span class="s2">if </span><span class="s1">x_2 != x_1:</span>
                <span class="s1">x_1 += dtype((b_box.top - y_1) / slope)</span>
            <span class="s1">y_1 = b_box.top</span>


<span class="s2">def </span><span class="s1">_draw_line(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end):</span>
    <span class="s0">&quot;&quot;&quot;draw a non-horizontal line (without anti-aliasing).&quot;&quot;&quot;</span>
    <span class="s3"># Variant of https://en.wikipedia.org/wiki/Bresenham's_line_algorithm</span>
    <span class="s3">#</span>
    <span class="s3"># This strongly differs from craw.c implementation, because we use a</span>
    <span class="s3"># &quot;slope&quot; variable (instead of delta_x and delta_y) and a &quot;error&quot; variable.</span>
    <span class="s3"># And we can not do pointer-arithmetic with &quot;BytesPerPixel&quot;, like in</span>
    <span class="s3"># the C-algorithm.</span>
    <span class="s2">if </span><span class="s1">start.x == end.x:</span>
        <span class="s3"># This case should not happen...</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s1">slope = abs((end.y - start.y) / (end.x - start.x))</span>
    <span class="s1">error = </span><span class="s4">0.0</span>

    <span class="s2">if </span><span class="s1">slope &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3"># Here, it's a rather horizontal line</span>

        <span class="s3"># 1. check in which octants we are &amp; set init values</span>
        <span class="s2">if </span><span class="s1">end.x &lt; start.x:</span>
            <span class="s1">start.x</span><span class="s2">, </span><span class="s1">end.x = end.x</span><span class="s2">, </span><span class="s1">start.x</span>
            <span class="s1">start.y</span><span class="s2">, </span><span class="s1">end.y = end.y</span><span class="s2">, </span><span class="s1">start.y</span>
        <span class="s1">line_y = start.y</span>
        <span class="s1">dy_sign = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">(start.y &lt; end.y) </span><span class="s2">else </span><span class="s1">-</span><span class="s4">1</span>

        <span class="s3"># 2. step along x coordinate</span>
        <span class="s2">for </span><span class="s1">line_x </span><span class="s2">in </span><span class="s1">range(start.x</span><span class="s2">, </span><span class="s1">end.x + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">set_at(surf</span><span class="s2">, </span><span class="s1">line_x</span><span class="s2">, </span><span class="s1">line_y</span><span class="s2">, </span><span class="s1">color)</span>
            <span class="s1">error += slope</span>
            <span class="s2">if </span><span class="s1">error &gt;= </span><span class="s4">0.5</span><span class="s1">:</span>
                <span class="s1">line_y += dy_sign</span>
                <span class="s1">error -= </span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Case of a rather vertical line</span>

        <span class="s3"># 1. check in which octants we are &amp; set init values</span>
        <span class="s2">if </span><span class="s1">start.y &gt; end.y:</span>
            <span class="s1">start.x</span><span class="s2">, </span><span class="s1">end.x = end.x</span><span class="s2">, </span><span class="s1">start.x</span>
            <span class="s1">start.y</span><span class="s2">, </span><span class="s1">end.y = end.y</span><span class="s2">, </span><span class="s1">start.y</span>
        <span class="s1">line_x = start.x</span>
        <span class="s1">slope = </span><span class="s4">1 </span><span class="s1">/ slope</span>
        <span class="s1">dx_sign = </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">(start.x &lt; end.x) </span><span class="s2">else </span><span class="s1">-</span><span class="s4">1</span>

        <span class="s3"># 2. step along y coordinate</span>
        <span class="s2">for </span><span class="s1">line_y </span><span class="s2">in </span><span class="s1">range(start.y</span><span class="s2">, </span><span class="s1">end.y + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">set_at(surf</span><span class="s2">, </span><span class="s1">line_x</span><span class="s2">, </span><span class="s1">line_y</span><span class="s2">, </span><span class="s1">color)</span>
            <span class="s1">error += slope</span>
            <span class="s2">if </span><span class="s1">error &gt;= </span><span class="s4">0.5</span><span class="s1">:</span>
                <span class="s1">line_x += dx_sign</span>
                <span class="s1">error -= </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">_draw_aaline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">blend):</span>
    <span class="s0">&quot;&quot;&quot;draw an anti-aliased line. 
 
    The algorithm yields identical results with _draw_line for horizontal, 
    vertical or diagonal lines, and results changes smoothly when changing 
    any of the endpoint coordinates. 
 
    Note that this yields strange results for very short lines, eg 
    a line from (0, 0) to (0, 1) will draw 2 pixels, and a line from 
    (0, 0) to (0, 1.1) will blend 10 % on the pixel (0, 2). 
    &quot;&quot;&quot;</span>
    <span class="s3"># The different requirements that we have on an antialiasing algorithm</span>
    <span class="s3"># implies to make some compromises:</span>
    <span class="s3"># 1. We want smooth evolution wrt to the 4 endpoint coordinates</span>
    <span class="s3">#    (this means also that we want a smooth evolution when the angle</span>
    <span class="s3">#     passes +/- 45Â°</span>
    <span class="s3"># 2. We want the same behavior when swapping the endpoints</span>
    <span class="s3"># 3. We want understandable results for the endpoint values</span>
    <span class="s3">#    (eg we want to avoid half-integer values to draw a simple plain</span>
    <span class="s3">#     horizontal or vertical line between two integer l endpoints)</span>
    <span class="s3">#</span>
    <span class="s3"># This implies to somehow make the line artificially 1 pixel longer</span>
    <span class="s3"># and to draw a full pixel when we have the  endpoints are identical.</span>
    <span class="s1">d_x = end.x - start.x</span>
    <span class="s1">d_y = end.y - start.y</span>

    <span class="s2">if </span><span class="s1">d_x == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">d_y == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3"># For smoothness reasons, we could also do some blending here,</span>
        <span class="s3"># but it seems overshoot...</span>
        <span class="s1">set_at(surf</span><span class="s2">, </span><span class="s1">int(start.x)</span><span class="s2">, </span><span class="s1">int(start.y)</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">start.x &gt; end.x </span><span class="s2">or </span><span class="s1">start.y &gt; end.y:</span>
        <span class="s1">start.x</span><span class="s2">, </span><span class="s1">end.x = end.x</span><span class="s2">, </span><span class="s1">start.x</span>
        <span class="s1">start.y</span><span class="s2">, </span><span class="s1">end.y = end.y</span><span class="s2">, </span><span class="s1">start.y</span>
        <span class="s1">d_x = -d_x</span>
        <span class="s1">d_y = -d_y</span>

    <span class="s2">if </span><span class="s1">abs(d_x) &gt;= abs(d_y):</span>
        <span class="s1">slope = d_y / d_x</span>

        <span class="s2">def </span><span class="s1">draw_two_pixel(in_x</span><span class="s2">, </span><span class="s1">float_y</span><span class="s2">, </span><span class="s1">factor):</span>
            <span class="s1">flr_y = floor(float_y)</span>
            <span class="s1">draw_pixel(surf</span><span class="s2">, </span><span class="s1">(in_x</span><span class="s2">, </span><span class="s1">flr_y)</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">factor * inv_frac(float_y)</span><span class="s2">, </span><span class="s1">blend)</span>
            <span class="s1">draw_pixel(surf</span><span class="s2">, </span><span class="s1">(in_x</span><span class="s2">, </span><span class="s1">flr_y + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">factor * frac(float_y)</span><span class="s2">, </span><span class="s1">blend)</span>

        <span class="s1">_draw_aaline_dx(d_x</span><span class="s2">, </span><span class="s1">slope</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">draw_two_pixel)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">slope = d_x / d_y</span>

        <span class="s2">def </span><span class="s1">draw_two_pixel(float_x</span><span class="s2">, </span><span class="s1">in_y</span><span class="s2">, </span><span class="s1">factor):</span>
            <span class="s1">fl_x = floor(float_x)</span>
            <span class="s1">draw_pixel(surf</span><span class="s2">, </span><span class="s1">(fl_x</span><span class="s2">, </span><span class="s1">in_y)</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">factor * inv_frac(float_x)</span><span class="s2">, </span><span class="s1">blend)</span>
            <span class="s1">draw_pixel(surf</span><span class="s2">, </span><span class="s1">(fl_x + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">in_y)</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">factor * frac(float_x)</span><span class="s2">, </span><span class="s1">blend)</span>

        <span class="s1">_draw_aaline_dy(d_y</span><span class="s2">, </span><span class="s1">slope</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">draw_two_pixel)</span>


<span class="s2">def </span><span class="s1">_draw_aaline_dy(d_y</span><span class="s2">, </span><span class="s1">slope</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">draw_two_pixel):</span>
    <span class="s1">g_y = ceil(start.y)</span>
    <span class="s1">g_x = start.x + (g_y - start.y) * slope</span>
    <span class="s3"># 1. Draw start of the segment</span>
    <span class="s2">if </span><span class="s1">start.y &lt; g_y:</span>
        <span class="s1">draw_two_pixel(g_x - slope</span><span class="s2">, </span><span class="s1">floor(start.y)</span><span class="s2">, </span><span class="s1">inv_frac(start.y))</span>
    <span class="s3"># 2. Draw end of the segment</span>
    <span class="s1">rest = frac(end.y)</span>
    <span class="s1">s_y = ceil(end.y)</span>
    <span class="s2">if </span><span class="s1">rest &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">s_x = start.x + slope * (d_y + </span><span class="s4">1 </span><span class="s1">- rest)</span>
        <span class="s1">draw_two_pixel(s_x</span><span class="s2">, </span><span class="s1">s_y</span><span class="s2">, </span><span class="s1">rest)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">s_y += </span><span class="s4">1</span>
    <span class="s3"># 3. loop for other points</span>
    <span class="s2">for </span><span class="s1">line_y </span><span class="s2">in </span><span class="s1">range(g_y</span><span class="s2">, </span><span class="s1">s_y):</span>
        <span class="s1">line_x = g_x + slope * (line_y - g_y)</span>
        <span class="s1">draw_two_pixel(line_x</span><span class="s2">, </span><span class="s1">line_y</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_draw_aaline_dx(d_x</span><span class="s2">, </span><span class="s1">slope</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">draw_two_pixel):</span>
    <span class="s3"># A and G are respectively left and right to the &quot;from&quot; point, but</span>
    <span class="s3"># with integer-x-coordinate, (and only if from_x is not integer).</span>
    <span class="s3"># Hence they appear in following order on the line in general case:</span>
    <span class="s3">#  A   from-pt    G    .  .  .        to-pt    S</span>
    <span class="s3">#  |------*-------|--- .  .  . ---|-----*------|-</span>
    <span class="s1">g_x = ceil(start.x)</span>
    <span class="s1">g_y = start.y + (g_x - start.x) * slope</span>
    <span class="s3"># 1. Draw start of the segment if we have a non-integer-part</span>
    <span class="s2">if </span><span class="s1">start.x &lt; g_x:</span>
        <span class="s3"># this corresponds to the point &quot;A&quot;</span>
        <span class="s1">draw_two_pixel(floor(start.x)</span><span class="s2">, </span><span class="s1">g_y - slope</span><span class="s2">, </span><span class="s1">inv_frac(start.x))</span>
    <span class="s3"># 2. Draw end of the segment: we add one pixel for homogeneity reasons</span>
    <span class="s1">rest = frac(end.x)</span>
    <span class="s1">s_x = ceil(end.x)</span>
    <span class="s2">if </span><span class="s1">rest &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3"># Again we draw only if we have a non-integer-part</span>
        <span class="s1">s_y = start.y + slope * (d_x + </span><span class="s4">1 </span><span class="s1">- rest)</span>
        <span class="s1">draw_two_pixel(s_x</span><span class="s2">, </span><span class="s1">s_y</span><span class="s2">, </span><span class="s1">rest)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">s_x += </span><span class="s4">1</span>
    <span class="s3"># 3. loop for other points</span>
    <span class="s2">for </span><span class="s1">line_x </span><span class="s2">in </span><span class="s1">range(g_x</span><span class="s2">, </span><span class="s1">s_x):</span>
        <span class="s1">line_y = g_y + slope * (line_x - g_x)</span>
        <span class="s1">draw_two_pixel(line_x</span><span class="s2">, </span><span class="s1">line_y</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s3">#   C L I P   A N D   D R A W   L I N E   F U N C T I O N S    #</span>


<span class="s2">def </span><span class="s1">_clip_and_draw_line(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">pts):</span>
    <span class="s0">&quot;&quot;&quot;clip the line into the rectangle and draw if needed. 
 
    Returns true if anything has been drawn, else false.&quot;&quot;&quot;</span>
    <span class="s3"># &quot;pts&quot; is a list with the four coordinates of the two endpoints</span>
    <span class="s3"># of the line to be drawn : pts = x1, y1, x2, y2.</span>
    <span class="s3"># The data format is like that to stay closer to the C-algorithm.</span>
    <span class="s2">if not </span><span class="s1">clip_line(</span>
        <span class="s1">pts</span><span class="s2">, </span><span class="s1">BoundingBox(rect.x</span><span class="s2">, </span><span class="s1">rect.y</span><span class="s2">, </span><span class="s1">rect.x + rect.w - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rect.y + rect.h - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s3"># The line segment defined by &quot;pts&quot; is not crossing the rectangle</span>
        <span class="s2">return </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">pts[</span><span class="s4">1</span><span class="s1">] == pts[</span><span class="s4">3</span><span class="s1">]:  </span><span class="s3"># eg y1 == y2</span>
        <span class="s1">_drawhorzline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s2">elif </span><span class="s1">pts[</span><span class="s4">0</span><span class="s1">] == pts[</span><span class="s4">2</span><span class="s1">]:  </span><span class="s3"># eg x1 == x2</span>
        <span class="s1">_drawvertline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">3</span><span class="s1">])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">_draw_line(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">Point(pts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">Point(pts[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pts[</span><span class="s4">3</span><span class="s1">]))</span>
    <span class="s2">return </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">_clip_and_draw_line_width(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">width):</span>
    <span class="s1">yinc = xinc = </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">abs(line[</span><span class="s4">0</span><span class="s1">] - line[</span><span class="s4">2</span><span class="s1">]) &gt; abs(line[</span><span class="s4">1</span><span class="s1">] - line[</span><span class="s4">3</span><span class="s1">]):</span>
        <span class="s1">yinc = </span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">xinc = </span><span class="s4">1</span>
    <span class="s1">newpts = line[:]</span>
    <span class="s2">if </span><span class="s1">_clip_and_draw_line(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">newpts):</span>
        <span class="s1">anydrawn = </span><span class="s4">1</span>
        <span class="s1">frame = newpts[:]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">anydrawn = </span><span class="s4">0</span>
        <span class="s1">frame = [</span><span class="s4">10000</span><span class="s2">, </span><span class="s4">10000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10000</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">loop </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">width // </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">newpts[</span><span class="s4">0</span><span class="s1">] = line[</span><span class="s4">0</span><span class="s1">] + xinc * loop</span>
        <span class="s1">newpts[</span><span class="s4">1</span><span class="s1">] = line[</span><span class="s4">1</span><span class="s1">] + yinc * loop</span>
        <span class="s1">newpts[</span><span class="s4">2</span><span class="s1">] = line[</span><span class="s4">2</span><span class="s1">] + xinc * loop</span>
        <span class="s1">newpts[</span><span class="s4">3</span><span class="s1">] = line[</span><span class="s4">3</span><span class="s1">] + yinc * loop</span>
        <span class="s2">if </span><span class="s1">_clip_and_draw_line(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">newpts):</span>
            <span class="s1">anydrawn = </span><span class="s4">1</span>
            <span class="s1">frame[</span><span class="s4">0</span><span class="s1">] = min(newpts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">frame[</span><span class="s4">1</span><span class="s1">] = min(newpts[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">frame[</span><span class="s4">2</span><span class="s1">] = max(newpts[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">2</span><span class="s1">])</span>
            <span class="s1">frame[</span><span class="s4">3</span><span class="s1">] = max(newpts[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">3</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">loop * </span><span class="s4">2 </span><span class="s1">&lt; width:</span>
            <span class="s1">newpts[</span><span class="s4">0</span><span class="s1">] = line[</span><span class="s4">0</span><span class="s1">] - xinc * loop</span>
            <span class="s1">newpts[</span><span class="s4">1</span><span class="s1">] = line[</span><span class="s4">1</span><span class="s1">] - yinc * loop</span>
            <span class="s1">newpts[</span><span class="s4">2</span><span class="s1">] = line[</span><span class="s4">2</span><span class="s1">] - xinc * loop</span>
            <span class="s1">newpts[</span><span class="s4">3</span><span class="s1">] = line[</span><span class="s4">3</span><span class="s1">] - yinc * loop</span>
            <span class="s2">if </span><span class="s1">_clip_and_draw_line(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">newpts):</span>
                <span class="s1">anydrawn = </span><span class="s4">1</span>
                <span class="s1">frame[</span><span class="s4">0</span><span class="s1">] = min(newpts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s1">frame[</span><span class="s4">1</span><span class="s1">] = min(newpts[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">frame[</span><span class="s4">2</span><span class="s1">] = max(newpts[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">2</span><span class="s1">])</span>
                <span class="s1">frame[</span><span class="s4">3</span><span class="s1">] = max(newpts[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">frame[</span><span class="s4">3</span><span class="s1">])</span>

    <span class="s2">return </span><span class="s1">anydrawn</span>


<span class="s2">def </span><span class="s1">_clip_and_draw_aaline(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">blend):</span>
    <span class="s0">&quot;&quot;&quot;draw anti-aliased line between two endpoints.&quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">clip_line(</span>
        <span class="s1">line</span><span class="s2">,</span>
        <span class="s1">BoundingBox(rect.x - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rect.y - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rect.x + rect.w</span><span class="s2">, </span><span class="s1">rect.y + rect.h)</span><span class="s2">,</span>
        <span class="s1">use_float=</span><span class="s2">True,</span>
    <span class="s1">):</span>
        <span class="s2">return  </span><span class="s3"># TODO Rect(rect.x, rect.y, 0, 0)</span>
    <span class="s1">_draw_aaline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">Point(line[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">line[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">Point(line[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">line[</span><span class="s4">3</span><span class="s1">])</span><span class="s2">, </span><span class="s1">blend)</span>
    <span class="s2">return  </span><span class="s3"># TODO Rect(-- affected area --)</span>


<span class="s3">#    D R A W   L I N E   F U N C T I O N S    #</span>


<span class="s2">def </span><span class="s1">draw_aaline(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">from_point</span><span class="s2">, </span><span class="s1">to_point</span><span class="s2">, </span><span class="s1">blend=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;draw anti-aliased line between two endpoints.&quot;&quot;&quot;</span>
    <span class="s1">line = [from_point[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">from_point[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">to_point[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">to_point[</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s2">return </span><span class="s1">_clip_and_draw_aaline(surf</span><span class="s2">, </span><span class="s1">surf.get_clip()</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">blend)</span>


<span class="s2">def </span><span class="s1">draw_line(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">from_point</span><span class="s2">, </span><span class="s1">to_point</span><span class="s2">, </span><span class="s1">width=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;draw anti-aliased line between two endpoints.&quot;&quot;&quot;</span>
    <span class="s1">line = [from_point[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">from_point[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">to_point[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">to_point[</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s2">return </span><span class="s1">_clip_and_draw_line_width(surf</span><span class="s2">, </span><span class="s1">surf.get_clip()</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">width)</span>


<span class="s3">#   M U L T I L I N E   F U N C T I O N S   #</span>


<span class="s2">def </span><span class="s1">_multi_lines(</span>
    <span class="s1">surf</span><span class="s2">,</span>
    <span class="s1">color</span><span class="s2">,</span>
    <span class="s1">closed</span><span class="s2">,  </span><span class="s3"># pylint: disable=too-many-arguments</span>
    <span class="s1">points</span><span class="s2">,</span>
    <span class="s1">width=</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">blend=</span><span class="s2">False,</span>
    <span class="s1">aaline=</span><span class="s2">False,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;draw several lines, either anti-aliased or not.&quot;&quot;&quot;</span>
    <span class="s3"># The code for anti-aliased or not is almost identical, so it's factorized</span>
    <span class="s2">if </span><span class="s1">len(points) &lt;= </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span>
    <span class="s1">line = [</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">4  </span><span class="s3"># store x1, y1 &amp; x2, y2 of the lines to be drawn</span>

    <span class="s1">xlist = [pt[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">points]</span>
    <span class="s1">ylist = [pt[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">points]</span>
    <span class="s1">line[</span><span class="s4">0</span><span class="s1">] = xlist[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">line[</span><span class="s4">1</span><span class="s1">] = ylist[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">b_box = BoundingBox(left=xlist[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">right=xlist[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">top=ylist[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bottom=ylist[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s2">for </span><span class="s1">line_x</span><span class="s2">, </span><span class="s1">line_y </span><span class="s2">in </span><span class="s1">points[</span><span class="s4">1</span><span class="s1">:]:</span>
        <span class="s1">b_box.left = min(b_box.left</span><span class="s2">, </span><span class="s1">line_x)</span>
        <span class="s1">b_box.right = max(b_box.right</span><span class="s2">, </span><span class="s1">line_x)</span>
        <span class="s1">b_box.top = min(b_box.top</span><span class="s2">, </span><span class="s1">line_y)</span>
        <span class="s1">b_box.bottom = max(b_box.bottom</span><span class="s2">, </span><span class="s1">line_y)</span>

    <span class="s1">rect = surf.get_clip()</span>
    <span class="s2">for </span><span class="s1">loop </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">len(points)):</span>

        <span class="s1">line[</span><span class="s4">0</span><span class="s1">] = xlist[loop - </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">line[</span><span class="s4">1</span><span class="s1">] = ylist[loop - </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">line[</span><span class="s4">2</span><span class="s1">] = xlist[loop]</span>
        <span class="s1">line[</span><span class="s4">3</span><span class="s1">] = ylist[loop]</span>
        <span class="s2">if </span><span class="s1">aaline:</span>
            <span class="s1">_clip_and_draw_aaline(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">blend)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_clip_and_draw_line_width(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">width)</span>

    <span class="s2">if </span><span class="s1">closed:</span>
        <span class="s1">line[</span><span class="s4">0</span><span class="s1">] = xlist[len(points) - </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">line[</span><span class="s4">1</span><span class="s1">] = ylist[len(points) - </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">line[</span><span class="s4">2</span><span class="s1">] = xlist[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">line[</span><span class="s4">3</span><span class="s1">] = ylist[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">aaline:</span>
            <span class="s1">_clip_and_draw_aaline(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">blend)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_clip_and_draw_line_width(surf</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">width)</span>

    <span class="s3"># TODO Rect(...)</span>


<span class="s2">def </span><span class="s1">draw_lines(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">width=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;draw several lines connected through the points.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_multi_lines(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">aaline=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">draw_aalines(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">blend=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;draw several anti-aliased lines connected through the points.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_multi_lines(surf</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">blend=blend</span><span class="s2">, </span><span class="s1">aaline=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">draw_polygon(surface</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">width):</span>
    <span class="s0">&quot;&quot;&quot;Draw a polygon&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">width:</span>
        <span class="s1">draw_lines(surface</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">width)</span>
        <span class="s2">return  </span><span class="s3"># TODO Rect(...)</span>
    <span class="s1">num_points = len(points)</span>
    <span class="s1">point_x = [x </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">points]</span>
    <span class="s1">point_y = [y </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">points]</span>

    <span class="s1">miny = min(point_y)</span>
    <span class="s1">maxy = max(point_y)</span>

    <span class="s2">if </span><span class="s1">miny == maxy:</span>
        <span class="s1">minx = min(point_x)</span>
        <span class="s1">maxx = max(point_x)</span>
        <span class="s1">_clip_and_draw_horizline(surface</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">minx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">maxx)</span>
        <span class="s2">return  </span><span class="s3"># TODO Rect(...)</span>

    <span class="s2">for </span><span class="s1">y_coord </span><span class="s2">in </span><span class="s1">range(miny</span><span class="s2">, </span><span class="s1">maxy + </span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">x_intersect = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_points):</span>
            <span class="s1">_draw_polygon_inner_loop(i</span><span class="s2">, </span><span class="s1">point_x</span><span class="s2">, </span><span class="s1">point_y</span><span class="s2">, </span><span class="s1">y_coord</span><span class="s2">, </span><span class="s1">x_intersect)</span>

        <span class="s1">x_intersect.sort()</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">len(x_intersect)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s1">_clip_and_draw_horizline(</span>
                <span class="s1">surface</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">x_intersect[i]</span><span class="s2">, </span><span class="s1">y_coord</span><span class="s2">, </span><span class="s1">x_intersect[i + </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">)</span>

    <span class="s3"># special case : horizontal border lines</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_points):</span>
        <span class="s1">i_prev = i - </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">i </span><span class="s2">else </span><span class="s1">num_points - </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">miny &lt; point_y[i] == point_y[i_prev] &lt; maxy:</span>
            <span class="s1">_clip_and_draw_horizline(</span>
                <span class="s1">surface</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">point_x[i]</span><span class="s2">, </span><span class="s1">point_y[i]</span><span class="s2">, </span><span class="s1">point_x[i_prev]</span>
            <span class="s1">)</span>

    <span class="s2">return  </span><span class="s3"># TODO Rect(...)</span>


<span class="s2">def </span><span class="s1">_draw_polygon_inner_loop(index</span><span class="s2">, </span><span class="s1">point_x</span><span class="s2">, </span><span class="s1">point_y</span><span class="s2">, </span><span class="s1">y_coord</span><span class="s2">, </span><span class="s1">x_intersect):</span>
    <span class="s1">i_prev = index - </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">index </span><span class="s2">else </span><span class="s1">len(point_x) - </span><span class="s4">1</span>

    <span class="s1">y_1 = point_y[i_prev]</span>
    <span class="s1">y_2 = point_y[index]</span>

    <span class="s2">if </span><span class="s1">y_1 &lt; y_2:</span>
        <span class="s1">x_1 = point_x[i_prev]</span>
        <span class="s1">x_2 = point_x[index]</span>
    <span class="s2">elif </span><span class="s1">y_1 &gt; y_2:</span>
        <span class="s1">y_2 = point_y[i_prev]</span>
        <span class="s1">y_1 = point_y[index]</span>
        <span class="s1">x_2 = point_x[i_prev]</span>
        <span class="s1">x_1 = point_x[index]</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s3"># special case handled below</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">(y_2 &gt; y_coord &gt;= y_1) </span><span class="s2">or </span><span class="s1">((y_coord == max(point_y)) </span><span class="s2">and </span><span class="s1">(y_coord &lt;= y_2)):</span>
        <span class="s1">x_intersect.append((y_coord - y_1) * (x_2 - x_1) // (y_2 - y_1) + x_1)</span>
</pre>
</body>
</html>