<html>
<head>
<title>png.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
png.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python</span>

<span class="s0"># $URL: http://pypng.googlecode.com/svn/trunk/code/png.py $</span>
<span class="s0"># $Rev: 228 $</span>

<span class="s0"># png.py - PNG encoder/decoder in pure Python</span>
<span class="s0">#</span>
<span class="s0"># Modified for Pygame in Oct., 2012 to work with Python 3.x.</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2006 Johann C. Rocholl &lt;johann@browsershots.org&gt;</span>
<span class="s0"># Portions Copyright (C) 2009 David Jones &lt;drj@pobox.com&gt;</span>
<span class="s0"># And probably portions Copyright (C) 2006 Nicko van Someren &lt;nicko@nicko.org&gt;</span>
<span class="s0">#</span>
<span class="s0"># Original concept by Johann C. Rocholl.</span>
<span class="s0">#</span>
<span class="s0"># LICENSE (The MIT License)</span>
<span class="s0">#</span>
<span class="s0"># Permission is hereby granted, free of charge, to any person</span>
<span class="s0"># obtaining a copy of this software and associated documentation files</span>
<span class="s0"># (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<span class="s0"># including without limitation the rights to use, copy, modify, merge,</span>
<span class="s0"># publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="s0"># and to permit persons to whom the Software is furnished to do so,</span>
<span class="s0"># subject to the following conditions:</span>
<span class="s0">#</span>
<span class="s0"># The above copyright notice and this permission notice shall be</span>
<span class="s0"># included in all copies or substantial portions of the Software.</span>
<span class="s0">#</span>
<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="s0"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="s0"># NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="s0"># BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="s0"># ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="s0"># CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="s0"># SOFTWARE.</span>
<span class="s0">#</span>
<span class="s0"># Changelog (recent first):</span>
<span class="s0"># 2009-03-11 David: interlaced bit depth &lt; 8 (writing).</span>
<span class="s0"># 2009-03-10 David: interlaced bit depth &lt; 8 (reading).</span>
<span class="s0"># 2009-03-04 David: Flat and Boxed pixel formats.</span>
<span class="s0"># 2009-02-26 David: Palette support (writing).</span>
<span class="s0"># 2009-02-23 David: Bit-depths &lt; 8; better PNM support.</span>
<span class="s0"># 2006-06-17 Nicko: Reworked into a class, faster interlacing.</span>
<span class="s0"># 2006-06-17 Johann: Very simple prototype PNG decoder.</span>
<span class="s0"># 2006-06-17 Nicko: Test suite with various image generators.</span>
<span class="s0"># 2006-06-17 Nicko: Alpha-channel, grey-scale, 16-bit/plane support.</span>
<span class="s0"># 2006-06-15 Johann: Scanline iterator interface for large input files.</span>
<span class="s0"># 2006-06-09 Johann: Very simple prototype PNG encoder.</span>

<span class="s0"># Incorporated into Bangai-O Development Tools by drj on 2009-02-11 from</span>
<span class="s0"># http://trac.browsershots.org/browser/trunk/pypng/lib/png.py?rev=2885</span>

<span class="s0"># Incorporated into pypng by drj on 2009-03-12 from</span>
<span class="s0"># //depot/prj/bangaio/master/code/png.py#67</span>


<span class="s2">&quot;&quot;&quot; 
Pure Python PNG Reader/Writer 
 
This Python module implements support for PNG images (see PNG 
specification at http://www.w3.org/TR/2003/REC-PNG-20031110/ ). It reads 
and writes PNG files with all allowable bit depths (1/2/4/8/16/24/32/48/64 
bits per pixel) and colour combinations: greyscale (1/2/4/8/16 bit); RGB, 
RGBA, LA (greyscale with alpha) with 8/16 bits per channel; colour mapped 
images (1/2/4/8 bit).  Adam7 interlacing is supported for reading and 
writing.  A number of optional chunks can be specified (when writing) 
and understood (when reading): ``tRNS``, ``bKGD``, ``gAMA``. 
 
For help, type ``import png; help(png)`` in your python interpreter. 
 
A good place to start is the :class:`Reader` and :class:`Writer` classes. 
 
This file can also be used as a command-line utility to convert 
`Netpbm &lt;http://netpbm.sourceforge.net/&gt;`_ PNM files to PNG, and the reverse conversion from PNG to 
PNM. The interface is similar to that of the ``pnmtopng`` program from 
Netpbm.  Type ``python png.py --help`` at the shell prompt 
for usage and a list of options. 
 
A note on spelling and terminology 
---------------------------------- 
 
Generally British English spelling is used in the documentation.  So 
that's &quot;greyscale&quot; and &quot;colour&quot;.  This not only matches the author's 
native language, it's also used by the PNG specification. 
 
The major colour models supported by PNG (and hence by PyPNG) are: 
greyscale, RGB, greyscale--alpha, RGB--alpha.  These are sometimes 
referred to using the abbreviations: L, RGB, LA, RGBA.  In this case 
each letter abbreviates a single channel: *L* is for Luminance or Luma or 
Lightness which is the channel used in greyscale images; *R*, *G*, *B* stand 
for Red, Green, Blue, the components of a colour image; *A* stands for 
Alpha, the opacity channel (used for transparency effects, but higher 
values are more opaque, so it makes sense to call it opacity). 
 
A note on formats 
----------------- 
 
When getting pixel data out of this module (reading) and presenting 
data to this module (writing) there are a number of ways the data could 
be represented as a Python value.  Generally this module uses one of 
three formats called &quot;flat row flat pixel&quot;, &quot;boxed row flat pixel&quot;, and 
&quot;boxed row boxed pixel&quot;.  Basically the concern is whether each pixel 
and each row comes in its own little tuple (box), or not. 
 
Consider an image that is 3 pixels wide by 2 pixels high, and each pixel 
has RGB components: 
 
Boxed row flat pixel:: 
 
  list([R,G,B, R,G,B, R,G,B], 
       [R,G,B, R,G,B, R,G,B]) 
 
Each row appears as its own list, but the pixels are flattened so that 
three values for one pixel simply follow the three values for the previous 
pixel.  This is the most common format used, because it provides a good 
compromise between space and convenience.  PyPNG regards itself as 
at liberty to replace any sequence type with any sufficiently compatible 
other sequence type; in practice each row is an array (from the array 
module), and the outer list is sometimes an iterator rather than an 
explicit list (so that streaming is possible). 
 
Flat row flat pixel:: 
 
  [R,G,B, R,G,B, R,G,B, 
   R,G,B, R,G,B, R,G,B] 
 
The entire image is one single giant sequence of colour values. 
Generally an array will be used (to save space), not a list. 
 
Boxed row boxed pixel:: 
 
  list([ (R,G,B), (R,G,B), (R,G,B) ], 
       [ (R,G,B), (R,G,B), (R,G,B) ]) 
 
Each row appears in its own list, but each pixel also appears in its own 
tuple.  A serious memory burn in Python. 
 
In all cases the top row comes first, and for each row the pixels are 
ordered from left-to-right.  Within a pixel the values appear in the 
order, R-G-B-A (or L-A for greyscale--alpha). 
 
There is a fourth format, mentioned because it is used internally, 
is close to what lies inside a PNG file itself, and has some support 
from the public API.  This format is called packed.  When packed, 
each row is a sequence of bytes (integers from 0 to 255), just as 
it is before PNG scanline filtering is applied.  When the bit depth 
is 8 this is essentially the same as boxed row flat pixel; when the 
bit depth is less than 8, several pixels are packed into each byte; 
when the bit depth is 16 (the only value more than 8 that is supported 
by the PNG image format) each pixel value is decomposed into 2 bytes 
(and `packed` is a misnomer).  This format is used by the 
:meth:`Writer.write_packed` method.  It isn't usually a convenient 
format, but may be just right if the source data for the PNG image 
comes from something that uses a similar format (for example, 1-bit 
BMPs, or another PNG file). 
 
And now, my famous members 
-------------------------- 
&quot;&quot;&quot;</span>

<span class="s1">__version__ = </span><span class="s3">&quot;$URL: http://pypng.googlecode.com/svn/trunk/code/png.py $ $Rev: 228 $&quot;</span>

<span class="s4">import </span><span class="s1">io</span>
<span class="s4">import </span><span class="s1">itertools</span>
<span class="s4">import </span><span class="s1">math</span>
<span class="s4">import </span><span class="s1">operator</span>
<span class="s4">import </span><span class="s1">struct</span>
<span class="s4">import </span><span class="s1">sys</span>
<span class="s4">import </span><span class="s1">zlib</span>
<span class="s4">import </span><span class="s1">warnings</span>
<span class="s4">from </span><span class="s1">array </span><span class="s4">import </span><span class="s1">array</span>
<span class="s4">from </span><span class="s1">functools </span><span class="s4">import </span><span class="s1">reduce</span>

<span class="s4">from </span><span class="s1">pygame.tests.test_utils </span><span class="s4">import </span><span class="s1">tostring</span>

<span class="s1">__all__ = [</span><span class="s3">&quot;Image&quot;</span><span class="s4">, </span><span class="s3">&quot;Reader&quot;</span><span class="s4">, </span><span class="s3">&quot;Writer&quot;</span><span class="s4">, </span><span class="s3">&quot;write_chunks&quot;</span><span class="s4">, </span><span class="s3">&quot;from_array&quot;</span><span class="s1">]</span>


<span class="s0"># The PNG signature.</span>
<span class="s0"># http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
<span class="s1">_signature = struct.pack(</span><span class="s3">&quot;8B&quot;</span><span class="s4">, </span><span class="s5">137</span><span class="s4">, </span><span class="s5">80</span><span class="s4">, </span><span class="s5">78</span><span class="s4">, </span><span class="s5">71</span><span class="s4">, </span><span class="s5">13</span><span class="s4">, </span><span class="s5">10</span><span class="s4">, </span><span class="s5">26</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>

<span class="s1">_adam7 = (</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">4</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">2</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span><span class="s4">,</span>
<span class="s1">)</span>


<span class="s4">def </span><span class="s1">group(s</span><span class="s4">, </span><span class="s1">n):</span>
    <span class="s0"># See</span>
    <span class="s0"># http://www.python.org/doc/2.6/library/functions.html#zip</span>
    <span class="s4">return </span><span class="s1">zip(*[iter(s)] * n)</span>


<span class="s4">def </span><span class="s1">isarray(x):</span>
    <span class="s2">&quot;&quot;&quot;Same as ``isinstance(x, array)``.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">isinstance(x</span><span class="s4">, </span><span class="s1">array)</span>


<span class="s0"># Conditionally convert to bytes.  Works on Python 2 and Python 3.</span>
<span class="s4">try</span><span class="s1">:</span>
    <span class="s1">bytes(</span><span class="s3">&quot;&quot;</span><span class="s4">, </span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">strtobytes(x):</span>
        <span class="s4">return </span><span class="s1">bytes(x</span><span class="s4">, </span><span class="s3">&quot;iso8859-1&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">bytestostr(x):</span>
        <span class="s4">return </span><span class="s1">str(x</span><span class="s4">, </span><span class="s3">&quot;iso8859-1&quot;</span><span class="s1">)</span>

<span class="s4">except</span><span class="s1">:</span>
    <span class="s1">strtobytes = str</span>
    <span class="s1">bytestostr = str</span>


<span class="s4">def </span><span class="s1">interleave_planes(ipixels</span><span class="s4">, </span><span class="s1">apixels</span><span class="s4">, </span><span class="s1">ipsize</span><span class="s4">, </span><span class="s1">apsize):</span>
    <span class="s2">&quot;&quot;&quot; 
    Interleave (colour) planes, e.g. RGB + A = RGBA. 
 
    Return an array of pixels consisting of the `ipsize` elements of data 
    from each pixel in `ipixels` followed by the `apsize` elements of data 
    from each pixel in `apixels`.  Conventionally `ipixels` and 
    `apixels` are byte arrays so the sizes are bytes, but it actually 
    works with any arrays of the same type.  The returned array is the 
    same type as the input arrays which should be the same type as each other. 
    &quot;&quot;&quot;</span>

    <span class="s1">itotal = len(ipixels)</span>
    <span class="s1">atotal = len(apixels)</span>
    <span class="s1">newtotal = itotal + atotal</span>
    <span class="s1">newpsize = ipsize + apsize</span>
    <span class="s0"># Set up the output buffer</span>
    <span class="s0"># See http://www.python.org/doc/2.4.4/lib/module-array.html#l2h-1356</span>
    <span class="s1">out = array(ipixels.typecode)</span>
    <span class="s0"># It's annoying that there is no cheap way to set the array size :-(</span>
    <span class="s1">out.extend(ipixels)</span>
    <span class="s1">out.extend(apixels)</span>
    <span class="s0"># Interleave in the pixel data</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(ipsize):</span>
        <span class="s1">out[i:newtotal:newpsize] = ipixels[i:itotal:ipsize]</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(apsize):</span>
        <span class="s1">out[i + ipsize : newtotal : newpsize] = apixels[i:atotal:apsize]</span>
    <span class="s4">return </span><span class="s1">out</span>


<span class="s4">def </span><span class="s1">check_palette(palette):</span>
    <span class="s2">&quot;&quot;&quot;Check a palette argument (to the :class:`Writer` class) for validity. 
    Returns the palette as a list if okay; raises an exception otherwise. 
    &quot;&quot;&quot;</span>

    <span class="s0"># None is the default and is allowed.</span>
    <span class="s4">if </span><span class="s1">palette </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">return None</span>

    <span class="s1">p = list(palette)</span>
    <span class="s4">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt; len(p) &lt;= </span><span class="s5">256</span><span class="s1">):</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;a palette must have between 1 and 256 entries&quot;</span><span class="s1">)</span>
    <span class="s1">seen_triple = </span><span class="s4">False</span>
    <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">t </span><span class="s4">in </span><span class="s1">enumerate(p):</span>
        <span class="s4">if </span><span class="s1">len(t) </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;palette entry %d: entries must be 3- or 4-tuples.&quot; </span><span class="s1">% i)</span>
        <span class="s4">if </span><span class="s1">len(t) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">seen_triple = </span><span class="s4">True</span>
        <span class="s4">if </span><span class="s1">seen_triple </span><span class="s4">and </span><span class="s1">len(t) == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;palette entry %d: all 4-tuples must precede all 3-tuples&quot; </span><span class="s1">% i</span>
            <span class="s1">)</span>
        <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">t:</span>
            <span class="s4">if </span><span class="s1">int(x) != x </span><span class="s4">or not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= x &lt;= </span><span class="s5">255</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;palette entry %d: values must be integer: 0 &lt;= x &lt;= 255&quot; </span><span class="s1">% i</span>
                <span class="s1">)</span>
    <span class="s4">return </span><span class="s1">p</span>


<span class="s4">class </span><span class="s1">Error(Exception):</span>
    <span class="s1">prefix = </span><span class="s3">&quot;Error&quot;</span>

    <span class="s4">def </span><span class="s1">__str__(self):</span>
        <span class="s4">return </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">self.prefix</span><span class="s4">}</span><span class="s3">: </span><span class="s4">{</span><span class="s3">&quot; &quot;</span><span class="s1">.join(self.args)</span><span class="s4">}</span><span class="s3">'</span>


<span class="s4">class </span><span class="s1">FormatError(Error):</span>
    <span class="s2">&quot;&quot;&quot;Problem with input file format.  In other words, PNG file does 
    not conform to the specification in some way and is invalid. 
    &quot;&quot;&quot;</span>

    <span class="s1">prefix = </span><span class="s3">&quot;FormatError&quot;</span>


<span class="s4">class </span><span class="s1">ChunkError(FormatError):</span>
    <span class="s1">prefix = </span><span class="s3">&quot;ChunkError&quot;</span>


<span class="s4">class </span><span class="s1">Writer:</span>
    <span class="s2">&quot;&quot;&quot; 
    PNG encoder in pure Python. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">width=</span><span class="s4">None,</span>
        <span class="s1">height=</span><span class="s4">None,</span>
        <span class="s1">size=</span><span class="s4">None,</span>
        <span class="s1">greyscale=</span><span class="s4">False,</span>
        <span class="s1">alpha=</span><span class="s4">False,</span>
        <span class="s1">bitdepth=</span><span class="s5">8</span><span class="s4">,</span>
        <span class="s1">palette=</span><span class="s4">None,</span>
        <span class="s1">transparent=</span><span class="s4">None,</span>
        <span class="s1">background=</span><span class="s4">None,</span>
        <span class="s1">gamma=</span><span class="s4">None,</span>
        <span class="s1">compression=</span><span class="s4">None,</span>
        <span class="s1">interlace=</span><span class="s4">False,</span>
        <span class="s1">bytes_per_sample=</span><span class="s4">None,  </span><span class="s0"># deprecated</span>
        <span class="s1">planes=</span><span class="s4">None,</span>
        <span class="s1">colormap=</span><span class="s4">None,</span>
        <span class="s1">maxval=</span><span class="s4">None,</span>
        <span class="s1">chunk_limit=</span><span class="s5">2</span><span class="s1">**</span><span class="s5">20</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a PNG encoder object. 
 
        Arguments: 
 
        width, height 
          Image size in pixels, as two separate arguments. 
        size 
          Image size (w,h) in pixels, as single argument. 
        greyscale 
          Input data is greyscale, not RGB. 
        alpha 
          Input data has alpha channel (RGBA or LA). 
        bitdepth 
          Bit depth: from 1 to 16. 
        palette 
          Create a palette for a colour mapped image (colour type 3). 
        transparent 
          Specify a transparent colour (create a ``tRNS`` chunk). 
        background 
          Specify a default background colour (create a ``bKGD`` chunk). 
        gamma 
          Specify a gamma value (create a ``gAMA`` chunk). 
        compression 
          zlib compression level (1-9). 
        interlace 
          Create an interlaced image. 
        chunk_limit 
          Write multiple ``IDAT`` chunks to save memory. 
 
        The image size (in pixels) can be specified either by using the 
        `width` and `height` arguments, or with the single `size` 
        argument.  If `size` is used it should be a pair (*width*, 
        *height*). 
 
        `greyscale` and `alpha` are booleans that specify whether 
        an image is greyscale (or colour), and whether it has an 
        alpha channel (or not). 
 
        `bitdepth` specifies the bit depth of the source pixel values. 
        Each source pixel value must be an integer between 0 and 
        ``2**bitdepth-1``.  For example, 8-bit images have values 
        between 0 and 255.  PNG only stores images with bit depths of 
        1,2,4,8, or 16.  When `bitdepth` is not one of these values, 
        the next highest valid bit depth is selected, and an ``sBIT`` 
        (significant bits) chunk is generated that specifies the original 
        precision of the source image.  In this case the supplied pixel 
        values will be rescaled to fit the range of the selected bit depth. 
 
        The details of which bit depth / colour model combinations the 
        PNG file format supports directly, are somewhat arcane 
        (refer to the PNG specification for full details).  Briefly: 
        &quot;small&quot; bit depths (1,2,4) are only allowed with greyscale and 
        colour mapped images; colour mapped images cannot have bit depth 
        16. 
 
        For colour mapped images (in other words, when the `palette` 
        argument is specified) the `bitdepth` argument must match one of 
        the valid PNG bit depths: 1, 2, 4, or 8.  (It is valid to have a 
        PNG image with a palette and an ``sBIT`` chunk, but the meaning 
        is slightly different; it would be awkward to press the 
        `bitdepth` argument into service for this.) 
 
        The `palette` option, when specified, causes a colour mapped image 
        to be created: the PNG colour type is set to 3; greyscale 
        must not be set; alpha must not be set; transparent must 
        not be set; the bit depth must be 1,2,4, or 8.  When a colour 
        mapped image is created, the pixel values are palette indexes 
        and the `bitdepth` argument specifies the size of these indexes 
        (not the size of the colour values in the palette). 
 
        The palette argument value should be a sequence of 3- or 
        4-tuples.  3-tuples specify RGB palette entries; 4-tuples 
        specify RGBA palette entries.  If both 4-tuples and 3-tuples 
        appear in the sequence then all the 4-tuples must come 
        before all the 3-tuples.  A ``PLTE`` chunk is created; if there 
        are 4-tuples then a ``tRNS`` chunk is created as well.  The 
        ``PLTE`` chunk will contain all the RGB triples in the same 
        sequence; the ``tRNS`` chunk will contain the alpha channel for 
        all the 4-tuples, in the same sequence.  Palette entries 
        are always 8-bit. 
 
        If specified, the `transparent` and `background` parameters must 
        be a tuple with three integer values for red, green, blue, or 
        a simple integer (or singleton tuple) for a greyscale image. 
 
        If specified, the `gamma` parameter must be a positive number 
        (generally, a float).  A ``gAMA`` chunk will be created.  Note that 
        this will not change the values of the pixels as they appear in 
        the PNG file, they are assumed to have already been converted 
        appropriately for the gamma specified. 
 
        The `compression` argument specifies the compression level 
        to be used by the ``zlib`` module.  Higher values are likely 
        to compress better, but will be slower to compress.  The 
        default for this argument is ``None``; this does not mean 
        no compression, rather it means that the default from the 
        ``zlib`` module is used (which is generally acceptable). 
 
        If `interlace` is true then an interlaced image is created 
        (using PNG's so far only interlace method, *Adam7*).  This does not 
        affect how the pixels should be presented to the encoder, rather 
        it changes how they are arranged into the PNG file.  On slow 
        connexions interlaced images can be partially decoded by the 
        browser to give a rough view of the image that is successively 
        refined as more image data appears. 
 
        .. note :: 
 
          Enabling the `interlace` option requires the entire image 
          to be processed in working memory. 
 
        `chunk_limit` is used to limit the amount of memory used whilst 
        compressing the image.  In order to avoid using large amounts of 
        memory, multiple ``IDAT`` chunks may be created. 
        &quot;&quot;&quot;</span>

        <span class="s0"># At the moment the `planes` argument is ignored;</span>
        <span class="s0"># its purpose is to act as a dummy so that</span>
        <span class="s0"># ``Writer(x, y, **info)`` works, where `info` is a dictionary</span>
        <span class="s0"># returned by Reader.read and friends.</span>
        <span class="s0"># Ditto for `colormap`.</span>

        <span class="s0"># A couple of helper functions come first.  Best skipped if you</span>
        <span class="s0"># are reading through.</span>

        <span class="s4">def </span><span class="s1">isinteger(x):</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">int(x) == x</span>
            <span class="s4">except</span><span class="s1">:</span>
                <span class="s4">return False</span>

        <span class="s4">def </span><span class="s1">check_color(c</span><span class="s4">, </span><span class="s1">which):</span>
            <span class="s2">&quot;&quot;&quot;Checks that a colour argument for transparent or 
            background options is the right form.  Also &quot;corrects&quot; bare 
            integers to 1-tuples. 
            &quot;&quot;&quot;</span>

            <span class="s4">if </span><span class="s1">c </span><span class="s4">is None</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">c</span>
            <span class="s4">if </span><span class="s1">greyscale:</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">l = len(c)</span>
                <span class="s4">except </span><span class="s1">TypeError:</span>
                    <span class="s1">c = (c</span><span class="s4">,</span><span class="s1">)</span>
                <span class="s4">if </span><span class="s1">len(c) != </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">which</span><span class="s4">} </span><span class="s3">for greyscale must be 1-tuple&quot;</span><span class="s1">)</span>
                <span class="s4">if not </span><span class="s1">isinteger(c[</span><span class="s5">0</span><span class="s1">]):</span>
                    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">which</span><span class="s4">} </span><span class="s3">colour for greyscale must be integer&quot;</span><span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">if not </span><span class="s1">(</span>
                    <span class="s1">len(c) == </span><span class="s5">3</span>
                    <span class="s4">and </span><span class="s1">isinteger(c[</span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s4">and </span><span class="s1">isinteger(c[</span><span class="s5">1</span><span class="s1">])</span>
                    <span class="s4">and </span><span class="s1">isinteger(c[</span><span class="s5">2</span><span class="s1">])</span>
                <span class="s1">):</span>
                    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">which</span><span class="s4">} </span><span class="s3">colour must be a triple of integers&quot;</span><span class="s1">)</span>
            <span class="s4">return </span><span class="s1">c</span>

        <span class="s4">if </span><span class="s1">size:</span>
            <span class="s4">if </span><span class="s1">len(size) != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;size argument should be a pair (width, height)&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">width </span><span class="s4">is not None and </span><span class="s1">width != size[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;size[0] (%r) and width (%r) should match when both are used.&quot;</span>
                    <span class="s1">% (size[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">width)</span>
                <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">height </span><span class="s4">is not None and </span><span class="s1">height != size[</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;size[1] (%r) and height (%r) should match when both are used.&quot;</span>
                    <span class="s1">% (size[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">height)</span>
                <span class="s1">)</span>
            <span class="s1">width</span><span class="s4">, </span><span class="s1">height = size</span>
        <span class="s4">del </span><span class="s1">size</span>

        <span class="s4">if </span><span class="s1">width &lt;= </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">height &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;width and height must be greater than zero&quot;</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">isinteger(width) </span><span class="s4">or not </span><span class="s1">isinteger(height):</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;width and height must be integers&quot;</span><span class="s1">)</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#7Integers-and-byte-order</span>
        <span class="s4">if </span><span class="s1">width &gt; </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32 </span><span class="s1">- </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">height &gt; </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;width and height cannot exceed 2**32-1&quot;</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s1">alpha </span><span class="s4">and </span><span class="s1">transparent </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;transparent colour not allowed with alpha channel&quot;</span><span class="s1">)</span>

        <span class="s4">if </span><span class="s1">bytes_per_sample </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;please use bitdepth instead of bytes_per_sample&quot;</span><span class="s4">, </span><span class="s1">DeprecationWarning</span>
            <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">bytes_per_sample </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">0.125</span><span class="s4">, </span><span class="s5">0.25</span><span class="s4">, </span><span class="s5">0.5</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;bytes per sample must be .125, .25, .5, 1, or 2&quot;</span><span class="s1">)</span>
            <span class="s1">bitdepth = int(</span><span class="s5">8 </span><span class="s1">* bytes_per_sample)</span>
        <span class="s4">del </span><span class="s1">bytes_per_sample</span>
        <span class="s4">if not </span><span class="s1">isinteger(bitdepth) </span><span class="s4">or </span><span class="s1">bitdepth &lt; </span><span class="s5">1 </span><span class="s4">or </span><span class="s5">16 </span><span class="s1">&lt; bitdepth:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;bitdepth (</span><span class="s4">{</span><span class="s1">bitdepth</span><span class="s4">!r}</span><span class="s3">) must be a positive integer &lt;= 16&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.rescale = </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">palette:</span>
            <span class="s4">if </span><span class="s1">bitdepth </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;with palette, bitdepth must be 1, 2, 4, or 8&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">transparent </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;transparent and palette not compatible&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">alpha:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;alpha and palette not compatible&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">greyscale:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;greyscale and palette not compatible&quot;</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># No palette, check for sBIT chunk generation.</span>
            <span class="s4">if </span><span class="s1">alpha </span><span class="s4">or not </span><span class="s1">greyscale:</span>
                <span class="s4">if </span><span class="s1">bitdepth </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">8</span><span class="s4">, </span><span class="s5">16</span><span class="s1">):</span>
                    <span class="s1">targetbitdepth = (</span><span class="s5">8</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)[bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
                    <span class="s1">self.rescale = (bitdepth</span><span class="s4">, </span><span class="s1">targetbitdepth)</span>
                    <span class="s1">bitdepth = targetbitdepth</span>
                    <span class="s4">del </span><span class="s1">targetbitdepth</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">assert </span><span class="s1">greyscale</span>
                <span class="s4">assert not </span><span class="s1">alpha</span>
                <span class="s4">if </span><span class="s1">bitdepth </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">16</span><span class="s1">):</span>
                    <span class="s4">if </span><span class="s1">bitdepth &gt; </span><span class="s5">8</span><span class="s1">:</span>
                        <span class="s1">targetbitdepth = </span><span class="s5">16</span>
                    <span class="s4">elif </span><span class="s1">bitdepth == </span><span class="s5">3</span><span class="s1">:</span>
                        <span class="s1">targetbitdepth = </span><span class="s5">4</span>
                    <span class="s4">else</span><span class="s1">:</span>
                        <span class="s4">assert </span><span class="s1">bitdepth </span><span class="s4">in </span><span class="s1">(</span><span class="s5">5</span><span class="s4">, </span><span class="s5">6</span><span class="s4">, </span><span class="s5">7</span><span class="s1">)</span>
                        <span class="s1">targetbitdepth = </span><span class="s5">8</span>
                    <span class="s1">self.rescale = (bitdepth</span><span class="s4">, </span><span class="s1">targetbitdepth)</span>
                    <span class="s1">bitdepth = targetbitdepth</span>
                    <span class="s4">del </span><span class="s1">targetbitdepth</span>

        <span class="s4">if </span><span class="s1">bitdepth &lt; </span><span class="s5">8 </span><span class="s4">and </span><span class="s1">(alpha </span><span class="s4">or not </span><span class="s1">greyscale </span><span class="s4">and not </span><span class="s1">palette):</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;bitdepth &lt; 8 only permitted with greyscale or palette&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">bitdepth &gt; </span><span class="s5">8 </span><span class="s4">and </span><span class="s1">palette:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;bit depth must be 8 or less for images with palette&quot;</span><span class="s1">)</span>

        <span class="s1">transparent = check_color(transparent</span><span class="s4">, </span><span class="s3">&quot;transparent&quot;</span><span class="s1">)</span>
        <span class="s1">background = check_color(background</span><span class="s4">, </span><span class="s3">&quot;background&quot;</span><span class="s1">)</span>

        <span class="s0"># It's important that the true boolean values (greyscale, alpha,</span>
        <span class="s0"># colormap, interlace) are converted to bool because Iverson's</span>
        <span class="s0"># convention is relied upon later on.</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.height = height</span>
        <span class="s1">self.transparent = transparent</span>
        <span class="s1">self.background = background</span>
        <span class="s1">self.gamma = gamma</span>
        <span class="s1">self.greyscale = bool(greyscale)</span>
        <span class="s1">self.alpha = bool(alpha)</span>
        <span class="s1">self.colormap = bool(palette)</span>
        <span class="s1">self.bitdepth = int(bitdepth)</span>
        <span class="s1">self.compression = compression</span>
        <span class="s1">self.chunk_limit = chunk_limit</span>
        <span class="s1">self.interlace = bool(interlace)</span>
        <span class="s1">self.palette = check_palette(palette)</span>

        <span class="s1">self.color_type = </span><span class="s5">4 </span><span class="s1">* self.alpha + </span><span class="s5">2 </span><span class="s1">* (</span><span class="s4">not </span><span class="s1">greyscale) + </span><span class="s5">1 </span><span class="s1">* self.colormap</span>
        <span class="s4">assert </span><span class="s1">self.color_type </span><span class="s4">in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">6</span><span class="s1">)</span>

        <span class="s1">self.color_planes = (</span><span class="s5">3</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)[self.greyscale </span><span class="s4">or </span><span class="s1">self.colormap]</span>
        <span class="s1">self.planes = self.color_planes + self.alpha</span>
        <span class="s0"># :todo: fix for bitdepth &lt; 8</span>
        <span class="s1">self.psize = (self.bitdepth / </span><span class="s5">8</span><span class="s1">) * self.planes</span>

    <span class="s4">def </span><span class="s1">make_palette(self):</span>
        <span class="s2">&quot;&quot;&quot;Create the byte sequences for a ``PLTE`` and if necessary a 
        ``tRNS`` chunk.  Returned as a pair (*p*, *t*).  *t* will be 
        ``None`` if no ``tRNS`` chunk is necessary. 
        &quot;&quot;&quot;</span>

        <span class="s1">p = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s1">t = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>

        <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">self.palette:</span>
            <span class="s1">p.extend(x[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">])</span>
            <span class="s4">if </span><span class="s1">len(x) &gt; </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">t.append(x[</span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">p = tostring(p)</span>
        <span class="s1">t = tostring(t)</span>
        <span class="s4">if </span><span class="s1">t:</span>
            <span class="s4">return </span><span class="s1">p</span><span class="s4">, </span><span class="s1">t</span>
        <span class="s4">return </span><span class="s1">p</span><span class="s4">, None</span>

    <span class="s4">def </span><span class="s1">write(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">rows):</span>
        <span class="s2">&quot;&quot;&quot;Write a PNG image to the output file.  `rows` should be 
        an iterable that yields each row in boxed row flat pixel format. 
        The rows should be the rows of the original image, so there 
        should be ``self.height`` rows of ``self.width * self.planes`` values. 
        If `interlace` is specified (when creating the instance), then 
        an interlaced PNG file will be written.  Supply the rows in the 
        normal image order; the interlacing is carried out internally. 
 
        .. note :: 
 
          Interlacing will require the entire image to be in working memory. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.interlace:</span>
            <span class="s1">fmt = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
            <span class="s1">a = array(fmt</span><span class="s4">, </span><span class="s1">itertools.chain(*rows))</span>
            <span class="s4">return </span><span class="s1">self.write_array(outfile</span><span class="s4">, </span><span class="s1">a)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">nrows = self.write_passes(outfile</span><span class="s4">, </span><span class="s1">rows)</span>
            <span class="s4">if </span><span class="s1">nrows != self.height:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;rows supplied (%d) does not match height (%d)&quot;</span>
                    <span class="s1">% (nrows</span><span class="s4">, </span><span class="s1">self.height)</span>
                <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">write_passes(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">packed=</span><span class="s4">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write a PNG image to the output file. 
 
        Most users are expected to find the :meth:`write` or 
        :meth:`write_array` method more convenient. 
 
        The rows should be given to this method in the order that 
        they appear in the output file.  For straightlaced images, 
        this is the usual top to bottom ordering, but for interlaced 
        images the rows should have already been interlaced before 
        passing them to this function. 
 
        `rows` should be an iterable that yields each row.  When 
        `packed` is ``False`` the rows should be in boxed row flat pixel 
        format; when `packed` is ``True`` each row should be a packed 
        sequence of bytes. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#5PNG-file-signature</span>
        <span class="s1">outfile.write(_signature)</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11IHDR</span>
        <span class="s1">write_chunk(</span>
            <span class="s1">outfile</span><span class="s4">,</span>
            <span class="s3">&quot;IHDR&quot;</span><span class="s4">,</span>
            <span class="s1">struct.pack(</span>
                <span class="s3">&quot;!2I5B&quot;</span><span class="s4">,</span>
                <span class="s1">self.width</span><span class="s4">,</span>
                <span class="s1">self.height</span><span class="s4">,</span>
                <span class="s1">self.bitdepth</span><span class="s4">,</span>
                <span class="s1">self.color_type</span><span class="s4">,</span>
                <span class="s5">0</span><span class="s4">,</span>
                <span class="s5">0</span><span class="s4">,</span>
                <span class="s1">self.interlace</span><span class="s4">,</span>
            <span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s0"># See :chunk:order</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11gAMA</span>
        <span class="s4">if </span><span class="s1">self.gamma </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">write_chunk(</span>
                <span class="s1">outfile</span><span class="s4">, </span><span class="s3">&quot;gAMA&quot;</span><span class="s4">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;!L&quot;</span><span class="s4">, </span><span class="s1">int(round(self.gamma * </span><span class="s5">1e5</span><span class="s1">)))</span>
            <span class="s1">)</span>

        <span class="s0"># See :chunk:order</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11sBIT</span>
        <span class="s4">if </span><span class="s1">self.rescale:</span>
            <span class="s1">write_chunk(</span>
                <span class="s1">outfile</span><span class="s4">,</span>
                <span class="s3">&quot;sBIT&quot;</span><span class="s4">,</span>
                <span class="s1">struct.pack(</span><span class="s3">&quot;%dB&quot; </span><span class="s1">% self.planes</span><span class="s4">, </span><span class="s1">*[self.rescale[</span><span class="s5">0</span><span class="s1">]] * self.planes)</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s0"># :chunk:order: Without a palette (PLTE chunk), ordering is</span>
        <span class="s0"># relatively relaxed.  With one, gAMA chunk must precede PLTE</span>
        <span class="s0"># chunk which must precede tRNS and bKGD.</span>
        <span class="s0"># See http://www.w3.org/TR/PNG/#5ChunkOrdering</span>
        <span class="s4">if </span><span class="s1">self.palette:</span>
            <span class="s1">p</span><span class="s4">, </span><span class="s1">t = self.make_palette()</span>
            <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;PLTE&quot;</span><span class="s4">, </span><span class="s1">p)</span>
            <span class="s4">if </span><span class="s1">t:</span>
                <span class="s0"># tRNS chunk is optional.  Only needed if palette entries</span>
                <span class="s0"># have alpha.</span>
                <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;tRNS&quot;</span><span class="s4">, </span><span class="s1">t)</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11tRNS</span>
        <span class="s4">if </span><span class="s1">self.transparent </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.greyscale:</span>
                <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;tRNS&quot;</span><span class="s4">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;!1H&quot;</span><span class="s4">, </span><span class="s1">*self.transparent))</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;tRNS&quot;</span><span class="s4">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;!3H&quot;</span><span class="s4">, </span><span class="s1">*self.transparent))</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11bKGD</span>
        <span class="s4">if </span><span class="s1">self.background </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">self.greyscale:</span>
                <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;bKGD&quot;</span><span class="s4">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;!1H&quot;</span><span class="s4">, </span><span class="s1">*self.background))</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;bKGD&quot;</span><span class="s4">, </span><span class="s1">struct.pack(</span><span class="s3">&quot;!3H&quot;</span><span class="s4">, </span><span class="s1">*self.background))</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#11IDAT</span>
        <span class="s4">if </span><span class="s1">self.compression </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">compressor = zlib.compressobj(self.compression)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">compressor = zlib.compressobj()</span>

        <span class="s0"># Choose an extend function based on the bitdepth.  The extend</span>
        <span class="s0"># function packs/decomposes the pixel values into bytes and</span>
        <span class="s0"># stuffs them onto the data array.</span>
        <span class="s1">data = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.bitdepth == </span><span class="s5">8 </span><span class="s4">or </span><span class="s1">packed:</span>
            <span class="s1">extend = data.extend</span>
        <span class="s4">elif </span><span class="s1">self.bitdepth == </span><span class="s5">16</span><span class="s1">:</span>
            <span class="s0"># Decompose into bytes</span>
            <span class="s4">def </span><span class="s1">extend(sl):</span>
                <span class="s1">fmt = </span><span class="s3">f&quot;!</span><span class="s4">{</span><span class="s1">len(sl)</span><span class="s4">}</span><span class="s3">H&quot;</span>
                <span class="s1">data.extend(array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">struct.pack(fmt</span><span class="s4">, </span><span class="s1">*sl)))</span>

        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># Pack into bytes</span>
            <span class="s4">assert </span><span class="s1">self.bitdepth &lt; </span><span class="s5">8</span>
            <span class="s0"># samples per byte</span>
            <span class="s1">spb = int(</span><span class="s5">8 </span><span class="s1">/ self.bitdepth)</span>

            <span class="s4">def </span><span class="s1">extend(sl):</span>
                <span class="s1">a = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">sl)</span>
                <span class="s0"># Adding padding bytes so we can group into a whole</span>
                <span class="s0"># number of spb-tuples.</span>
                <span class="s1">l = float(len(a))</span>
                <span class="s1">extra = math.ceil(l / float(spb)) * spb - l</span>
                <span class="s1">a.extend([</span><span class="s5">0</span><span class="s1">] * int(extra))</span>
                <span class="s0"># Pack into bytes</span>
                <span class="s1">l = group(a</span><span class="s4">, </span><span class="s1">spb)</span>
                <span class="s1">l = map(</span><span class="s4">lambda </span><span class="s1">e: reduce(</span><span class="s4">lambda </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y: (x &lt;&lt; self.bitdepth) + y</span><span class="s4">, </span><span class="s1">e)</span><span class="s4">, </span><span class="s1">l)</span>
                <span class="s1">data.extend(l)</span>

        <span class="s4">if </span><span class="s1">self.rescale:</span>
            <span class="s1">oldextend = extend</span>
            <span class="s1">factor = float(</span><span class="s5">2 </span><span class="s1">** self.rescale[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) / float(</span><span class="s5">2 </span><span class="s1">** self.rescale[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s4">def </span><span class="s1">extend(sl):</span>
                <span class="s1">oldextend(map(</span><span class="s4">lambda </span><span class="s1">x: int(round(factor * x))</span><span class="s4">, </span><span class="s1">sl))</span>

        <span class="s0"># Build the first row, testing mostly to see if we need to</span>
        <span class="s0"># changed the extend function to cope with NumPy integer types</span>
        <span class="s0"># (they cause our ordinary definition of extend to fail, so we</span>
        <span class="s0"># wrap it).  See</span>
        <span class="s0"># http://code.google.com/p/pypng/issues/detail?id=44</span>
        <span class="s1">enumrows = enumerate(rows)</span>
        <span class="s4">del </span><span class="s1">rows</span>

        <span class="s0"># First row's filter type.</span>
        <span class="s1">data.append(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0"># :todo: Certain exceptions in the call to ``.next()`` or the</span>
        <span class="s0"># following try would indicate no row data supplied.</span>
        <span class="s0"># Should catch.</span>
        <span class="s1">i</span><span class="s4">, </span><span class="s1">row = next(enumrows)</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s0"># If this fails...</span>
            <span class="s1">extend(row)</span>
        <span class="s4">except</span><span class="s1">:</span>
            <span class="s0"># ... try a version that converts the values to int first.</span>
            <span class="s0"># Not only does this work for the (slightly broken) NumPy</span>
            <span class="s0"># types, there are probably lots of other, unknown, &quot;nearly&quot;</span>
            <span class="s0"># int types it works for.</span>
            <span class="s4">def </span><span class="s1">wrapmapint(f):</span>
                <span class="s4">return lambda </span><span class="s1">sl: f(map(int</span><span class="s4">, </span><span class="s1">sl))</span>

            <span class="s1">extend = wrapmapint(extend)</span>
            <span class="s4">del </span><span class="s1">wrapmapint</span>
            <span class="s1">extend(row)</span>

        <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">row </span><span class="s4">in </span><span class="s1">enumrows:</span>
            <span class="s0"># Add &quot;None&quot; filter type.  Currently, it's essential that</span>
            <span class="s0"># this filter type be used for every scanline as we do not</span>
            <span class="s0"># mark the first row of a reduced pass image; that means we</span>
            <span class="s0"># could accidentally compute the wrong filtered scanline if</span>
            <span class="s0"># we used &quot;up&quot;, &quot;average&quot;, or &quot;paeth&quot; on such a line.</span>
            <span class="s1">data.append(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">extend(row)</span>
            <span class="s4">if </span><span class="s1">len(data) &gt; self.chunk_limit:</span>
                <span class="s1">compressed = compressor.compress(tostring(data))</span>
                <span class="s4">if </span><span class="s1">len(compressed):</span>
                    <span class="s0"># print(len(data), len(compressed), file= &gt;&gt; sys.stderr)</span>
                    <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;IDAT&quot;</span><span class="s4">, </span><span class="s1">compressed)</span>
                <span class="s0"># Because of our very witty definition of ``extend``,</span>
                <span class="s0"># above, we must re-use the same ``data`` object.  Hence</span>
                <span class="s0"># we use ``del`` to empty this one, rather than create a</span>
                <span class="s0"># fresh one (which would be my natural FP instinct).</span>
                <span class="s4">del </span><span class="s1">data[:]</span>
        <span class="s4">if </span><span class="s1">len(data):</span>
            <span class="s1">compressed = compressor.compress(tostring(data))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">compressed = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">flushed = compressor.flush()</span>
        <span class="s4">if </span><span class="s1">len(compressed) </span><span class="s4">or </span><span class="s1">len(flushed):</span>
            <span class="s0"># print(len(data), len(compressed), len(flushed), file=sys.stderr)</span>
            <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;IDAT&quot;</span><span class="s4">, </span><span class="s1">compressed + flushed)</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#11IEND</span>
        <span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s3">&quot;IEND&quot;</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">i + </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">write_array(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">pixels):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write an array in flat row flat pixel format as a PNG file on 
        the output file.  See also :meth:`write` method. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.interlace:</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.array_scanlines_interlace(pixels))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.array_scanlines(pixels))</span>

    <span class="s4">def </span><span class="s1">write_packed(self</span><span class="s4">, </span><span class="s1">outfile</span><span class="s4">, </span><span class="s1">rows):</span>
        <span class="s2">&quot;&quot;&quot; 
        Write PNG file to `outfile`.  The pixel data comes from `rows` 
        which should be in boxed row packed format.  Each row should be 
        a sequence of packed bytes. 
 
        Technically, this method does work for interlaced images but it 
        is best avoided.  For interlaced images, the rows should be 
        presented in the order that they appear in the file. 
 
        This method should not be used when the source image bit depth 
        is not one naturally supported by PNG; the bit depth should be 
        1, 2, 4, 8, or 16. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.rescale:</span>
            <span class="s4">raise </span><span class="s1">Error(</span>
                <span class="s3">&quot;write_packed method not suitable for bit depth %d&quot; </span><span class="s1">% self.rescale[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s4">return </span><span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">packed=</span><span class="s4">True</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">convert_pnm(self</span><span class="s4">, </span><span class="s1">infile</span><span class="s4">, </span><span class="s1">outfile):</span>
        <span class="s2">&quot;&quot;&quot; 
        Convert a PNM file containing raw pixel data into a PNG file 
        with the parameters set in the writer object.  Works for 
        (binary) PGM, PPM, and PAM formats. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.interlace:</span>
            <span class="s1">pixels = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
            <span class="s1">pixels.fromfile(</span>
                <span class="s1">infile</span><span class="s4">,</span>
                <span class="s1">(self.bitdepth / </span><span class="s5">8</span><span class="s1">) * self.color_planes * self.width * self.height</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.array_scanlines_interlace(pixels))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.file_scanlines(infile))</span>

    <span class="s4">def </span><span class="s1">convert_ppm_and_pgm(self</span><span class="s4">, </span><span class="s1">ppmfile</span><span class="s4">, </span><span class="s1">pgmfile</span><span class="s4">, </span><span class="s1">outfile):</span>
        <span class="s2">&quot;&quot;&quot; 
        Convert a PPM and PGM file containing raw pixel data into a 
        PNG outfile with the parameters set in the writer object. 
        &quot;&quot;&quot;</span>
        <span class="s1">pixels = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s1">pixels.fromfile(</span>
            <span class="s1">ppmfile</span><span class="s4">, </span><span class="s1">(self.bitdepth / </span><span class="s5">8</span><span class="s1">) * self.color_planes * self.width * self.height</span>
        <span class="s1">)</span>
        <span class="s1">apixels = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s1">apixels.fromfile(pgmfile</span><span class="s4">, </span><span class="s1">(self.bitdepth / </span><span class="s5">8</span><span class="s1">) * self.width * self.height)</span>
        <span class="s1">pixels = interleave_planes(</span>
            <span class="s1">pixels</span><span class="s4">,</span>
            <span class="s1">apixels</span><span class="s4">,</span>
            <span class="s1">(self.bitdepth / </span><span class="s5">8</span><span class="s1">) * self.color_planes</span><span class="s4">,</span>
            <span class="s1">(self.bitdepth / </span><span class="s5">8</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.interlace:</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.array_scanlines_interlace(pixels))</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">self.write_passes(outfile</span><span class="s4">, </span><span class="s1">self.array_scanlines(pixels))</span>

    <span class="s4">def </span><span class="s1">file_scanlines(self</span><span class="s4">, </span><span class="s1">infile):</span>
        <span class="s2">&quot;&quot;&quot; 
        Generates boxed rows in flat pixel format, from the input file 
        `infile`.  It assumes that the input file is in a &quot;Netpbm-like&quot; 
        binary format, and is positioned at the beginning of the first 
        pixel.  The number of pixels to read is taken from the image 
        dimensions (`width`, `height`, `planes`) and the number of bytes 
        per value is implied by the image `bitdepth`. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Values per row</span>
        <span class="s1">vpr = self.width * self.planes</span>
        <span class="s1">row_bytes = vpr</span>
        <span class="s4">if </span><span class="s1">self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s4">assert </span><span class="s1">self.bitdepth == </span><span class="s5">16</span>
            <span class="s1">row_bytes *= </span><span class="s5">2</span>
            <span class="s1">fmt = </span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% vpr</span>

            <span class="s4">def </span><span class="s1">line():</span>
                <span class="s4">return </span><span class="s1">array(</span><span class="s3">&quot;H&quot;</span><span class="s4">, </span><span class="s1">struct.unpack(fmt</span><span class="s4">, </span><span class="s1">infile.read(row_bytes)))</span>

        <span class="s4">else</span><span class="s1">:</span>

            <span class="s4">def </span><span class="s1">line():</span>
                <span class="s1">scanline = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">infile.read(row_bytes))</span>
                <span class="s4">return </span><span class="s1">scanline</span>

        <span class="s4">for </span><span class="s1">y </span><span class="s4">in </span><span class="s1">range(self.height):</span>
            <span class="s4">yield </span><span class="s1">line()</span>

    <span class="s4">def </span><span class="s1">array_scanlines(self</span><span class="s4">, </span><span class="s1">pixels):</span>
        <span class="s2">&quot;&quot;&quot; 
        Generates boxed rows (flat pixels) from flat rows (flat pixels) 
        in an array. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Values per row</span>
        <span class="s1">vpr = self.width * self.planes</span>
        <span class="s1">stop = </span><span class="s5">0</span>
        <span class="s4">for </span><span class="s1">y </span><span class="s4">in </span><span class="s1">range(self.height):</span>
            <span class="s1">start = stop</span>
            <span class="s1">stop = start + vpr</span>
            <span class="s4">yield </span><span class="s1">pixels[start:stop]</span>

    <span class="s4">def </span><span class="s1">array_scanlines_interlace(self</span><span class="s4">, </span><span class="s1">pixels):</span>
        <span class="s2">&quot;&quot;&quot; 
        Generator for interlaced scanlines from an array.  `pixels` is 
        the full source image in flat row flat pixel format.  The 
        generator yields each scanline of the reduced passes in turn, in 
        boxed row flat pixel format. 
        &quot;&quot;&quot;</span>

        <span class="s0"># http://www.w3.org/TR/PNG/#8InterlaceMethods</span>
        <span class="s0"># Array type.</span>
        <span class="s1">fmt = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s0"># Value per row</span>
        <span class="s1">vpr = self.width * self.planes</span>
        <span class="s4">for </span><span class="s1">xstart</span><span class="s4">, </span><span class="s1">ystart</span><span class="s4">, </span><span class="s1">xstep</span><span class="s4">, </span><span class="s1">ystep </span><span class="s4">in </span><span class="s1">_adam7:</span>
            <span class="s4">if </span><span class="s1">xstart &gt;= self.width:</span>
                <span class="s4">continue</span>
            <span class="s0"># Pixels per row (of reduced image)</span>
            <span class="s1">ppr = int(math.ceil((self.width - xstart) / float(xstep)))</span>
            <span class="s0"># number of values in reduced image row.</span>
            <span class="s1">row_len = ppr * self.planes</span>
            <span class="s4">for </span><span class="s1">y </span><span class="s4">in </span><span class="s1">range(ystart</span><span class="s4">, </span><span class="s1">self.height</span><span class="s4">, </span><span class="s1">ystep):</span>
                <span class="s4">if </span><span class="s1">xstep == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">offset = y * vpr</span>
                    <span class="s4">yield </span><span class="s1">pixels[offset : offset + vpr]</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">row = array(fmt)</span>
                    <span class="s0"># There's no easier way to set the length of an array</span>
                    <span class="s1">row.extend(pixels[</span><span class="s5">0</span><span class="s1">:row_len])</span>
                    <span class="s1">offset = y * vpr + xstart * self.planes</span>
                    <span class="s1">end_offset = (y + </span><span class="s5">1</span><span class="s1">) * vpr</span>
                    <span class="s1">skip = self.planes * xstep</span>
                    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self.planes):</span>
                        <span class="s1">row[i :: self.planes] = pixels[offset + i : end_offset : skip]</span>
                    <span class="s4">yield </span><span class="s1">row</span>


<span class="s4">def </span><span class="s1">write_chunk(outfile</span><span class="s4">, </span><span class="s1">tag</span><span class="s4">, </span><span class="s1">data=strtobytes(</span><span class="s3">&quot;&quot;</span><span class="s1">)):</span>
    <span class="s2">&quot;&quot;&quot; 
    Write a PNG chunk to the output file, including length and 
    checksum. 
    &quot;&quot;&quot;</span>

    <span class="s0"># http://www.w3.org/TR/PNG/#5Chunk-layout</span>
    <span class="s1">outfile.write(struct.pack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">len(data)))</span>
    <span class="s1">tag = strtobytes(tag)</span>
    <span class="s1">outfile.write(tag)</span>
    <span class="s1">outfile.write(data)</span>
    <span class="s1">checksum = zlib.crc32(tag)</span>
    <span class="s1">checksum = zlib.crc32(data</span><span class="s4">, </span><span class="s1">checksum)</span>
    <span class="s1">checksum &amp;= </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32 </span><span class="s1">- </span><span class="s5">1</span>
    <span class="s1">outfile.write(struct.pack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">checksum))</span>


<span class="s4">def </span><span class="s1">write_chunks(out</span><span class="s4">, </span><span class="s1">chunks):</span>
    <span class="s2">&quot;&quot;&quot;Create a PNG file by writing out the chunks.&quot;&quot;&quot;</span>

    <span class="s1">out.write(_signature)</span>
    <span class="s4">for </span><span class="s1">chunk </span><span class="s4">in </span><span class="s1">chunks:</span>
        <span class="s1">write_chunk(out</span><span class="s4">, </span><span class="s1">*chunk)</span>


<span class="s4">def </span><span class="s1">filter_scanline(type</span><span class="s4">, </span><span class="s1">line</span><span class="s4">, </span><span class="s1">fo</span><span class="s4">, </span><span class="s1">prev=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Apply a scanline filter to a scanline.  `type` specifies the 
    filter type (0 to 4); `line` specifies the current (unfiltered) 
    scanline as a sequence of bytes; `prev` specifies the previous 
    (unfiltered) scanline as a sequence of bytes. `fo` specifies the 
    filter offset; normally this is size of a pixel in bytes (the number 
    of bytes per sample times the number of channels), but when this is 
    &lt; 1 (for bit depths &lt; 8) then the filter offset is 1. 
    &quot;&quot;&quot;</span>

    <span class="s4">assert </span><span class="s5">0 </span><span class="s1">&lt;= type &lt; </span><span class="s5">5</span>

    <span class="s0"># The output array.  Which, pathetically, we extend one-byte at a</span>
    <span class="s0"># time (fortunately this is linear).</span>
    <span class="s1">out = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">[type])</span>

    <span class="s4">def </span><span class="s1">sub():</span>
        <span class="s1">ai = -fo</span>
        <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">line:</span>
            <span class="s4">if </span><span class="s1">ai &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">x = (x - line[ai]) &amp; </span><span class="s5">0xFF</span>
            <span class="s1">out.append(x)</span>
            <span class="s1">ai += </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">up():</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">x </span><span class="s4">in </span><span class="s1">enumerate(line):</span>
            <span class="s1">x = (x - prev[i]) &amp; </span><span class="s5">0xFF</span>
            <span class="s1">out.append(x)</span>

    <span class="s4">def </span><span class="s1">average():</span>
        <span class="s1">ai = -fo</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">x </span><span class="s4">in </span><span class="s1">enumerate(line):</span>
            <span class="s4">if </span><span class="s1">ai &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">x = (x - ((line[ai] + prev[i]) &gt;&gt; </span><span class="s5">1</span><span class="s1">)) &amp; </span><span class="s5">0xFF</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">x = (x - (prev[i] &gt;&gt; </span><span class="s5">1</span><span class="s1">)) &amp; </span><span class="s5">0xFF</span>
            <span class="s1">out.append(x)</span>
            <span class="s1">ai += </span><span class="s5">1</span>

    <span class="s4">def </span><span class="s1">paeth():</span>
        <span class="s0"># http://www.w3.org/TR/PNG/#9Filter-type-4-Paeth</span>
        <span class="s1">ai = -fo  </span><span class="s0"># also used for ci</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">x </span><span class="s4">in </span><span class="s1">enumerate(line):</span>
            <span class="s1">a = </span><span class="s5">0</span>
            <span class="s1">b = prev[i]</span>
            <span class="s1">c = </span><span class="s5">0</span>

            <span class="s4">if </span><span class="s1">ai &gt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">a = line[ai]</span>
                <span class="s1">c = prev[ai]</span>
            <span class="s1">p = a + b - c</span>
            <span class="s1">pa = abs(p - a)</span>
            <span class="s1">pb = abs(p - b)</span>
            <span class="s1">pc = abs(p - c)</span>
            <span class="s4">if </span><span class="s1">pa &lt;= pb </span><span class="s4">and </span><span class="s1">pa &lt;= pc:</span>
                <span class="s1">Pr = a</span>
            <span class="s4">elif </span><span class="s1">pb &lt;= pc:</span>
                <span class="s1">Pr = b</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">Pr = c</span>

            <span class="s1">x = (x - Pr) &amp; </span><span class="s5">0xFF</span>
            <span class="s1">out.append(x)</span>
            <span class="s1">ai += </span><span class="s5">1</span>

    <span class="s4">if not </span><span class="s1">prev:</span>
        <span class="s0"># We're on the first line.  Some of the filters can be reduced</span>
        <span class="s0"># to simpler cases which makes handling the line &quot;off the top&quot;</span>
        <span class="s0"># of the image simpler.  &quot;up&quot; becomes &quot;none&quot;; &quot;paeth&quot; becomes</span>
        <span class="s0"># &quot;left&quot; (non-trivial, but true). &quot;average&quot; needs to be handled</span>
        <span class="s0"># specially.</span>
        <span class="s4">if </span><span class="s1">type == </span><span class="s5">2</span><span class="s1">:  </span><span class="s0"># &quot;up&quot;</span>
            <span class="s4">return </span><span class="s1">line  </span><span class="s0"># type = 0</span>
        <span class="s4">elif </span><span class="s1">type == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">prev = [</span><span class="s5">0</span><span class="s1">] * len(line)</span>
        <span class="s4">elif </span><span class="s1">type == </span><span class="s5">4</span><span class="s1">:  </span><span class="s0"># &quot;paeth&quot;</span>
            <span class="s1">type = </span><span class="s5">1</span>
    <span class="s4">if </span><span class="s1">type == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">out.extend(line)</span>
    <span class="s4">elif </span><span class="s1">type == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">sub()</span>
    <span class="s4">elif </span><span class="s1">type == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">up()</span>
    <span class="s4">elif </span><span class="s1">type == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s1">average()</span>
    <span class="s4">else</span><span class="s1">:  </span><span class="s0"># type == 4</span>
        <span class="s1">paeth()</span>
    <span class="s4">return </span><span class="s1">out</span>


<span class="s4">def </span><span class="s1">from_array(a</span><span class="s4">, </span><span class="s1">mode=</span><span class="s4">None, </span><span class="s1">info={}):</span>
    <span class="s2">&quot;&quot;&quot;Create a PNG :class:`Image` object from a 2- or 3-dimensional array. 
    One application of this function is easy PIL-style saving: 
    ``png.from_array(pixels, 'L').save('foo.png')``. 
 
    .. note : 
 
      The use of the term *3-dimensional* is for marketing purposes 
      only.  It doesn't actually work.  Please bear with us.  Meanwhile 
      enjoy the complimentary snacks (on request) and please use a 
      2-dimensional array. 
 
    Unless they are specified using the *info* parameter, the PNG's 
    height and width are taken from the array size.  For a 3 dimensional 
    array the first axis is the height; the second axis is the width; 
    and the third axis is the channel number.  Thus an RGB image that is 
    16 pixels high and 8 wide will use an array that is 16x8x3.  For 2 
    dimensional arrays the first axis is the height, but the second axis 
    is ``width*channels``, so an RGB image that is 16 pixels high and 8 
    wide will use a 2-dimensional array that is 16x24 (each row will be 
    8*3==24 sample values). 
 
    *mode* is a string that specifies the image colour format in a 
    PIL-style mode.  It can be: 
 
    ``'L'`` 
      greyscale (1 channel) 
    ``'LA'`` 
      greyscale with alpha (2 channel) 
    ``'RGB'`` 
      colour image (3 channel) 
    ``'RGBA'`` 
      colour image with alpha (4 channel) 
 
    The mode string can also specify the bit depth (overriding how this 
    function normally derives the bit depth, see below).  Appending 
    ``';16'`` to the mode will cause the PNG to be 16 bits per channel; 
    any decimal from 1 to 16 can be used to specify the bit depth. 
 
    When a 2-dimensional array is used *mode* determines how many 
    channels the image has, and so allows the width to be derived from 
    the second array dimension. 
 
    The array is expected to be a ``numpy`` array, but it can be any 
    suitable Python sequence.  For example, a list of lists can be used: 
    ``png.from_array([[0, 255, 0], [255, 0, 255]], 'L')``.  The exact 
    rules are: ``len(a)`` gives the first dimension, height; 
    ``len(a[0])`` gives the second dimension; ``len(a[0][0])`` gives the 
    third dimension, unless an exception is raised in which case a 
    2-dimensional array is assumed.  It's slightly more complicated than 
    that because an iterator of rows can be used, and it all still 
    works.  Using an iterator allows data to be streamed efficiently. 
 
    The bit depth of the PNG is normally taken from the array element's 
    datatype (but if *mode* specifies a bitdepth then that is used 
    instead).  The array element's datatype is determined in a way which 
    is supposed to work both for ``numpy`` arrays and for Python 
    ``array.array`` objects.  A 1 byte datatype will give a bit depth of 
    8, a 2 byte datatype will give a bit depth of 16.  If the datatype 
    does not have an implicit size, for example it is a plain Python 
    list of lists, as above, then a default of 8 is used. 
 
    The *info* parameter is a dictionary that can be used to specify 
    metadata (in the same style as the arguments to the 
    :class:``png.Writer`` class).  For this function the keys that are 
    useful are: 
 
    height 
      overrides the height derived from the array dimensions and allows 
      *a* to be an iterable. 
    width 
      overrides the width derived from the array dimensions. 
    bitdepth 
      overrides the bit depth derived from the element datatype (but 
      must match *mode* if that also specifies a bit depth). 
 
    Generally anything specified in the 
    *info* dictionary will override any implicit choices that this 
    function would otherwise make, but must match any explicit ones. 
    For example, if the *info* dictionary has a ``greyscale`` key then 
    this must be true when mode is ``'L'`` or ``'LA'`` and false when 
    mode is ``'RGB'`` or ``'RGBA'``. 
    &quot;&quot;&quot;</span>

    <span class="s0"># We abuse the *info* parameter by modifying it.  Take a copy here.</span>
    <span class="s0"># (Also typechecks *info* to some extent).</span>
    <span class="s1">info = dict(info)</span>

    <span class="s0"># Syntax check mode string.</span>
    <span class="s1">bitdepth = </span><span class="s4">None</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">mode = mode.split(</span><span class="s3">&quot;;&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">len(mode) </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">Error()</span>
        <span class="s4">if </span><span class="s1">mode[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">not in </span><span class="s1">(</span><span class="s3">&quot;L&quot;</span><span class="s4">, </span><span class="s3">&quot;LA&quot;</span><span class="s4">, </span><span class="s3">&quot;RGB&quot;</span><span class="s4">, </span><span class="s3">&quot;RGBA&quot;</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">Error()</span>
        <span class="s4">if </span><span class="s1">len(mode) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">bitdepth = int(mode[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s4">except</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">Error()</span>
    <span class="s4">except </span><span class="s1">Error:</span>
        <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;mode string should be 'RGB' or 'L;16' or similar.&quot;</span><span class="s1">)</span>
    <span class="s1">mode = mode[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s0"># Get bitdepth from *mode* if possible.</span>
    <span class="s4">if </span><span class="s1">bitdepth:</span>
        <span class="s4">if </span><span class="s1">info.get(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">bitdepth != info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]:</span>
            <span class="s4">raise </span><span class="s1">Error(</span>
                <span class="s3">&quot;mode bitdepth (%d) should match info bitdepth (%d).&quot;</span>
                <span class="s1">% (bitdepth</span><span class="s4">, </span><span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">])</span>
            <span class="s1">)</span>
        <span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = bitdepth</span>

    <span class="s0"># Fill in and/or check entries in *info*.</span>
    <span class="s0"># Dimensions.</span>
    <span class="s4">if </span><span class="s3">&quot;size&quot; </span><span class="s4">in </span><span class="s1">info:</span>
        <span class="s0"># Check width, height, size all match where used.</span>
        <span class="s4">for </span><span class="s1">dimension</span><span class="s4">, </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">[(</span><span class="s3">&quot;width&quot;</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;height&quot;</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)]:</span>
            <span class="s4">if </span><span class="s1">dimension </span><span class="s4">in </span><span class="s1">info:</span>
                <span class="s4">if </span><span class="s1">info[dimension] != info[</span><span class="s3">&quot;size&quot;</span><span class="s1">][axis]:</span>
                    <span class="s4">raise </span><span class="s1">Error(</span>
                        <span class="s3">f&quot;info[</span><span class="s4">{</span><span class="s1">dimension</span><span class="s4">!r}</span><span class="s3">] should match info['size'][</span><span class="s4">{</span><span class="s1">axis</span><span class="s4">!r}</span><span class="s3">].&quot;</span>
                    <span class="s1">)</span>
        <span class="s1">info[</span><span class="s3">&quot;width&quot;</span><span class="s1">]</span><span class="s4">, </span><span class="s1">info[</span><span class="s3">&quot;height&quot;</span><span class="s1">] = info[</span><span class="s3">&quot;size&quot;</span><span class="s1">]</span>
    <span class="s4">if </span><span class="s3">&quot;height&quot; </span><span class="s4">not in </span><span class="s1">info:</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">l = len(a)</span>
        <span class="s4">except</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;len(a) does not work, supply info['height'] instead.&quot;</span><span class="s1">)</span>
        <span class="s1">info[</span><span class="s3">&quot;height&quot;</span><span class="s1">] = l</span>
    <span class="s0"># Colour format.</span>
    <span class="s4">if </span><span class="s3">&quot;greyscale&quot; </span><span class="s4">in </span><span class="s1">info:</span>
        <span class="s4">if </span><span class="s1">bool(info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]) != (</span><span class="s3">&quot;L&quot; </span><span class="s4">in </span><span class="s1">mode):</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;info['greyscale'] should match mode.&quot;</span><span class="s1">)</span>
    <span class="s1">info[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">] = </span><span class="s3">&quot;L&quot; </span><span class="s4">in </span><span class="s1">mode</span>
    <span class="s4">if </span><span class="s3">&quot;alpha&quot; </span><span class="s4">in </span><span class="s1">info:</span>
        <span class="s4">if </span><span class="s1">bool(info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">]) != (</span><span class="s3">&quot;A&quot; </span><span class="s4">in </span><span class="s1">mode):</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;info['alpha'] should match mode.&quot;</span><span class="s1">)</span>
    <span class="s1">info[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = </span><span class="s3">&quot;A&quot; </span><span class="s4">in </span><span class="s1">mode</span>

    <span class="s1">planes = len(mode)</span>
    <span class="s4">if </span><span class="s3">&quot;planes&quot; </span><span class="s4">in </span><span class="s1">info:</span>
        <span class="s4">if </span><span class="s1">info[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] != planes:</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;info['planes'] should match mode.&quot;</span><span class="s1">)</span>

    <span class="s0"># In order to work out whether we the array is 2D or 3D we need its</span>
    <span class="s0"># first row, which requires that we take a copy of its iterator.</span>
    <span class="s0"># We may also need the first row to derive width and bitdepth.</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">t = itertools.tee(a)</span>
    <span class="s1">row = next(t)</span>
    <span class="s4">del </span><span class="s1">t</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">row[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">threed = </span><span class="s4">True</span>
        <span class="s1">testelement = row[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s4">except</span><span class="s1">:</span>
        <span class="s1">threed = </span><span class="s4">False</span>
        <span class="s1">testelement = row</span>
    <span class="s4">if </span><span class="s3">&quot;width&quot; </span><span class="s4">not in </span><span class="s1">info:</span>
        <span class="s4">if </span><span class="s1">threed:</span>
            <span class="s1">width = len(row)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">width = len(row) // planes</span>
        <span class="s1">info[</span><span class="s3">&quot;width&quot;</span><span class="s1">] = width</span>

    <span class="s0"># Not implemented yet</span>
    <span class="s4">assert not </span><span class="s1">threed</span>

    <span class="s4">if </span><span class="s3">&quot;bitdepth&quot; </span><span class="s4">not in </span><span class="s1">info:</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">dtype = testelement.dtype</span>
            <span class="s0"># goto the &quot;else:&quot; clause.  Sorry.</span>
        <span class="s4">except</span><span class="s1">:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s0"># Try a Python array.array.</span>
                <span class="s1">bitdepth = </span><span class="s5">8 </span><span class="s1">* testelement.itemsize</span>
            <span class="s4">except</span><span class="s1">:</span>
                <span class="s0"># We can't determine it from the array element's</span>
                <span class="s0"># datatype, use a default of 8.</span>
                <span class="s1">bitdepth = </span><span class="s5">8</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># If we got here without exception, we now assume that</span>
            <span class="s0"># the array is a numpy array.</span>
            <span class="s4">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;b&quot;</span><span class="s1">:</span>
                <span class="s1">bitdepth = </span><span class="s5">1</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">bitdepth = </span><span class="s5">8 </span><span class="s1">* dtype.itemsize</span>
        <span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = bitdepth</span>

    <span class="s4">for </span><span class="s1">thing </span><span class="s4">in </span><span class="s3">&quot;width height bitdepth greyscale alpha&quot;</span><span class="s1">.split():</span>
        <span class="s4">assert </span><span class="s1">thing </span><span class="s4">in </span><span class="s1">info</span>
    <span class="s4">return </span><span class="s1">Image(a</span><span class="s4">, </span><span class="s1">info)</span>


<span class="s0"># So that refugee's from PIL feel more at home.  Not documented.</span>
<span class="s1">fromarray = from_array</span>


<span class="s4">class </span><span class="s1">Image:</span>
    <span class="s2">&quot;&quot;&quot;A PNG image. 
    You can create an :class:`Image` object from an array of pixels by calling 
    :meth:`png.from_array`.  It can be saved to disk with the 
    :meth:`save` method.&quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">info):</span>
        <span class="s2">&quot;&quot;&quot; 
        .. note :: 
 
          The constructor is not public.  Please do not call it. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.rows = rows</span>
        <span class="s1">self.info = info</span>

    <span class="s4">def </span><span class="s1">save(self</span><span class="s4">, </span><span class="s1">file):</span>
        <span class="s2">&quot;&quot;&quot;Save the image to *file*.  If *file* looks like an open file 
        descriptor then it is used, otherwise it is treated as a 
        filename and a fresh file is opened. 
 
        In general, you can only call this method once; after it has 
        been called the first time and the PNG image has been saved, the 
        source data will have been streamed, and cannot be streamed 
        again. 
        &quot;&quot;&quot;</span>

        <span class="s1">w = Writer(**self.info)</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">file.write</span>

            <span class="s4">def </span><span class="s1">close():</span>
                <span class="s4">pass</span>

        <span class="s4">except</span><span class="s1">:</span>
            <span class="s1">file = open(file</span><span class="s4">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>

            <span class="s4">def </span><span class="s1">close():</span>
                <span class="s1">file.close()</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">w.write(file</span><span class="s4">, </span><span class="s1">self.rows)</span>
        <span class="s4">finally</span><span class="s1">:</span>
            <span class="s1">close()</span>


<span class="s4">class </span><span class="s1">_readable:</span>
    <span class="s2">&quot;&quot;&quot; 
    A simple file-like interface for strings and arrays. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">buf):</span>
        <span class="s1">self.buf = buf</span>
        <span class="s1">self.offset = </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">read(self</span><span class="s4">, </span><span class="s1">n):</span>
        <span class="s1">r = self.buf[self.offset : self.offset + n]</span>
        <span class="s4">if </span><span class="s1">isarray(r):</span>
            <span class="s1">r = tostring(r)</span>
        <span class="s1">self.offset += n</span>
        <span class="s4">return </span><span class="s1">r</span>


<span class="s4">class </span><span class="s1">Reader:</span>
    <span class="s2">&quot;&quot;&quot; 
    PNG decoder in pure Python. 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">_guess=</span><span class="s4">None, </span><span class="s1">**kw):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a PNG decoder object. 
 
        The constructor expects exactly one keyword argument. If you 
        supply a positional argument instead, it will guess the input 
        type. You can choose among the following keyword arguments: 
 
        filename 
          Name of input file (a PNG file). 
        file 
          A file-like object (object with a read() method). 
        bytes 
          ``array`` or ``string`` with PNG data. 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">(_guess </span><span class="s4">is not None and </span><span class="s1">len(kw) != </span><span class="s5">0</span><span class="s1">) </span><span class="s4">or </span><span class="s1">(_guess </span><span class="s4">is None and </span><span class="s1">len(kw) != </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Reader() takes exactly 1 argument&quot;</span><span class="s1">)</span>

        <span class="s0"># Will be the first 8 bytes, later on.  See validate_signature.</span>
        <span class="s1">self.signature = </span><span class="s4">None</span>
        <span class="s1">self.transparent = </span><span class="s4">None</span>
        <span class="s0"># A pair of (len,type) if a chunk has been read but its data and</span>
        <span class="s0"># checksum have not (in other words the file position is just</span>
        <span class="s0"># past the 4 bytes that specify the chunk type).  See preamble</span>
        <span class="s0"># method for how this is used.</span>
        <span class="s1">self.atchunk = </span><span class="s4">None</span>

        <span class="s4">if </span><span class="s1">_guess </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s4">if </span><span class="s1">isarray(_guess):</span>
                <span class="s1">kw[</span><span class="s3">&quot;bytes&quot;</span><span class="s1">] = _guess</span>
            <span class="s4">elif </span><span class="s1">isinstance(_guess</span><span class="s4">, </span><span class="s1">str):</span>
                <span class="s1">kw[</span><span class="s3">&quot;filename&quot;</span><span class="s1">] = _guess</span>
            <span class="s4">elif </span><span class="s1">isinstance(_guess</span><span class="s4">, </span><span class="s1">io.IOBase):</span>
                <span class="s1">kw[</span><span class="s3">&quot;file&quot;</span><span class="s1">] = _guess</span>

        <span class="s4">if </span><span class="s3">&quot;filename&quot; </span><span class="s4">in </span><span class="s1">kw:</span>
            <span class="s1">self.file = open(kw[</span><span class="s3">&quot;filename&quot;</span><span class="s1">]</span><span class="s4">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s3">&quot;file&quot; </span><span class="s4">in </span><span class="s1">kw:</span>
            <span class="s1">self.file = kw[</span><span class="s3">&quot;file&quot;</span><span class="s1">]</span>
        <span class="s4">elif </span><span class="s3">&quot;bytes&quot; </span><span class="s4">in </span><span class="s1">kw:</span>
            <span class="s1">self.file = _readable(kw[</span><span class="s3">&quot;bytes&quot;</span><span class="s1">])</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;expecting filename, file or bytes array&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">chunk(self</span><span class="s4">, </span><span class="s1">seek=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read the next PNG chunk from the input file; returns a 
        (*type*,*data*) tuple.  *type* is the chunk's type as a string 
        (all PNG chunk types are 4 characters long).  *data* is the 
        chunk's data content, as a string. 
 
        If the optional `seek` argument is 
        specified then it will keep reading chunks until it either runs 
        out of file or finds the type specified by the argument.  Note 
        that in general the order of chunks in PNGs is unspecified, so 
        using `seek` can cause you to miss chunks. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.validate_signature()</span>

        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s0"># http://www.w3.org/TR/PNG/#5Chunk-layout</span>
            <span class="s4">if not </span><span class="s1">self.atchunk:</span>
                <span class="s1">self.atchunk = self.chunklentype()</span>
            <span class="s1">length</span><span class="s4">, </span><span class="s1">type = self.atchunk</span>
            <span class="s1">self.atchunk = </span><span class="s4">None</span>
            <span class="s1">data = self.file.read(length)</span>
            <span class="s4">if </span><span class="s1">len(data) != length:</span>
                <span class="s4">raise </span><span class="s1">ChunkError(</span>
                    <span class="s3">&quot;Chunk %s too short for required %i octets.&quot; </span><span class="s1">% (type</span><span class="s4">, </span><span class="s1">length)</span>
                <span class="s1">)</span>
            <span class="s1">checksum = self.file.read(</span><span class="s5">4</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">len(checksum) != </span><span class="s5">4</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Chunk %s too short for checksum.&quot;</span><span class="s4">, </span><span class="s1">checksum)</span>
            <span class="s4">if </span><span class="s1">seek </span><span class="s4">and </span><span class="s1">type != seek:</span>
                <span class="s4">continue</span>
            <span class="s1">verify = zlib.crc32(strtobytes(type))</span>
            <span class="s1">verify = zlib.crc32(data</span><span class="s4">, </span><span class="s1">verify)</span>
            <span class="s0"># Whether the output from zlib.crc32 is signed or not varies</span>
            <span class="s0"># according to hideous implementation details, see</span>
            <span class="s0"># http://bugs.python.org/issue1202 .</span>
            <span class="s0"># We coerce it to be positive here (in a way which works on</span>
            <span class="s0"># Python 2.3 and older).</span>
            <span class="s1">verify &amp;= </span><span class="s5">2</span><span class="s1">**</span><span class="s5">32 </span><span class="s1">- </span><span class="s5">1</span>
            <span class="s1">verify = struct.pack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">verify)</span>
            <span class="s4">if </span><span class="s1">checksum != verify:</span>
                <span class="s0"># print(repr(checksum))</span>
                <span class="s1">(a</span><span class="s4">,</span><span class="s1">) = struct.unpack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">checksum)</span>
                <span class="s1">(b</span><span class="s4">,</span><span class="s1">) = struct.unpack(</span><span class="s3">&quot;!I&quot;</span><span class="s4">, </span><span class="s1">verify)</span>
                <span class="s4">raise </span><span class="s1">ChunkError(</span>
                    <span class="s3">f&quot;Checksum error in </span><span class="s4">{</span><span class="s1">type</span><span class="s4">} </span><span class="s3">chunk: 0x</span><span class="s4">{</span><span class="s1">a</span><span class="s4">:</span><span class="s3">08X</span><span class="s4">} </span><span class="s3">!= 0x</span><span class="s4">{</span><span class="s1">b</span><span class="s4">:</span><span class="s3">08X</span><span class="s4">}</span><span class="s3">.&quot;</span>
                <span class="s1">)</span>
            <span class="s4">return </span><span class="s1">type</span><span class="s4">, </span><span class="s1">data</span>

    <span class="s4">def </span><span class="s1">chunks(self):</span>
        <span class="s2">&quot;&quot;&quot;Return an iterator that will yield each chunk as a 
        (*chunktype*, *content*) pair. 
        &quot;&quot;&quot;</span>

        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s1">t</span><span class="s4">, </span><span class="s1">v = self.chunk()</span>
            <span class="s4">yield </span><span class="s1">t</span><span class="s4">, </span><span class="s1">v</span>
            <span class="s4">if </span><span class="s1">t == </span><span class="s3">&quot;IEND&quot;</span><span class="s1">:</span>
                <span class="s4">break</span>

    <span class="s4">def </span><span class="s1">undo_filter(self</span><span class="s4">, </span><span class="s1">filter_type</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">previous):</span>
        <span class="s2">&quot;&quot;&quot;Undo the filter for a scanline.  `scanline` is a sequence of 
        bytes that does not include the initial filter type byte. 
        `previous` is decoded previous scanline (for straightlaced 
        images this is the previous pixel row, but for interlaced 
        images, it is the previous scanline in the reduced image, which 
        in general is not the previous pixel row in the final image). 
        When there is no previous scanline (the first row of a 
        straightlaced image, or the first row in one of the passes in an 
        interlaced image), then this argument should be ``None``. 
 
        The scanline will have the effects of filtering removed, and the 
        result will be returned as a fresh sequence of bytes. 
        &quot;&quot;&quot;</span>

        <span class="s0"># :todo: Would it be better to update scanline in place?</span>

        <span class="s0"># Create the result byte array.  It seems that the best way to</span>
        <span class="s0"># create the array to be the right size is to copy from an</span>
        <span class="s0"># existing sequence.  *sigh*</span>
        <span class="s0"># If we fill the result with scanline, then this allows a</span>
        <span class="s0"># micro-optimisation in the &quot;null&quot; and &quot;sub&quot; cases.</span>
        <span class="s1">result = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">scanline)</span>

        <span class="s4">if </span><span class="s1">filter_type == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># And here, we _rely_ on filling the result with scanline,</span>
            <span class="s0"># above.</span>
            <span class="s4">return </span><span class="s1">result</span>

        <span class="s4">if </span><span class="s1">filter_type </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span>
                <span class="s3">&quot;Invalid PNG Filter Type.&quot;</span>
                <span class="s3">&quot;  See http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># Filter unit.  The stride from one pixel to the corresponding</span>
        <span class="s0"># byte from the previous previous.  Normally this is the pixel</span>
        <span class="s0"># size in bytes, but when this is smaller than 1, the previous</span>
        <span class="s0"># byte is used instead.</span>
        <span class="s1">fu = max(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">self.psize)</span>

        <span class="s0"># For the first line of a pass, synthesize a dummy previous</span>
        <span class="s0"># line.  An alternative approach would be to observe that on the</span>
        <span class="s0"># first line 'up' is the same as 'null', 'paeth' is the same</span>
        <span class="s0"># as 'sub', with only 'average' requiring any special case.</span>
        <span class="s4">if not </span><span class="s1">previous:</span>
            <span class="s1">previous = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">] * len(scanline))</span>

        <span class="s4">def </span><span class="s1">sub():</span>
            <span class="s2">&quot;&quot;&quot;Undo sub filter.&quot;&quot;&quot;</span>

            <span class="s1">ai = </span><span class="s5">0</span>
            <span class="s0"># Loops starts at index fu.  Observe that the initial part</span>
            <span class="s0"># of the result is already filled in correctly with</span>
            <span class="s0"># scanline.</span>
            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(fu</span><span class="s4">, </span><span class="s1">len(result)):</span>
                <span class="s1">x = scanline[i]</span>
                <span class="s1">a = result[ai]</span>
                <span class="s1">result[i] = (x + a) &amp; </span><span class="s5">0xFF</span>
                <span class="s1">ai += </span><span class="s5">1</span>

        <span class="s4">def </span><span class="s1">up():</span>
            <span class="s2">&quot;&quot;&quot;Undo up filter.&quot;&quot;&quot;</span>
            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(result)):  </span><span class="s0"># pylint: disable=consider-using-enumerate</span>
                <span class="s1">x = scanline[i]</span>
                <span class="s1">b = previous[i]</span>
                <span class="s1">result[i] = (x + b) &amp; </span><span class="s5">0xFF</span>

        <span class="s4">def </span><span class="s1">average():</span>
            <span class="s2">&quot;&quot;&quot;Undo average filter.&quot;&quot;&quot;</span>

            <span class="s1">ai = -fu</span>
            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(result)):  </span><span class="s0"># pylint: disable=consider-using-enumerate</span>
                <span class="s1">x = scanline[i]</span>
                <span class="s4">if </span><span class="s1">ai &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">a = </span><span class="s5">0</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">a = result[ai]</span>
                <span class="s1">b = previous[i]</span>
                <span class="s1">result[i] = (x + ((a + b) &gt;&gt; </span><span class="s5">1</span><span class="s1">)) &amp; </span><span class="s5">0xFF</span>
                <span class="s1">ai += </span><span class="s5">1</span>

        <span class="s4">def </span><span class="s1">paeth():</span>
            <span class="s2">&quot;&quot;&quot;Undo Paeth filter.&quot;&quot;&quot;</span>

            <span class="s0"># Also used for ci.</span>
            <span class="s1">ai = -fu</span>
            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(result)):  </span><span class="s0"># pylint: disable=consider-using-enumerate</span>
                <span class="s1">x = scanline[i]</span>
                <span class="s4">if </span><span class="s1">ai &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">a = c = </span><span class="s5">0</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">a = result[ai]</span>
                    <span class="s1">c = previous[ai]</span>
                <span class="s1">b = previous[i]</span>
                <span class="s1">p = a + b - c</span>
                <span class="s1">pa = abs(p - a)</span>
                <span class="s1">pb = abs(p - b)</span>
                <span class="s1">pc = abs(p - c)</span>
                <span class="s4">if </span><span class="s1">pa &lt;= pb </span><span class="s4">and </span><span class="s1">pa &lt;= pc:</span>
                    <span class="s1">pr = a</span>
                <span class="s4">elif </span><span class="s1">pb &lt;= pc:</span>
                    <span class="s1">pr = b</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">pr = c</span>
                <span class="s1">result[i] = (x + pr) &amp; </span><span class="s5">0xFF</span>
                <span class="s1">ai += </span><span class="s5">1</span>

        <span class="s0"># Call appropriate filter algorithm.  Note that 0 has already</span>
        <span class="s0"># been dealt with.</span>
        <span class="s1">(</span><span class="s4">None, </span><span class="s1">sub</span><span class="s4">, </span><span class="s1">up</span><span class="s4">, </span><span class="s1">average</span><span class="s4">, </span><span class="s1">paeth)[filter_type]()</span>
        <span class="s4">return </span><span class="s1">result</span>

    <span class="s4">def </span><span class="s1">deinterlace(self</span><span class="s4">, </span><span class="s1">raw):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read raw pixel data, undo filters, deinterlace, and flatten. 
        Return in flat row flat pixel format. 
        &quot;&quot;&quot;</span>

        <span class="s0"># print(&quot;Reading interlaced, w=%s, r=%s, planes=%s, bpp=%s&quot;</span>
        <span class="s0"># % (self.width, self.height, self.planes, self.bps, file=sys.stderr))</span>
        <span class="s0"># Values per row (of the target image)</span>
        <span class="s1">vpr = self.width * self.planes</span>

        <span class="s0"># Make a result array, and make it big enough.  Interleaving</span>
        <span class="s0"># writes to the output array randomly (well, not quite), so the</span>
        <span class="s0"># entire output array must be in memory.</span>
        <span class="s1">fmt = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s1">a = array(fmt</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">] * vpr * self.height)</span>
        <span class="s1">source_offset = </span><span class="s5">0</span>

        <span class="s4">for </span><span class="s1">xstart</span><span class="s4">, </span><span class="s1">ystart</span><span class="s4">, </span><span class="s1">xstep</span><span class="s4">, </span><span class="s1">ystep </span><span class="s4">in </span><span class="s1">_adam7:</span>
            <span class="s0"># print(&quot;Adam7: start=%s,%s step=%s,%s&quot; % (</span>
            <span class="s0">#     xstart, ystart, xstep, ystep, file=sys.stderr))</span>
            <span class="s4">if </span><span class="s1">xstart &gt;= self.width:</span>
                <span class="s4">continue</span>
            <span class="s0"># The previous (reconstructed) scanline.  None at the</span>
            <span class="s0"># beginning of a pass to indicate that there is no previous</span>
            <span class="s0"># line.</span>
            <span class="s1">recon = </span><span class="s4">None</span>
            <span class="s0"># Pixels per row (reduced pass image)</span>
            <span class="s1">ppr = int(math.ceil((self.width - xstart) / float(xstep)))</span>
            <span class="s0"># Row size in bytes for this pass.</span>
            <span class="s1">row_size = int(math.ceil(self.psize * ppr))</span>
            <span class="s4">for </span><span class="s1">y </span><span class="s4">in </span><span class="s1">range(ystart</span><span class="s4">, </span><span class="s1">self.height</span><span class="s4">, </span><span class="s1">ystep):</span>
                <span class="s1">filter_type = raw[source_offset]</span>
                <span class="s1">source_offset += </span><span class="s5">1</span>
                <span class="s1">scanline = raw[source_offset : source_offset + row_size]</span>
                <span class="s1">source_offset += row_size</span>
                <span class="s1">recon = self.undo_filter(filter_type</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">recon)</span>
                <span class="s0"># Convert so that there is one element per pixel value</span>
                <span class="s1">flat = self.serialtoflat(recon</span><span class="s4">, </span><span class="s1">ppr)</span>
                <span class="s4">if </span><span class="s1">xstep == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4">assert </span><span class="s1">xstart == </span><span class="s5">0</span>
                    <span class="s1">offset = y * vpr</span>
                    <span class="s1">a[offset : offset + vpr] = flat</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">offset = y * vpr + xstart * self.planes</span>
                    <span class="s1">end_offset = (y + </span><span class="s5">1</span><span class="s1">) * vpr</span>
                    <span class="s1">skip = self.planes * xstep</span>
                    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(self.planes):</span>
                        <span class="s1">a[offset + i : end_offset : skip] = flat[i :: self.planes]</span>
        <span class="s4">return </span><span class="s1">a</span>

    <span class="s4">def </span><span class="s1">iterboxed(self</span><span class="s4">, </span><span class="s1">rows):</span>
        <span class="s2">&quot;&quot;&quot;Iterator that yields each scanline in boxed row flat pixel 
        format.  `rows` should be an iterator that yields the bytes of 
        each row in turn. 
        &quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">asvalues(raw):</span>
            <span class="s2">&quot;&quot;&quot;Convert a row of raw bytes into a flat row.  Result may 
            or may not share with argument&quot;&quot;&quot;</span>

            <span class="s4">if </span><span class="s1">self.bitdepth == </span><span class="s5">8</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">raw</span>
            <span class="s4">if </span><span class="s1">self.bitdepth == </span><span class="s5">16</span><span class="s1">:</span>
                <span class="s1">raw = tostring(raw)</span>
                <span class="s4">return </span><span class="s1">array(</span><span class="s3">&quot;H&quot;</span><span class="s4">, </span><span class="s1">struct.unpack(</span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% (len(raw) // </span><span class="s5">2</span><span class="s1">)</span><span class="s4">, </span><span class="s1">raw))</span>
            <span class="s4">assert </span><span class="s1">self.bitdepth &lt; </span><span class="s5">8</span>
            <span class="s1">width = self.width</span>
            <span class="s0"># Samples per byte</span>
            <span class="s1">spb = </span><span class="s5">8 </span><span class="s1">// self.bitdepth</span>
            <span class="s1">out = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
            <span class="s1">mask = </span><span class="s5">2</span><span class="s1">**self.bitdepth - </span><span class="s5">1</span>
            <span class="s1">shifts = map(self.bitdepth.__mul__</span><span class="s4">, </span><span class="s1">reversed(range(spb)))</span>
            <span class="s4">for </span><span class="s1">o </span><span class="s4">in </span><span class="s1">raw:</span>
                <span class="s1">out.extend(map(</span><span class="s4">lambda </span><span class="s1">i: mask &amp; (o &gt;&gt; i)</span><span class="s4">, </span><span class="s1">shifts))</span>
            <span class="s4">return </span><span class="s1">out[:width]</span>

        <span class="s4">return </span><span class="s1">map(asvalues</span><span class="s4">, </span><span class="s1">rows)</span>

    <span class="s4">def </span><span class="s1">serialtoflat(self</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">, </span><span class="s1">width=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Convert serial format (byte stream) pixel data to flat row 
        flat pixel. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.bitdepth == </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s4">return </span><span class="s1">bytes</span>
        <span class="s4">if </span><span class="s1">self.bitdepth == </span><span class="s5">16</span><span class="s1">:</span>
            <span class="s1">bytes = tostring(bytes)</span>
            <span class="s4">return </span><span class="s1">array(</span><span class="s3">&quot;H&quot;</span><span class="s4">, </span><span class="s1">struct.unpack(</span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% (len(bytes) // </span><span class="s5">2</span><span class="s1">)</span><span class="s4">, </span><span class="s1">bytes))</span>
        <span class="s4">assert </span><span class="s1">self.bitdepth &lt; </span><span class="s5">8</span>
        <span class="s4">if </span><span class="s1">width </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s1">width = self.width</span>
        <span class="s0"># Samples per byte</span>
        <span class="s1">spb = </span><span class="s5">8 </span><span class="s1">// self.bitdepth</span>
        <span class="s1">out = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s1">mask = </span><span class="s5">2</span><span class="s1">**self.bitdepth - </span><span class="s5">1</span>
        <span class="s1">shifts = map(self.bitdepth.__mul__</span><span class="s4">, </span><span class="s1">reversed(range(spb)))</span>
        <span class="s1">l = width</span>
        <span class="s4">for </span><span class="s1">o </span><span class="s4">in </span><span class="s1">bytes:</span>
            <span class="s1">out.extend([(mask &amp; (o &gt;&gt; s)) </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">shifts][:l])</span>
            <span class="s1">l -= spb</span>
            <span class="s4">if </span><span class="s1">l &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">l = width</span>
        <span class="s4">return </span><span class="s1">out</span>

    <span class="s4">def </span><span class="s1">iterstraight(self</span><span class="s4">, </span><span class="s1">raw):</span>
        <span class="s2">&quot;&quot;&quot;Iterator that undoes the effect of filtering, and yields each 
        row in serialised format (as a sequence of bytes).  Assumes input 
        is straightlaced.  `raw` should be an iterable that yields the 
        raw bytes in chunks of arbitrary size.&quot;&quot;&quot;</span>

        <span class="s0"># length of row, in bytes</span>
        <span class="s1">rb = self.row_bytes</span>
        <span class="s1">a = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s0"># The previous (reconstructed) scanline.  None indicates first</span>
        <span class="s0"># line of image.</span>
        <span class="s1">recon = </span><span class="s4">None</span>
        <span class="s4">for </span><span class="s1">some </span><span class="s4">in </span><span class="s1">raw:</span>
            <span class="s1">a.extend(some)</span>
            <span class="s4">while </span><span class="s1">len(a) &gt;= rb + </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">filter_type = a[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">scanline = a[</span><span class="s5">1 </span><span class="s1">: rb + </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s4">del </span><span class="s1">a[: rb + </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">recon = self.undo_filter(filter_type</span><span class="s4">, </span><span class="s1">scanline</span><span class="s4">, </span><span class="s1">recon)</span>
                <span class="s4">yield </span><span class="s1">recon</span>
        <span class="s4">if </span><span class="s1">len(a) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0"># :file:format We get here with a file format error: when the</span>
            <span class="s0"># available bytes (after decompressing) do not pack into exact</span>
            <span class="s0"># rows.</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Wrong size for decompressed IDAT chunk.&quot;</span><span class="s1">)</span>
        <span class="s4">assert </span><span class="s1">len(a) == </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">validate_signature(self):</span>
        <span class="s2">&quot;&quot;&quot;If signature (header) has not been read then read and 
        validate it; otherwise do nothing. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">self.signature:</span>
            <span class="s4">return</span>
        <span class="s1">self.signature = self.file.read(</span><span class="s5">8</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.signature != _signature:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;PNG file has invalid signature.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">preamble(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Extract the image metadata by reading the initial part of the PNG 
        file up to the start of the ``IDAT`` chunk.  All the chunks that 
        precede the ``IDAT`` chunk are read and either processed for 
        metadata or discarded. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.validate_signature()</span>

        <span class="s4">while True</span><span class="s1">:</span>
            <span class="s4">if not </span><span class="s1">self.atchunk:</span>
                <span class="s1">self.atchunk = self.chunklentype()</span>
                <span class="s4">if </span><span class="s1">self.atchunk </span><span class="s4">is None</span><span class="s1">:</span>
                    <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;This PNG file has no IDAT chunks.&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">self.atchunk[</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">&quot;IDAT&quot;</span><span class="s1">:</span>
                <span class="s4">return</span>
            <span class="s1">self.process_chunk()</span>

    <span class="s4">def </span><span class="s1">chunklentype(self):</span>
        <span class="s2">&quot;&quot;&quot;Reads just enough of the input to determine the next 
        chunk's length and type, returned as a (*length*, *type*) pair 
        where *type* is a string.  If there are no more chunks, ``None`` 
        is returned. 
        &quot;&quot;&quot;</span>

        <span class="s1">x = self.file.read(</span><span class="s5">8</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">x:</span>
            <span class="s4">return None</span>
        <span class="s4">if </span><span class="s1">len(x) != </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;End of file whilst reading chunk length and type.&quot;</span><span class="s1">)</span>
        <span class="s1">length</span><span class="s4">, </span><span class="s1">type = struct.unpack(</span><span class="s3">&quot;!I4s&quot;</span><span class="s4">, </span><span class="s1">x)</span>
        <span class="s1">type = bytestostr(type)</span>
        <span class="s4">if </span><span class="s1">length &gt; </span><span class="s5">2</span><span class="s1">**</span><span class="s5">31 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Chunk %s is too large: %d.&quot; </span><span class="s1">% (type</span><span class="s4">, </span><span class="s1">length))</span>
        <span class="s4">return </span><span class="s1">length</span><span class="s4">, </span><span class="s1">type</span>

    <span class="s4">def </span><span class="s1">process_chunk(self):</span>
        <span class="s2">&quot;&quot;&quot;Process the next chunk and its data.  This only processes the 
        following chunk types, all others are ignored: ``IHDR``, 
        ``PLTE``, ``bKGD``, ``tRNS``, ``gAMA``, ``sBIT``. 
        &quot;&quot;&quot;</span>

        <span class="s1">type</span><span class="s4">, </span><span class="s1">data = self.chunk()</span>
        <span class="s4">if </span><span class="s1">type == </span><span class="s3">&quot;IHDR&quot;</span><span class="s1">:</span>
            <span class="s0"># http://www.w3.org/TR/PNG/#11IHDR</span>
            <span class="s4">if </span><span class="s1">len(data) != </span><span class="s5">13</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;IHDR chunk has incorrect length.&quot;</span><span class="s1">)</span>
            <span class="s1">(</span>
                <span class="s1">self.width</span><span class="s4">,</span>
                <span class="s1">self.height</span><span class="s4">,</span>
                <span class="s1">self.bitdepth</span><span class="s4">,</span>
                <span class="s1">self.color_type</span><span class="s4">,</span>
                <span class="s1">self.compression</span><span class="s4">,</span>
                <span class="s1">self.filter</span><span class="s4">,</span>
                <span class="s1">self.interlace</span><span class="s4">,</span>
            <span class="s1">) = struct.unpack(</span><span class="s3">&quot;!2I5B&quot;</span><span class="s4">, </span><span class="s1">data)</span>

            <span class="s0"># Check that the header specifies only valid combinations.</span>
            <span class="s4">if </span><span class="s1">self.bitdepth </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s5">16</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;invalid bit depth %d&quot; </span><span class="s1">% self.bitdepth)</span>
            <span class="s4">if </span><span class="s1">self.color_type </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">6</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;invalid colour type %d&quot; </span><span class="s1">% self.color_type)</span>
            <span class="s0"># Check indexed (palettized) images have 8 or fewer bits</span>
            <span class="s0"># per pixel; check only indexed or greyscale images have</span>
            <span class="s0"># fewer than 8 bits per pixel.</span>
            <span class="s4">if </span><span class="s1">(self.color_type &amp; </span><span class="s5">1 </span><span class="s4">and </span><span class="s1">self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">) </span><span class="s4">or </span><span class="s1">(</span>
                <span class="s1">self.bitdepth &lt; </span><span class="s5">8 </span><span class="s4">and </span><span class="s1">self.color_type </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span>
                    <span class="s3">&quot;Illegal combination of bit depth (%d)&quot;</span>
                    <span class="s3">&quot; and colour type (%d).&quot;</span>
                    <span class="s3">&quot; See http://www.w3.org/TR/2003/REC-PNG-20031110/#table111 .&quot;</span>
                    <span class="s1">% (self.bitdepth</span><span class="s4">, </span><span class="s1">self.color_type)</span>
                <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">self.compression != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;unknown compression method %d&quot; </span><span class="s1">% self.compression)</span>
            <span class="s4">if </span><span class="s1">self.filter != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span>
                    <span class="s3">&quot;Unknown filter method %d,&quot;</span>
                    <span class="s3">&quot; see http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .&quot;</span>
                    <span class="s1">% self.filter</span>
                <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">self.interlace </span><span class="s4">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span>
                    <span class="s3">&quot;Unknown interlace method %d,&quot;</span>
                    <span class="s3">&quot; see http://www.w3.org/TR/2003/REC-PNG-20031110/#8InterlaceMethods .&quot;</span>
                    <span class="s1">% self.interlace</span>
                <span class="s1">)</span>

            <span class="s0"># Derived values</span>
            <span class="s0"># http://www.w3.org/TR/PNG/#6Colour-values</span>
            <span class="s1">colormap = bool(self.color_type &amp; </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">greyscale = </span><span class="s4">not </span><span class="s1">(self.color_type &amp; </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">alpha = bool(self.color_type &amp; </span><span class="s5">4</span><span class="s1">)</span>
            <span class="s1">color_planes = (</span><span class="s5">3</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)[greyscale </span><span class="s4">or </span><span class="s1">colormap]</span>
            <span class="s1">planes = color_planes + alpha</span>

            <span class="s1">self.colormap = colormap</span>
            <span class="s1">self.greyscale = greyscale</span>
            <span class="s1">self.alpha = alpha</span>
            <span class="s1">self.color_planes = color_planes</span>
            <span class="s1">self.planes = planes</span>
            <span class="s1">self.psize = float(self.bitdepth) / float(</span><span class="s5">8</span><span class="s1">) * planes</span>
            <span class="s4">if </span><span class="s1">int(self.psize) == self.psize:</span>
                <span class="s1">self.psize = int(self.psize)</span>
            <span class="s1">self.row_bytes = int(math.ceil(self.width * self.psize))</span>
            <span class="s0"># Stores PLTE chunk if present, and is used to check</span>
            <span class="s0"># chunk ordering constraints.</span>
            <span class="s1">self.plte = </span><span class="s4">None</span>
            <span class="s0"># Stores tRNS chunk if present, and is used to check chunk</span>
            <span class="s0"># ordering constraints.</span>
            <span class="s1">self.trns = </span><span class="s4">None</span>
            <span class="s0"># Stores sbit chunk if present.</span>
            <span class="s1">self.sbit = </span><span class="s4">None</span>
        <span class="s4">elif </span><span class="s1">type == </span><span class="s3">&quot;PLTE&quot;</span><span class="s1">:</span>
            <span class="s0"># http://www.w3.org/TR/PNG/#11PLTE</span>
            <span class="s4">if </span><span class="s1">self.plte:</span>
                <span class="s1">warnings.warn(</span><span class="s3">&quot;Multiple PLTE chunks present.&quot;</span><span class="s1">)</span>
            <span class="s1">self.plte = data</span>
            <span class="s4">if </span><span class="s1">len(data) % </span><span class="s5">3 </span><span class="s1">!= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;PLTE chunk's length should be a multiple of 3.&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">len(data) &gt; (</span><span class="s5">2</span><span class="s1">**self.bitdepth) * </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;PLTE chunk is too long.&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">len(data) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Empty PLTE is not allowed.&quot;</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">type == </span><span class="s3">&quot;bKGD&quot;</span><span class="s1">:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">self.colormap:</span>
                    <span class="s4">if not </span><span class="s1">self.plte:</span>
                        <span class="s1">warnings.warn(</span><span class="s3">&quot;PLTE chunk is required before bKGD chunk.&quot;</span><span class="s1">)</span>
                    <span class="s1">self.background = struct.unpack(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">data)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s1">self.background = struct.unpack(</span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% self.color_planes</span><span class="s4">, </span><span class="s1">data)</span>
            <span class="s4">except </span><span class="s1">struct.error:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;bKGD chunk has incorrect length.&quot;</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">type == </span><span class="s3">&quot;tRNS&quot;</span><span class="s1">:</span>
            <span class="s0"># http://www.w3.org/TR/PNG/#11tRNS</span>
            <span class="s1">self.trns = data</span>
            <span class="s4">if </span><span class="s1">self.colormap:</span>
                <span class="s4">if not </span><span class="s1">self.plte:</span>
                    <span class="s1">warnings.warn(</span><span class="s3">&quot;PLTE chunk is required before tRNS chunk.&quot;</span><span class="s1">)</span>
                <span class="s4">else</span><span class="s1">:</span>
                    <span class="s4">if </span><span class="s1">len(data) &gt; len(self.plte) / </span><span class="s5">3</span><span class="s1">:</span>
                        <span class="s0"># Was warning, but promoted to Error as it</span>
                        <span class="s0"># would otherwise cause pain later on.</span>
                        <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;tRNS chunk is too long.&quot;</span><span class="s1">)</span>
            <span class="s4">else</span><span class="s1">:</span>
                <span class="s4">if </span><span class="s1">self.alpha:</span>
                    <span class="s4">raise </span><span class="s1">FormatError(</span>
                        <span class="s3">&quot;tRNS chunk is not valid with colour type %d.&quot; </span><span class="s1">% self.color_type</span>
                    <span class="s1">)</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">self.transparent = struct.unpack(</span><span class="s3">&quot;!%dH&quot; </span><span class="s1">% self.color_planes</span><span class="s4">, </span><span class="s1">data)</span>
                <span class="s4">except </span><span class="s1">struct.error:</span>
                    <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;tRNS chunk has incorrect length.&quot;</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">type == </span><span class="s3">&quot;gAMA&quot;</span><span class="s1">:</span>
            <span class="s4">try</span><span class="s1">:</span>
                <span class="s1">self.gamma = struct.unpack(</span><span class="s3">&quot;!L&quot;</span><span class="s4">, </span><span class="s1">data)[</span><span class="s5">0</span><span class="s1">] / </span><span class="s5">100000.0</span>
            <span class="s4">except </span><span class="s1">struct.error:</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;gAMA chunk has incorrect length.&quot;</span><span class="s1">)</span>
        <span class="s4">elif </span><span class="s1">type == </span><span class="s3">&quot;sBIT&quot;</span><span class="s1">:</span>
            <span class="s1">self.sbit = data</span>
            <span class="s4">if </span><span class="s1">(</span>
                <span class="s1">self.colormap</span>
                <span class="s4">and </span><span class="s1">len(data) != </span><span class="s5">3</span>
                <span class="s4">or not </span><span class="s1">self.colormap</span>
                <span class="s4">and </span><span class="s1">len(data) != self.planes</span>
            <span class="s1">):</span>
                <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;sBIT chunk has incorrect length.&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">read(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read the PNG file and decode it.  Returns (`width`, `height`, 
        `pixels`, `metadata`). 
 
        May use excessive memory. 
 
        `pixels` are returned in boxed row flat pixel format. 
        &quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">iteridat():</span>
            <span class="s2">&quot;&quot;&quot;Iterator that yields all the ``IDAT`` chunks as strings.&quot;&quot;&quot;</span>
            <span class="s4">while True</span><span class="s1">:</span>
                <span class="s4">try</span><span class="s1">:</span>
                    <span class="s1">type</span><span class="s4">, </span><span class="s1">data = self.chunk()</span>
                <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">e:</span>
                    <span class="s4">raise </span><span class="s1">ChunkError(e.args[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s4">if </span><span class="s1">type == </span><span class="s3">&quot;IEND&quot;</span><span class="s1">:</span>
                    <span class="s0"># http://www.w3.org/TR/PNG/#11IEND</span>
                    <span class="s4">break</span>
                <span class="s4">if </span><span class="s1">type != </span><span class="s3">&quot;IDAT&quot;</span><span class="s1">:</span>
                    <span class="s4">continue</span>
                <span class="s0"># type == 'IDAT'</span>
                <span class="s0"># http://www.w3.org/TR/PNG/#11IDAT</span>
                <span class="s4">if </span><span class="s1">self.colormap </span><span class="s4">and not </span><span class="s1">self.plte:</span>
                    <span class="s1">warnings.warn(</span><span class="s3">&quot;PLTE chunk is required before IDAT chunk&quot;</span><span class="s1">)</span>
                <span class="s4">yield </span><span class="s1">data</span>

        <span class="s4">def </span><span class="s1">iterdecomp(idat):</span>
            <span class="s2">&quot;&quot;&quot;Iterator that yields decompressed strings.  `idat` should 
            be an iterator that yields the ``IDAT`` chunk data. 
            &quot;&quot;&quot;</span>

            <span class="s0"># Currently, with no max_length parameter to decompress, this</span>
            <span class="s0"># routine will do one yield per IDAT chunk.  So not very</span>
            <span class="s0"># incremental.</span>
            <span class="s1">d = zlib.decompressobj()</span>
            <span class="s0"># Each IDAT chunk is passed to the decompressor, then any</span>
            <span class="s0"># remaining state is decompressed out.</span>
            <span class="s4">for </span><span class="s1">data </span><span class="s4">in </span><span class="s1">idat:</span>
                <span class="s0"># :todo: add a max_length argument here to limit output</span>
                <span class="s0"># size.</span>
                <span class="s4">yield </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">d.decompress(data))</span>
            <span class="s4">yield </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">d.flush())</span>

        <span class="s1">self.preamble()</span>
        <span class="s1">raw = iterdecomp(iteridat())</span>

        <span class="s4">if </span><span class="s1">self.interlace:</span>
            <span class="s1">raw = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">itertools.chain(*raw))</span>
            <span class="s1">arraycode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[self.bitdepth &gt; </span><span class="s5">8</span><span class="s1">]</span>
            <span class="s0"># Like :meth:`group` but producing an array.array object for</span>
            <span class="s0"># each row.</span>
            <span class="s1">pixels = map(</span>
                <span class="s4">lambda </span><span class="s1">*row: array(arraycode</span><span class="s4">, </span><span class="s1">row)</span><span class="s4">,</span>
                <span class="s1">*[iter(self.deinterlace(raw))] * self.width * self.planes</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">pixels = self.iterboxed(self.iterstraight(raw))</span>
        <span class="s1">meta = dict()</span>
        <span class="s4">for </span><span class="s1">attr </span><span class="s4">in </span><span class="s3">&quot;greyscale alpha planes bitdepth interlace&quot;</span><span class="s1">.split():</span>
            <span class="s1">meta[attr] = getattr(self</span><span class="s4">, </span><span class="s1">attr)</span>
        <span class="s1">meta[</span><span class="s3">&quot;size&quot;</span><span class="s1">] = (self.width</span><span class="s4">, </span><span class="s1">self.height)</span>
        <span class="s4">for </span><span class="s1">attr </span><span class="s4">in </span><span class="s3">&quot;gamma transparent background&quot;</span><span class="s1">.split():</span>
            <span class="s1">a = getattr(self</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, None</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">a </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">meta[attr] = a</span>
        <span class="s4">return </span><span class="s1">self.width</span><span class="s4">, </span><span class="s1">self.height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta</span>

    <span class="s4">def </span><span class="s1">read_flat(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Read a PNG file and decode it into flat row flat pixel format. 
        Returns (*width*, *height*, *pixels*, *metadata*). 
 
        May use excessive memory. 
 
        `pixels` are returned in flat row flat pixel format. 
 
        See also the :meth:`read` method which returns pixels in the 
        more stream-friendly boxed row flat pixel format. 
        &quot;&quot;&quot;</span>

        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixel</span><span class="s4">, </span><span class="s1">meta = self.read()</span>
        <span class="s1">arraycode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s1">pixel = array(arraycode</span><span class="s4">, </span><span class="s1">itertools.chain(*pixel))</span>
        <span class="s4">return </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixel</span><span class="s4">, </span><span class="s1">meta</span>

    <span class="s4">def </span><span class="s1">palette(self</span><span class="s4">, </span><span class="s1">alpha=</span><span class="s3">&quot;natural&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Returns a palette that is a sequence of 3-tuples or 4-tuples, 
        synthesizing it from the ``PLTE`` and ``tRNS`` chunks.  These 
        chunks should have already been processed (for example, by 
        calling the :meth:`preamble` method).  All the tuples are the 
        same size: 3-tuples if there is no ``tRNS`` chunk, 4-tuples when 
        there is a ``tRNS`` chunk.  Assumes that the image is colour type 
        3 and therefore a ``PLTE`` chunk is required. 
 
        If the `alpha` argument is ``'force'`` then an alpha channel is 
        always added, forcing the result to be a sequence of 4-tuples. 
        &quot;&quot;&quot;</span>

        <span class="s4">if not </span><span class="s1">self.plte:</span>
            <span class="s4">raise </span><span class="s1">FormatError(</span><span class="s3">&quot;Required PLTE chunk is missing in colour type 3 image.&quot;</span><span class="s1">)</span>
        <span class="s1">plte = group(array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">self.plte)</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">self.trns </span><span class="s4">or </span><span class="s1">alpha == </span><span class="s3">&quot;force&quot;</span><span class="s1">:</span>
            <span class="s1">trns = array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">self.trns </span><span class="s4">or </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">trns.extend([</span><span class="s5">255</span><span class="s1">] * (len(plte) - len(trns)))</span>
            <span class="s1">plte = map(operator.add</span><span class="s4">, </span><span class="s1">plte</span><span class="s4">, </span><span class="s1">group(trns</span><span class="s4">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s4">return </span><span class="s1">plte</span>

    <span class="s4">def </span><span class="s1">asDirect(self):</span>
        <span class="s2">&quot;&quot;&quot;Returns the image data as a direct representation of an 
        ``x * y * planes`` array.  This method is intended to remove the 
        need for callers to deal with palettes and transparency 
        themselves.  Images with a palette (colour type 3) 
        are converted to RGB or RGBA; images with transparency (a 
        ``tRNS`` chunk) are converted to LA or RGBA as appropriate. 
        When returned in this format the pixel values represent the 
        colour value directly without needing to refer to palettes or 
        transparency information. 
 
        Like the :meth:`read` method this method returns a 4-tuple: 
 
        (*width*, *height*, *pixels*, *meta*) 
 
        This method normally returns pixel values with the bit depth 
        they have in the source image, but when the source PNG has an 
        ``sBIT`` chunk it is inspected and can reduce the bit depth of 
        the result pixels; pixel values will be reduced according to 
        the bit depth specified in the ``sBIT`` chunk (PNG nerds should 
        note a single result bit depth is used for all channels; the 
        maximum of the ones specified in the ``sBIT`` chunk.  An RGB565 
        image will be rescaled to 6-bit RGB666). 
 
        The *meta* dictionary that is returned reflects the `direct` 
        format and not the original source image.  For example, an RGB 
        source image with a ``tRNS`` chunk to represent a transparent 
        colour, will have ``planes=3`` and ``alpha=False`` for the 
        source image, but the *meta* dictionary returned by this method 
        will have ``planes=4`` and ``alpha=True`` because an alpha 
        channel is synthesized and added. 
 
        *pixels* is the pixel data in boxed row flat pixel format (just 
        like the :meth:`read` method). 
 
        All the other aspects of the image data are not changed. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.preamble()</span>

        <span class="s0"># Simple case, no conversion necessary.</span>
        <span class="s4">if not </span><span class="s1">self.colormap </span><span class="s4">and not </span><span class="s1">self.trns </span><span class="s4">and not </span><span class="s1">self.sbit:</span>
            <span class="s4">return </span><span class="s1">self.read()</span>

        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = self.read()</span>

        <span class="s4">if </span><span class="s1">self.colormap:</span>
            <span class="s1">meta[</span><span class="s3">&quot;colormap&quot;</span><span class="s1">] = </span><span class="s4">False</span>
            <span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = bool(self.trns)</span>
            <span class="s1">meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = </span><span class="s5">8</span>
            <span class="s1">meta[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] = </span><span class="s5">3 </span><span class="s1">+ bool(self.trns)</span>
            <span class="s1">plte = list(self.palette())</span>

            <span class="s4">def </span><span class="s1">iterpal(pixels):</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s1">row = map(plte.__getitem__</span><span class="s4">, </span><span class="s1">row)</span>
                    <span class="s4">yield </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">itertools.chain(*row))</span>

            <span class="s1">pixels = iterpal(pixels)</span>
        <span class="s4">elif </span><span class="s1">self.trns:</span>
            <span class="s0"># It would be nice if there was some reasonable way of doing</span>
            <span class="s0"># this without generating a whole load of intermediate tuples.</span>
            <span class="s0"># But tuples does seem like the easiest way, with no other way</span>
            <span class="s0"># clearly much simpler or much faster.  (Actually, the L to LA</span>
            <span class="s0"># conversion could perhaps go faster (all those 1-tuples!), but</span>
            <span class="s0"># I still wonder whether the code proliferation is worth it)</span>
            <span class="s1">it = self.transparent</span>
            <span class="s1">maxval = </span><span class="s5">2 </span><span class="s1">** meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span>
            <span class="s1">planes = meta[</span><span class="s3">&quot;planes&quot;</span><span class="s1">]</span>
            <span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = </span><span class="s4">True</span>
            <span class="s1">meta[</span><span class="s3">&quot;planes&quot;</span><span class="s1">] += </span><span class="s5">1</span>
            <span class="s1">typecode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>

            <span class="s4">def </span><span class="s1">itertrns(pixels):</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s0"># For each row we group it into pixels, then form a</span>
                    <span class="s0"># characterisation vector that says whether each pixel</span>
                    <span class="s0"># is opaque or not.  Then we convert True/False to</span>
                    <span class="s0"># 0/maxval (by multiplication), and add it as the extra</span>
                    <span class="s0"># channel.</span>
                    <span class="s1">row = group(row</span><span class="s4">, </span><span class="s1">planes)</span>
                    <span class="s1">opa = map(it.__ne__</span><span class="s4">, </span><span class="s1">row)</span>
                    <span class="s1">opa = map(maxval.__mul__</span><span class="s4">, </span><span class="s1">opa)</span>
                    <span class="s1">opa = zip(opa)  </span><span class="s0"># convert to 1-tuples</span>
                    <span class="s4">yield </span><span class="s1">array(typecode</span><span class="s4">, </span><span class="s1">itertools.chain(*map(operator.add</span><span class="s4">, </span><span class="s1">row</span><span class="s4">, </span><span class="s1">opa)))</span>

            <span class="s1">pixels = itertrns(pixels)</span>
        <span class="s1">targetbitdepth = </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">self.sbit:</span>
            <span class="s1">sbit = struct.unpack(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">len(self.sbit)</span><span class="s4">}</span><span class="s3">B&quot;</span><span class="s4">, </span><span class="s1">self.sbit)</span>
            <span class="s1">targetbitdepth = max(sbit)</span>
            <span class="s4">if </span><span class="s1">targetbitdepth &gt; meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]:</span>
                <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;sBIT chunk %r exceeds bitdepth %d&quot; </span><span class="s1">% (sbit</span><span class="s4">, </span><span class="s1">self.bitdepth))</span>
            <span class="s4">if </span><span class="s1">min(sbit) &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">f&quot;sBIT chunk </span><span class="s4">{</span><span class="s1">sbit</span><span class="s4">!r} </span><span class="s3">has a 0-entry&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">targetbitdepth == meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]:</span>
                <span class="s1">targetbitdepth = </span><span class="s4">None</span>
        <span class="s4">if </span><span class="s1">targetbitdepth:</span>
            <span class="s1">shift = meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - targetbitdepth</span>
            <span class="s1">meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = targetbitdepth</span>

            <span class="s4">def </span><span class="s1">itershift(pixels):</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s4">yield </span><span class="s1">map(shift.__rrshift__</span><span class="s4">, </span><span class="s1">row)</span>

            <span class="s1">pixels = itershift(pixels)</span>
        <span class="s4">return </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta</span>

    <span class="s4">def </span><span class="s1">asFloat(self</span><span class="s4">, </span><span class="s1">maxval=</span><span class="s5">1.0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Return image pixels as per :meth:`asDirect` method, but scale 
        all pixel values to be floating point values between 0.0 and 
        *maxval*. 
        &quot;&quot;&quot;</span>

        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info = self.asDirect()</span>
        <span class="s1">sourcemaxval = </span><span class="s5">2 </span><span class="s1">** info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span>
        <span class="s4">del </span><span class="s1">info[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]</span>
        <span class="s1">info[</span><span class="s3">&quot;maxval&quot;</span><span class="s1">] = float(maxval)</span>
        <span class="s1">factor = float(maxval) / float(sourcemaxval)</span>

        <span class="s4">def </span><span class="s1">iterfloat():</span>
            <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                <span class="s4">yield </span><span class="s1">map(factor.__mul__</span><span class="s4">, </span><span class="s1">row)</span>

        <span class="s4">return </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">iterfloat()</span><span class="s4">, </span><span class="s1">info</span>

    <span class="s4">def </span><span class="s1">_as_rescale(self</span><span class="s4">, </span><span class="s1">get</span><span class="s4">, </span><span class="s1">targetbitdepth):</span>
        <span class="s2">&quot;&quot;&quot;Helper used by :meth:`asRGB8` and :meth:`asRGBA8`.&quot;&quot;&quot;</span>

        <span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = get()</span>
        <span class="s1">maxval = </span><span class="s5">2 </span><span class="s1">** meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span>
        <span class="s1">targetmaxval = </span><span class="s5">2</span><span class="s1">**targetbitdepth - </span><span class="s5">1</span>
        <span class="s1">factor = float(targetmaxval) / float(maxval)</span>
        <span class="s1">meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = targetbitdepth</span>

        <span class="s4">def </span><span class="s1">iterscale():</span>
            <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                <span class="s4">yield </span><span class="s1">map(</span><span class="s4">lambda </span><span class="s1">x: int(round(x * factor))</span><span class="s4">, </span><span class="s1">row)</span>

        <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">iterscale()</span><span class="s4">, </span><span class="s1">meta</span>

    <span class="s4">def </span><span class="s1">asRGB8(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the image data as an RGB pixels with 8-bits per 
        sample.  This is like the :meth:`asRGB` method except that 
        this method additionally rescales the values so that they 
        are all between 0 and 255 (8-bit).  In the case where the 
        source image has a bit depth &lt; 8 the transformation preserves 
        all the information; where the source image has bit depth 
        &gt; 8, then rescaling to 8-bit values loses precision.  No 
        dithering is performed.  Like :meth:`asRGB`, an alpha channel 
        in the source image will raise an exception. 
 
        This function returns a 4-tuple: 
        (*width*, *height*, *pixels*, *metadata*). 
        *width*, *height*, *metadata* are as per the :meth:`read` method. 
 
        *pixels* is the pixel data in boxed row flat pixel format. 
        &quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self._as_rescale(self.asRGB</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">asRGBA8(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the image data as RGBA pixels with 8-bits per 
        sample.  This method is similar to :meth:`asRGB8` and 
        :meth:`asRGBA`:  The result pixels have an alpha channel, *and* 
        values are rescaled to the range 0 to 255.  The alpha channel is 
        synthesized if necessary (with a small speed penalty). 
        &quot;&quot;&quot;</span>

        <span class="s4">return </span><span class="s1">self._as_rescale(self.asRGBA</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">asRGB(self):</span>
        <span class="s2">&quot;&quot;&quot;Return image as RGB pixels.  RGB colour images are passed 
        through unchanged; greyscales are expanded into RGB 
        triplets (there is a small speed overhead for doing this). 
 
        An alpha channel in the source image will raise an 
        exception. 
 
        The return values are as for the :meth:`read` method 
        except that the *metadata* reflect the returned pixels, not the 
        source image.  In particular, for this method 
        ``metadata['greyscale']`` will be ``False``. 
        &quot;&quot;&quot;</span>

        <span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = self.asDirect()</span>
        <span class="s4">if </span><span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">]:</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;will not convert image with alpha channel to RGB&quot;</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta</span>
        <span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">] = </span><span class="s4">False</span>
        <span class="s1">typecode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>

        <span class="s4">def </span><span class="s1">iterrgb():</span>
            <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                <span class="s1">a = array(typecode</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]) * </span><span class="s5">3 </span><span class="s1">* width</span>
                <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
                    <span class="s1">a[i::</span><span class="s5">3</span><span class="s1">] = row</span>
                <span class="s4">yield </span><span class="s1">a</span>

        <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">iterrgb()</span><span class="s4">, </span><span class="s1">meta</span>

    <span class="s4">def </span><span class="s1">asRGBA(self):</span>
        <span class="s2">&quot;&quot;&quot;Return image as RGBA pixels.  Greyscales are expanded into 
        RGB triplets; an alpha channel is synthesized if necessary. 
        The return values are as for the :meth:`read` method 
        except that the *metadata* reflect the returned pixels, not the 
        source image.  In particular, for this method 
        ``metadata['greyscale']`` will be ``False``, and 
        ``metadata['alpha']`` will be ``True``. 
        &quot;&quot;&quot;</span>

        <span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = self.asDirect()</span>
        <span class="s4">if </span><span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] </span><span class="s4">and not </span><span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta</span>
        <span class="s1">typecode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s1">maxval = </span><span class="s5">2 </span><span class="s1">** meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span>

        <span class="s4">def </span><span class="s1">newarray():</span>
            <span class="s4">return </span><span class="s1">array(typecode</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]) * </span><span class="s5">4 </span><span class="s1">* width</span>

        <span class="s4">if </span><span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] </span><span class="s4">and </span><span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s0"># LA to RGBA</span>
            <span class="s4">def </span><span class="s1">convert():</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s0"># Create a fresh target row, then copy L channel</span>
                    <span class="s0"># into first three target channels, and A channel</span>
                    <span class="s0"># into fourth channel.</span>
                    <span class="s1">a = newarray()</span>
                    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
                        <span class="s1">a[i::</span><span class="s5">4</span><span class="s1">] = row[</span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
                    <span class="s1">a[</span><span class="s5">3</span><span class="s1">::</span><span class="s5">4</span><span class="s1">] = row[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
                    <span class="s4">yield </span><span class="s1">a</span>

        <span class="s4">elif </span><span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s0"># L to RGBA</span>
            <span class="s4">def </span><span class="s1">convert():</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s1">a = newarray()</span>
                    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
                        <span class="s1">a[i::</span><span class="s5">4</span><span class="s1">] = row</span>
                    <span class="s1">a[</span><span class="s5">3</span><span class="s1">::</span><span class="s5">4</span><span class="s1">] = array(typecode</span><span class="s4">, </span><span class="s1">[maxval]) * width</span>
                    <span class="s4">yield </span><span class="s1">a</span>

        <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">assert not </span><span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] </span><span class="s4">and not </span><span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]</span>
            <span class="s0"># RGB to RGBA</span>
            <span class="s4">def </span><span class="s1">convert():</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
                    <span class="s1">a = newarray()</span>
                    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
                        <span class="s1">a[i::</span><span class="s5">4</span><span class="s1">] = row[i::</span><span class="s5">3</span><span class="s1">]</span>
                    <span class="s1">a[</span><span class="s5">3</span><span class="s1">::</span><span class="s5">4</span><span class="s1">] = array(typecode</span><span class="s4">, </span><span class="s1">[maxval]) * width</span>
                    <span class="s4">yield </span><span class="s1">a</span>

        <span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = </span><span class="s4">True</span>
        <span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">] = </span><span class="s4">False</span>
        <span class="s4">return </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">convert()</span><span class="s4">, </span><span class="s1">meta</span>


<span class="s0"># === Internal Test Support ===</span>

<span class="s0"># This section comprises the tests that are internally validated (as</span>
<span class="s0"># opposed to tests which produce output files that are externally</span>
<span class="s0"># validated).  Primarily they are unittests.</span>

<span class="s0"># Note that it is difficult to internally validate the results of</span>
<span class="s0"># writing a PNG file.  The only thing we can do is read it back in</span>
<span class="s0"># again, which merely checks consistency, not that the PNG file we</span>
<span class="s0"># produce is valid.</span>

<span class="s0"># Run the tests from the command line:</span>
<span class="s0"># python -c 'import png;png.test()'</span>

<span class="s0"># (For an in-memory binary file IO object) We use BytesIO where</span>
<span class="s0"># available, otherwise we use StringIO, but name it BytesIO.</span>
<span class="s4">try</span><span class="s1">:</span>
    <span class="s4">from </span><span class="s1">io </span><span class="s4">import </span><span class="s1">BytesIO</span>
<span class="s4">except</span><span class="s1">:</span>
    <span class="s4">from </span><span class="s1">StringIO </span><span class="s4">import </span><span class="s1">StringIO </span><span class="s4">as </span><span class="s1">BytesIO</span>
<span class="s4">import </span><span class="s1">tempfile</span>
<span class="s4">import </span><span class="s1">unittest</span>


<span class="s4">def </span><span class="s1">test():</span>
    <span class="s1">unittest.main(__name__)</span>


<span class="s4">def </span><span class="s1">topngbytes(name</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">**k):</span>
    <span class="s2">&quot;&quot;&quot;Convenience function for creating a PNG file &quot;in memory&quot; as a 
    string.  Creates a :class:`Writer` instance using the keyword arguments, 
    then passes `rows` to its :meth:`Writer.write` method.  The resulting 
    PNG file is returned as a string.  `name` is used to identify the file for 
    debugging. 
    &quot;&quot;&quot;</span>

    <span class="s4">import </span><span class="s1">os</span>

    <span class="s1">print(name)</span>
    <span class="s1">f = BytesIO()</span>
    <span class="s1">w = Writer(x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">**k)</span>
    <span class="s1">w.write(f</span><span class="s4">, </span><span class="s1">rows)</span>
    <span class="s4">if </span><span class="s1">os.environ.get(</span><span class="s3">&quot;PYPNG_TEST_TMP&quot;</span><span class="s1">):</span>
        <span class="s1">w = open(name</span><span class="s4">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>
        <span class="s1">w.write(f.getvalue())</span>
        <span class="s1">w.close()</span>
    <span class="s4">return </span><span class="s1">f.getvalue()</span>


<span class="s4">def </span><span class="s1">testWithIO(inp</span><span class="s4">, </span><span class="s1">out</span><span class="s4">, </span><span class="s1">f):</span>
    <span class="s2">&quot;&quot;&quot;Calls the function `f` with ``sys.stdin`` changed to `inp` 
    and ``sys.stdout`` changed to `out`.  They are restored when `f` 
    returns.  This function returns whatever `f` returns. 
    &quot;&quot;&quot;</span>

    <span class="s4">import </span><span class="s1">os</span>

    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">oldin</span><span class="s4">, </span><span class="s1">sys.stdin = sys.stdin</span><span class="s4">, </span><span class="s1">inp</span>
        <span class="s1">oldout</span><span class="s4">, </span><span class="s1">sys.stdout = sys.stdout</span><span class="s4">, </span><span class="s1">out</span>
        <span class="s1">x = f()</span>
    <span class="s4">finally</span><span class="s1">:</span>
        <span class="s1">sys.stdin = oldin</span>
        <span class="s1">sys.stdout = oldout</span>
    <span class="s4">if </span><span class="s1">os.environ.get(</span><span class="s3">&quot;PYPNG_TEST_TMP&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">hasattr(out</span><span class="s4">, </span><span class="s3">&quot;getvalue&quot;</span><span class="s1">):</span>
        <span class="s1">name = mycallersname()</span>
        <span class="s4">if </span><span class="s1">name:</span>
            <span class="s1">w = open(name + </span><span class="s3">&quot;.png&quot;</span><span class="s4">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>
            <span class="s1">w.write(out.getvalue())</span>
            <span class="s1">w.close()</span>
    <span class="s4">return </span><span class="s1">x</span>


<span class="s4">def </span><span class="s1">mycallersname():</span>
    <span class="s2">&quot;&quot;&quot;Returns the name of the caller of the caller of this function 
    (hence the name of the caller of the function in which 
    &quot;mycallersname()&quot; textually appears).  Returns None if this cannot 
    be determined.&quot;&quot;&quot;</span>

    <span class="s0"># http://docs.python.org/library/inspect.html#the-interpreter-stack</span>
    <span class="s4">import </span><span class="s1">inspect</span>

    <span class="s1">frame = inspect.currentframe()</span>
    <span class="s4">if not </span><span class="s1">frame:</span>
        <span class="s4">return None</span>
    <span class="s1">frame_</span><span class="s4">, </span><span class="s1">filename_</span><span class="s4">, </span><span class="s1">lineno_</span><span class="s4">, </span><span class="s1">funname</span><span class="s4">, </span><span class="s1">linelist_</span><span class="s4">, </span><span class="s1">listi_ = inspect.getouterframes(</span>
        <span class="s1">frame</span>
    <span class="s1">)[</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s4">return </span><span class="s1">funname</span>


<span class="s4">def </span><span class="s1">seqtobytes(s):</span>
    <span class="s2">&quot;&quot;&quot;Convert a sequence of integers to a *bytes* instance.  Good for 
    plastering over Python 2 / Python 3 cracks. 
    &quot;&quot;&quot;</span>

    <span class="s4">return </span><span class="s1">strtobytes(</span><span class="s3">&quot;&quot;</span><span class="s1">.join(chr(x) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">s))</span>


<span class="s4">class </span><span class="s1">Test(unittest.TestCase):</span>
    <span class="s0"># This member is used by the superclass.  If we don't define a new</span>
    <span class="s0"># class here then when we use self.assertRaises() and the PyPNG code</span>
    <span class="s0"># raises an assertion then we get no proper traceback.  I can't work</span>
    <span class="s0"># out why, but defining a new class here means we get a proper</span>
    <span class="s0"># traceback.</span>
    <span class="s4">class </span><span class="s1">failureException(Exception):</span>
        <span class="s4">pass</span>

    <span class="s4">def </span><span class="s1">helperLN(self</span><span class="s4">, </span><span class="s1">n):</span>
        <span class="s1">mask = (</span><span class="s5">1 </span><span class="s1">&lt;&lt; n) - </span><span class="s5">1</span>
        <span class="s0"># Use small chunk_limit so that multiple chunk writing is</span>
        <span class="s0"># tested.  Making it a test for Issue 20.</span>
        <span class="s1">w = Writer(</span><span class="s5">15</span><span class="s4">, </span><span class="s5">17</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">bitdepth=n</span><span class="s4">, </span><span class="s1">chunk_limit=</span><span class="s5">99</span><span class="s1">)</span>
        <span class="s1">f = BytesIO()</span>
        <span class="s1">w.write_array(f</span><span class="s4">, </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">map(mask.__and__</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">256</span><span class="s1">))))</span>
        <span class="s1">r = Reader(bytes=f.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.read()</span>
        <span class="s1">self.assertEqual(x</span><span class="s4">, </span><span class="s5">15</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(y</span><span class="s4">, </span><span class="s5">17</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">list(itertools.chain(*pixels))</span><span class="s4">, </span><span class="s1">map(mask.__and__</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">256</span><span class="s1">))</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testL8(self):</span>
        <span class="s4">return </span><span class="s1">self.helperLN(</span><span class="s5">8</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testL4(self):</span>
        <span class="s4">return </span><span class="s1">self.helperLN(</span><span class="s5">4</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testL2(self):</span>
        <span class="s2">&quot;Also tests asRGB8.&quot;</span>
        <span class="s1">w = Writer(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">bitdepth=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">f = BytesIO()</span>
        <span class="s1">w.write_array(f</span><span class="s4">, </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">)))</span>
        <span class="s1">r = Reader(bytes=f.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asRGB8()</span>
        <span class="s1">self.assertEqual(x</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(y</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">row </span><span class="s4">in </span><span class="s1">enumerate(pixels):</span>
            <span class="s1">self.assertEqual(len(row)</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(list(row)</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0x55 </span><span class="s1">* i] * </span><span class="s5">3</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testP2(self):</span>
        <span class="s2">&quot;2-bit palette.&quot;</span>
        <span class="s1">a = (</span><span class="s5">255</span><span class="s4">, </span><span class="s5">255</span><span class="s4">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">b = (</span><span class="s5">200</span><span class="s4">, </span><span class="s5">120</span><span class="s4">, </span><span class="s5">120</span><span class="s1">)</span>
        <span class="s1">c = (</span><span class="s5">50</span><span class="s4">, </span><span class="s5">99</span><span class="s4">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">w = Writer(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s1">bitdepth=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">palette=[a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c])</span>
        <span class="s1">f = BytesIO()</span>
        <span class="s1">w.write_array(f</span><span class="s4">, </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)))</span>
        <span class="s1">r = Reader(bytes=f.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asRGB8()</span>
        <span class="s1">self.assertEqual(x</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(y</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(list(pixels)</span><span class="s4">, </span><span class="s1">map(list</span><span class="s4">, </span><span class="s1">[a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c]))</span>

    <span class="s4">def </span><span class="s1">testPtrns(self):</span>
        <span class="s2">&quot;Test colour type 3 and tRNS chunk (and 4-bit palette).&quot;</span>
        <span class="s1">a = (</span><span class="s5">50</span><span class="s4">, </span><span class="s5">99</span><span class="s4">, </span><span class="s5">50</span><span class="s4">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">b = (</span><span class="s5">200</span><span class="s4">, </span><span class="s5">120</span><span class="s4">, </span><span class="s5">120</span><span class="s4">, </span><span class="s5">80</span><span class="s1">)</span>
        <span class="s1">c = (</span><span class="s5">255</span><span class="s4">, </span><span class="s5">255</span><span class="s4">, </span><span class="s5">255</span><span class="s1">)</span>
        <span class="s1">d = (</span><span class="s5">200</span><span class="s4">, </span><span class="s5">120</span><span class="s4">, </span><span class="s5">120</span><span class="s1">)</span>
        <span class="s1">e = (</span><span class="s5">50</span><span class="s4">, </span><span class="s5">99</span><span class="s4">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">w = Writer(</span><span class="s5">3</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s1">bitdepth=</span><span class="s5">4</span><span class="s4">, </span><span class="s1">palette=[a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, </span><span class="s1">e])</span>
        <span class="s1">f = BytesIO()</span>
        <span class="s1">w.write_array(f</span><span class="s4">, </span><span class="s1">array(</span><span class="s3">&quot;B&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s5">4</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s1">r = Reader(bytes=f.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asRGBA8()</span>
        <span class="s1">self.assertEqual(x</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(y</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">c = c + (</span><span class="s5">255</span><span class="s4">,</span><span class="s1">)</span>
        <span class="s1">d = d + (</span><span class="s5">255</span><span class="s4">,</span><span class="s1">)</span>
        <span class="s1">e = e + (</span><span class="s5">255</span><span class="s4">,</span><span class="s1">)</span>
        <span class="s1">boxed = [(e</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, </span><span class="s1">c)</span><span class="s4">, </span><span class="s1">(d</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">a)</span><span class="s4">, </span><span class="s1">(c</span><span class="s4">, </span><span class="s1">a</span><span class="s4">, </span><span class="s1">b)]</span>
        <span class="s1">flat = map(</span><span class="s4">lambda </span><span class="s1">row: itertools.chain(*row)</span><span class="s4">, </span><span class="s1">boxed)</span>
        <span class="s1">self.assertEqual(map(list</span><span class="s4">, </span><span class="s1">pixels)</span><span class="s4">, </span><span class="s1">map(list</span><span class="s4">, </span><span class="s1">flat))</span>

    <span class="s4">def </span><span class="s1">testRGBtoRGBA(self):</span>
        <span class="s3">&quot;asRGBA8() on colour type 2 source.&quot; &quot;&quot;</span>
        <span class="s0"># Test for Issue 26</span>
        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;basn2c08&quot;</span><span class="s1">])</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asRGBA8()</span>
        <span class="s0"># Test the pixels at row 9 columns 0 and 1.</span>
        <span class="s1">row9 = list(pixels)[</span><span class="s5">9</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(row9[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">8</span><span class="s1">]</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0xFF</span><span class="s4">, </span><span class="s5">0xDF</span><span class="s4">, </span><span class="s5">0xFF</span><span class="s4">, </span><span class="s5">0xFF</span><span class="s4">, </span><span class="s5">0xFF</span><span class="s4">, </span><span class="s5">0xDE</span><span class="s4">, </span><span class="s5">0xFF</span><span class="s4">, </span><span class="s5">0xFF</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">testLtoRGBA(self):</span>
        <span class="s3">&quot;asRGBA() on grey source.&quot; &quot;&quot;</span>
        <span class="s0"># Test for Issue 60</span>
        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;basi0g08&quot;</span><span class="s1">])</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asRGBA()</span>
        <span class="s1">row9 = list(list(pixels)[</span><span class="s5">9</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(row9[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">8</span><span class="s1">]</span><span class="s4">, </span><span class="s1">[</span><span class="s5">222</span><span class="s4">, </span><span class="s5">222</span><span class="s4">, </span><span class="s5">222</span><span class="s4">, </span><span class="s5">255</span><span class="s4">, </span><span class="s5">221</span><span class="s4">, </span><span class="s5">221</span><span class="s4">, </span><span class="s5">221</span><span class="s4">, </span><span class="s5">255</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">testCtrns(self):</span>
        <span class="s2">&quot;Test colour type 2 and tRNS chunk.&quot;</span>
        <span class="s0"># Test for Issue 25</span>
        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;tbrn2c08&quot;</span><span class="s1">])</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asRGBA8()</span>
        <span class="s0"># I just happen to know that the first pixel is transparent.</span>
        <span class="s0"># In particular it should be #7f7f7f00</span>
        <span class="s1">row0 = list(pixels)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(tuple(row0[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">4</span><span class="s1">])</span><span class="s4">, </span><span class="s1">(</span><span class="s5">0x7F</span><span class="s4">, </span><span class="s5">0x7F</span><span class="s4">, </span><span class="s5">0x7F</span><span class="s4">, </span><span class="s5">0x00</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">testAdam7read(self):</span>
        <span class="s2">&quot;&quot;&quot;Adam7 interlace reading. 
        Specifically, test that for images in the PngSuite that 
        have both an interlaced and straightlaced pair that both 
        images from the pair produce the same array of pixels.&quot;&quot;&quot;</span>
        <span class="s4">for </span><span class="s1">candidate </span><span class="s4">in </span><span class="s1">_pngsuite:</span>
            <span class="s4">if not </span><span class="s1">candidate.startswith(</span><span class="s3">&quot;basn&quot;</span><span class="s1">):</span>
                <span class="s4">continue</span>
            <span class="s1">candi = candidate.replace(</span><span class="s3">&quot;n&quot;</span><span class="s4">, </span><span class="s3">&quot;i&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">candi </span><span class="s4">not in </span><span class="s1">_pngsuite:</span>
                <span class="s4">continue</span>
            <span class="s1">print(</span><span class="s3">f&quot;adam7 read </span><span class="s4">{</span><span class="s1">candidate</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">straight = Reader(bytes=_pngsuite[candidate])</span>
            <span class="s1">adam7 = Reader(bytes=_pngsuite[candi])</span>
            <span class="s0"># Just compare the pixels.  Ignore x,y (because they're</span>
            <span class="s0"># likely to be correct?); metadata is ignored because the</span>
            <span class="s0"># &quot;interlace&quot; member differs.  Lame.</span>
            <span class="s1">straight = straight.read()[</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">adam7 = adam7.read()[</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">self.assertEqual(map(list</span><span class="s4">, </span><span class="s1">straight)</span><span class="s4">, </span><span class="s1">map(list</span><span class="s4">, </span><span class="s1">adam7))</span>

    <span class="s4">def </span><span class="s1">testAdam7write(self):</span>
        <span class="s2">&quot;&quot;&quot;Adam7 interlace writing. 
        For each test image in the PngSuite, write an interlaced 
        and a straightlaced version.  Decode both, and compare results. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Not such a great test, because the only way we can check what</span>
        <span class="s0"># we have written is to read it back again.</span>

        <span class="s4">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">bytes </span><span class="s4">in </span><span class="s1">_pngsuite.items():</span>
            <span class="s0"># Only certain colour types supported for this test.</span>
            <span class="s4">if </span><span class="s1">name[</span><span class="s5">3</span><span class="s1">:</span><span class="s5">5</span><span class="s1">] </span><span class="s4">not in </span><span class="s1">[</span><span class="s3">&quot;n0&quot;</span><span class="s4">, </span><span class="s3">&quot;n2&quot;</span><span class="s4">, </span><span class="s3">&quot;n4&quot;</span><span class="s4">, </span><span class="s3">&quot;n6&quot;</span><span class="s1">]:</span>
                <span class="s4">continue</span>
            <span class="s1">it = Reader(bytes=bytes)</span>
            <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = it.read()</span>
            <span class="s1">pngi = topngbytes(</span>
                <span class="s3">f&quot;adam7wn</span><span class="s4">{</span><span class="s1">name</span><span class="s4">}</span><span class="s3">.png&quot;</span><span class="s4">,</span>
                <span class="s1">pixels</span><span class="s4">,</span>
                <span class="s1">x=x</span><span class="s4">,</span>
                <span class="s1">y=y</span><span class="s4">,</span>
                <span class="s1">bitdepth=it.bitdepth</span><span class="s4">,</span>
                <span class="s1">greyscale=it.greyscale</span><span class="s4">,</span>
                <span class="s1">alpha=it.alpha</span><span class="s4">,</span>
                <span class="s1">transparent=it.transparent</span><span class="s4">,</span>
                <span class="s1">interlace=</span><span class="s4">False,</span>
            <span class="s1">)</span>
            <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">ps</span><span class="s4">, </span><span class="s1">meta = Reader(bytes=pngi).read()</span>
            <span class="s1">it = Reader(bytes=bytes)</span>
            <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = it.read()</span>
            <span class="s1">pngs = topngbytes(</span>
                <span class="s3">f&quot;adam7wi</span><span class="s4">{</span><span class="s1">name</span><span class="s4">}</span><span class="s3">.png&quot;</span><span class="s4">,</span>
                <span class="s1">pixels</span><span class="s4">,</span>
                <span class="s1">x=x</span><span class="s4">,</span>
                <span class="s1">y=y</span><span class="s4">,</span>
                <span class="s1">bitdepth=it.bitdepth</span><span class="s4">,</span>
                <span class="s1">greyscale=it.greyscale</span><span class="s4">,</span>
                <span class="s1">alpha=it.alpha</span><span class="s4">,</span>
                <span class="s1">transparent=it.transparent</span><span class="s4">,</span>
                <span class="s1">interlace=</span><span class="s4">True,</span>
            <span class="s1">)</span>
            <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pi</span><span class="s4">, </span><span class="s1">meta = Reader(bytes=pngs).read()</span>
            <span class="s1">self.assertEqual(map(list</span><span class="s4">, </span><span class="s1">ps)</span><span class="s4">, </span><span class="s1">map(list</span><span class="s4">, </span><span class="s1">pi))</span>

    <span class="s4">def </span><span class="s1">testPGMin(self):</span>
        <span class="s2">&quot;&quot;&quot;Test that the command line tool can read PGM files.&quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">do():</span>
            <span class="s4">return </span><span class="s1">_main([</span><span class="s3">&quot;testPGMin&quot;</span><span class="s1">])</span>

        <span class="s1">s = BytesIO()</span>
        <span class="s1">s.write(strtobytes(</span><span class="s3">&quot;P5 2 2 3</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s1">s.write(strtobytes(</span><span class="s3">&quot;</span><span class="s4">\x00\x01\x02\x03</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s1">s.flush()</span>
        <span class="s1">s.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">o = BytesIO()</span>
        <span class="s1">testWithIO(s</span><span class="s4">, </span><span class="s1">o</span><span class="s4">, </span><span class="s1">do)</span>
        <span class="s1">r = Reader(bytes=o.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.read()</span>
        <span class="s1">self.assertTrue(r.greyscale)</span>
        <span class="s1">self.assertEqual(r.bitdepth</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testPAMin(self):</span>
        <span class="s2">&quot;&quot;&quot;Test that the command line tool can read PAM file.&quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">do():</span>
            <span class="s4">return </span><span class="s1">_main([</span><span class="s3">&quot;testPAMin&quot;</span><span class="s1">])</span>

        <span class="s1">s = BytesIO()</span>
        <span class="s1">s.write(</span>
            <span class="s1">strtobytes(</span>
                <span class="s3">&quot;P7</span><span class="s4">\n</span><span class="s3">WIDTH 3</span><span class="s4">\n</span><span class="s3">HEIGHT 1</span><span class="s4">\n</span><span class="s3">DEPTH 4</span><span class="s4">\n</span><span class="s3">MAXVAL 255</span><span class="s4">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;TUPLTYPE RGB_ALPHA</span><span class="s4">\n</span><span class="s3">ENDHDR</span><span class="s4">\n</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s0"># The pixels in flat row flat pixel format</span>
        <span class="s1">flat = [</span><span class="s5">255</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">255</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">255</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">120</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">255</span><span class="s4">, </span><span class="s5">30</span><span class="s1">]</span>
        <span class="s1">asbytes = seqtobytes(flat)</span>
        <span class="s1">s.write(asbytes)</span>
        <span class="s1">s.flush()</span>
        <span class="s1">s.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">o = BytesIO()</span>
        <span class="s1">testWithIO(s</span><span class="s4">, </span><span class="s1">o</span><span class="s4">, </span><span class="s1">do)</span>
        <span class="s1">r = Reader(bytes=o.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.read()</span>
        <span class="s1">self.assertTrue(r.alpha)</span>
        <span class="s1">self.assertTrue(</span><span class="s4">not </span><span class="s1">r.greyscale)</span>
        <span class="s1">self.assertEqual(list(itertools.chain(*pixels))</span><span class="s4">, </span><span class="s1">flat)</span>

    <span class="s4">def </span><span class="s1">testLA4(self):</span>
        <span class="s2">&quot;&quot;&quot;Create an LA image with bitdepth 4.&quot;&quot;&quot;</span>
        <span class="s1">bytes = topngbytes(</span>
            <span class="s3">&quot;la4.png&quot;</span><span class="s4">, </span><span class="s1">[[</span><span class="s5">5</span><span class="s4">, </span><span class="s5">12</span><span class="s1">]]</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">alpha=</span><span class="s4">True, </span><span class="s1">bitdepth=</span><span class="s5">4</span>
        <span class="s1">)</span>
        <span class="s1">sbit = Reader(bytes=bytes).chunk(</span><span class="s3">&quot;sBIT&quot;</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(sbit</span><span class="s4">, </span><span class="s1">strtobytes(</span><span class="s3">&quot;</span><span class="s4">\x04\x04</span><span class="s3">&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">testPNMsbit(self):</span>
        <span class="s2">&quot;&quot;&quot;Test that PNM files can generates sBIT chunk.&quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">do():</span>
            <span class="s4">return </span><span class="s1">_main([</span><span class="s3">&quot;testPNMsbit&quot;</span><span class="s1">])</span>

        <span class="s1">s = BytesIO()</span>
        <span class="s1">s.write(strtobytes(</span><span class="s3">&quot;P6 8 1 1</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s4">for </span><span class="s1">pixel </span><span class="s4">in </span><span class="s1">range(</span><span class="s5">8</span><span class="s1">):</span>
            <span class="s1">s.write(struct.pack(</span><span class="s3">&quot;&lt;I&quot;</span><span class="s4">, </span><span class="s1">(</span><span class="s5">0x4081 </span><span class="s1">* pixel) &amp; </span><span class="s5">0x10101</span><span class="s1">)[:</span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">s.flush()</span>
        <span class="s1">s.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">o = BytesIO()</span>
        <span class="s1">testWithIO(s</span><span class="s4">, </span><span class="s1">o</span><span class="s4">, </span><span class="s1">do)</span>
        <span class="s1">r = Reader(bytes=o.getvalue())</span>
        <span class="s1">sbit = r.chunk(</span><span class="s3">&quot;sBIT&quot;</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self.assertEqual(sbit</span><span class="s4">, </span><span class="s1">strtobytes(</span><span class="s3">&quot;</span><span class="s4">\x01\x01\x01</span><span class="s3">&quot;</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">testLtrns0(self):</span>
        <span class="s2">&quot;&quot;&quot;Create greyscale image with tRNS chunk.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.helperLtrns(</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testLtrns1(self):</span>
        <span class="s2">&quot;&quot;&quot;Using 1-tuple for transparent arg.&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self.helperLtrns((</span><span class="s5">0</span><span class="s4">,</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">helperLtrns(self</span><span class="s4">, </span><span class="s1">transparent):</span>
        <span class="s2">&quot;&quot;&quot;Helper used by :meth:`testLtrns*`.&quot;&quot;&quot;</span>
        <span class="s1">pixels = zip([</span><span class="s5">0x00</span><span class="s4">, </span><span class="s5">0x38</span><span class="s4">, </span><span class="s5">0x4C</span><span class="s4">, </span><span class="s5">0x54</span><span class="s4">, </span><span class="s5">0x5C</span><span class="s4">, </span><span class="s5">0x40</span><span class="s4">, </span><span class="s5">0x38</span><span class="s4">, </span><span class="s5">0x00</span><span class="s1">])</span>
        <span class="s1">o = BytesIO()</span>
        <span class="s1">w = Writer(</span><span class="s5">8</span><span class="s4">, </span><span class="s5">8</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">bitdepth=</span><span class="s5">1</span><span class="s4">, </span><span class="s1">transparent=transparent)</span>
        <span class="s1">w.write_packed(o</span><span class="s4">, </span><span class="s1">pixels)</span>
        <span class="s1">r = Reader(bytes=o.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asDirect()</span>
        <span class="s1">self.assertTrue(meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertTrue(meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">])</span>
        <span class="s1">self.assertEqual(meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testWinfo(self):</span>
        <span class="s2">&quot;&quot;&quot;Test the dictionary returned by a `read` method can be used 
        as args for :meth:`Writer`. 
        &quot;&quot;&quot;</span>
        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;basn2c16&quot;</span><span class="s1">])</span>
        <span class="s1">info = r.read()[</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s1">w = Writer(**info)</span>

    <span class="s4">def </span><span class="s1">testPackedIter(self):</span>
        <span class="s2">&quot;&quot;&quot;Test iterator for row when using write_packed. 
 
        Indicative for Issue 47. 
        &quot;&quot;&quot;</span>
        <span class="s1">w = Writer(</span><span class="s5">16</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">alpha=</span><span class="s4">False, </span><span class="s1">bitdepth=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">o = BytesIO()</span>
        <span class="s1">w.write_packed(</span>
            <span class="s1">o</span><span class="s4">, </span><span class="s1">[itertools.chain([</span><span class="s5">0x0A</span><span class="s1">]</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0xAA</span><span class="s1">])</span><span class="s4">, </span><span class="s1">itertools.chain([</span><span class="s5">0x0F</span><span class="s1">]</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0xFF</span><span class="s1">])]</span>
        <span class="s1">)</span>
        <span class="s1">r = Reader(bytes=o.getvalue())</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">info = r.asDirect()</span>
        <span class="s1">pixels = list(pixels)</span>
        <span class="s1">self.assertEqual(len(pixels)</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(pixels[</span><span class="s5">0</span><span class="s1">])</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testInterlacedArray(self):</span>
        <span class="s2">&quot;&quot;&quot;Test that reading an interlaced PNG yields each row as an 
        array.&quot;&quot;&quot;</span>
        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;basi0g08&quot;</span><span class="s1">])</span>
        <span class="s1">list(r.read()[</span><span class="s5">2</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">].tostring</span>

    <span class="s4">def </span><span class="s1">testTrnsArray(self):</span>
        <span class="s2">&quot;&quot;&quot;Test that reading a type 2 PNG with tRNS chunk yields each 
        row as an array (using asDirect).&quot;&quot;&quot;</span>
        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;tbrn2c08&quot;</span><span class="s1">])</span>
        <span class="s1">list(r.asDirect()[</span><span class="s5">2</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">].tostring</span>

    <span class="s0"># Invalid file format tests.  These construct various badly</span>
    <span class="s0"># formatted PNG files, then feed them into a Reader.  When</span>
    <span class="s0"># everything is working properly, we should get FormatError</span>
    <span class="s0"># exceptions raised.</span>
    <span class="s4">def </span><span class="s1">testEmpty(self):</span>
        <span class="s2">&quot;&quot;&quot;Test empty file.&quot;&quot;&quot;</span>

        <span class="s1">r = Reader(bytes=</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">self.assertRaises(FormatError</span><span class="s4">, </span><span class="s1">r.asDirect)</span>

    <span class="s4">def </span><span class="s1">testSigOnly(self):</span>
        <span class="s2">&quot;&quot;&quot;Test file containing just signature bytes.&quot;&quot;&quot;</span>

        <span class="s1">r = Reader(bytes=_signature)</span>
        <span class="s1">self.assertRaises(FormatError</span><span class="s4">, </span><span class="s1">r.asDirect)</span>

    <span class="s4">def </span><span class="s1">testExtraPixels(self):</span>
        <span class="s2">&quot;&quot;&quot;Test file that contains too many pixels.&quot;&quot;&quot;</span>

        <span class="s4">def </span><span class="s1">eachchunk(chunk):</span>
            <span class="s4">if </span><span class="s1">chunk[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">&quot;IDAT&quot;</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">chunk</span>
            <span class="s1">data = zlib.decompress(chunk[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">data += strtobytes(</span><span class="s3">&quot;</span><span class="s4">\x00</span><span class="s3">garbage&quot;</span><span class="s1">)</span>
            <span class="s1">data = zlib.compress(data)</span>
            <span class="s1">chunk = (chunk[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">data)</span>
            <span class="s4">return </span><span class="s1">chunk</span>

        <span class="s1">self.assertRaises(FormatError</span><span class="s4">, </span><span class="s1">self.helperFormat</span><span class="s4">, </span><span class="s1">eachchunk)</span>

    <span class="s4">def </span><span class="s1">testNotEnoughPixels(self):</span>
        <span class="s4">def </span><span class="s1">eachchunk(chunk):</span>
            <span class="s4">if </span><span class="s1">chunk[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">&quot;IDAT&quot;</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">chunk</span>
            <span class="s0"># Remove last byte.</span>
            <span class="s1">data = zlib.decompress(chunk[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">data = data[:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">data = zlib.compress(data)</span>
            <span class="s4">return </span><span class="s1">(chunk[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">data)</span>

        <span class="s1">self.assertRaises(FormatError</span><span class="s4">, </span><span class="s1">self.helperFormat</span><span class="s4">, </span><span class="s1">eachchunk)</span>

    <span class="s4">def </span><span class="s1">helperFormat(self</span><span class="s4">, </span><span class="s1">f):</span>
        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;basn0g01&quot;</span><span class="s1">])</span>
        <span class="s1">o = BytesIO()</span>

        <span class="s4">def </span><span class="s1">newchunks():</span>
            <span class="s4">for </span><span class="s1">chunk </span><span class="s4">in </span><span class="s1">r.chunks():</span>
                <span class="s4">yield </span><span class="s1">f(chunk)</span>

        <span class="s1">write_chunks(o</span><span class="s4">, </span><span class="s1">newchunks())</span>
        <span class="s1">r = Reader(bytes=o.getvalue())</span>
        <span class="s4">return </span><span class="s1">list(r.asDirect()[</span><span class="s5">2</span><span class="s1">])</span>

    <span class="s4">def </span><span class="s1">testBadFilter(self):</span>
        <span class="s4">def </span><span class="s1">eachchunk(chunk):</span>
            <span class="s4">if </span><span class="s1">chunk[</span><span class="s5">0</span><span class="s1">] != </span><span class="s3">&quot;IDAT&quot;</span><span class="s1">:</span>
                <span class="s4">return </span><span class="s1">chunk</span>
            <span class="s1">data = zlib.decompress(chunk[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s0"># Corrupt the first filter byte</span>
            <span class="s1">data = strtobytes(</span><span class="s3">&quot;</span><span class="s4">\x99</span><span class="s3">&quot;</span><span class="s1">) + data[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s1">data = zlib.compress(data)</span>
            <span class="s4">return </span><span class="s1">(chunk[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">data)</span>

        <span class="s1">self.assertRaises(FormatError</span><span class="s4">, </span><span class="s1">self.helperFormat</span><span class="s4">, </span><span class="s1">eachchunk)</span>

    <span class="s4">def </span><span class="s1">testFlat(self):</span>
        <span class="s2">&quot;&quot;&quot;Test read_flat.&quot;&quot;&quot;</span>
        <span class="s4">import </span><span class="s1">hashlib</span>

        <span class="s1">r = Reader(bytes=_pngsuite[</span><span class="s3">&quot;basn0g02&quot;</span><span class="s1">])</span>
        <span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">pixel</span><span class="s4">, </span><span class="s1">meta = r.read_flat()</span>
        <span class="s1">d = hashlib.md5(seqtobytes(pixel)).digest()</span>
        <span class="s1">self.assertEqual(_enhex(d)</span><span class="s4">, </span><span class="s3">&quot;255cd971ab8cd9e7275ff906e5041aa0&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testfromarray(self):</span>
        <span class="s1">img = from_array([[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0x33</span><span class="s4">, </span><span class="s5">0x66</span><span class="s1">]</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0xFF</span><span class="s4">, </span><span class="s5">0xCC</span><span class="s4">, </span><span class="s5">0x99</span><span class="s1">]]</span><span class="s4">, </span><span class="s3">&quot;L&quot;</span><span class="s1">)</span>
        <span class="s1">img.save(</span><span class="s3">&quot;testfromarray.png&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testfromarrayL16(self):</span>
        <span class="s1">img = from_array(group(range(</span><span class="s5">2</span><span class="s1">**</span><span class="s5">16</span><span class="s1">)</span><span class="s4">, </span><span class="s5">256</span><span class="s1">)</span><span class="s4">, </span><span class="s3">&quot;L;16&quot;</span><span class="s1">)</span>
        <span class="s1">img.save(</span><span class="s3">&quot;testL16.png&quot;</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testfromarrayRGB(self):</span>
        <span class="s1">img = from_array(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">]</span><span class="s4">,</span>
                <span class="s1">[</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">]</span><span class="s4">,</span>
            <span class="s1">]</span><span class="s4">,</span>
            <span class="s3">&quot;RGB;1&quot;</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s1">o = BytesIO()</span>
        <span class="s1">img.save(o)</span>

    <span class="s4">def </span><span class="s1">testfromarrayIter(self):</span>
        <span class="s4">import </span><span class="s1">itertools</span>

        <span class="s1">i = itertools.islice(itertools.count(</span><span class="s5">10</span><span class="s1">)</span><span class="s4">, </span><span class="s5">20</span><span class="s1">)</span>
        <span class="s1">i = map(</span><span class="s4">lambda </span><span class="s1">x: [x</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">x]</span><span class="s4">, </span><span class="s1">i)</span>
        <span class="s1">img = from_array(i</span><span class="s4">, </span><span class="s3">&quot;RGB;5&quot;</span><span class="s4">, </span><span class="s1">dict(height=</span><span class="s5">20</span><span class="s1">))</span>
        <span class="s1">f = open(</span><span class="s3">&quot;testiter.png&quot;</span><span class="s4">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>
        <span class="s1">img.save(f)</span>
        <span class="s1">f.close()</span>

    <span class="s0"># numpy dependent tests.  These are skipped (with a message to</span>
    <span class="s0"># sys.stderr) if numpy cannot be imported.</span>
    <span class="s4">def </span><span class="s1">testNumpyuint16(self):</span>
        <span class="s2">&quot;&quot;&quot;numpy uint16.&quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">import </span><span class="s1">numpy</span>
        <span class="s4">except </span><span class="s1">ImportError:</span>
            <span class="s1">sys.stderr.write(</span><span class="s3">&quot;skipping numpy test</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s1">rows = [map(numpy.uint16</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0x10000</span><span class="s4">, </span><span class="s5">0x5555</span><span class="s1">))]</span>
        <span class="s1">b = topngbytes(</span>
            <span class="s3">&quot;numpyuint16.png&quot;</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">alpha=</span><span class="s4">False, </span><span class="s1">bitdepth=</span><span class="s5">16</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testNumpyuint8(self):</span>
        <span class="s2">&quot;&quot;&quot;numpy uint8.&quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">import </span><span class="s1">numpy</span>
        <span class="s4">except </span><span class="s1">ImportError:</span>
            <span class="s1">sys.stderr.write(</span><span class="s3">&quot;skipping numpy test</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s1">rows = [map(numpy.uint8</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0x100</span><span class="s4">, </span><span class="s5">0x55</span><span class="s1">))]</span>
        <span class="s1">b = topngbytes(</span>
            <span class="s3">&quot;numpyuint8.png&quot;</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s5">4</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">alpha=</span><span class="s4">False, </span><span class="s1">bitdepth=</span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testNumpybool(self):</span>
        <span class="s2">&quot;&quot;&quot;numpy bool.&quot;&quot;&quot;</span>

        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">import </span><span class="s1">numpy</span>
        <span class="s4">except </span><span class="s1">ImportError:</span>
            <span class="s1">sys.stderr.write(</span><span class="s3">&quot;skipping numpy test</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s1">rows = [map(numpy.bool</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s1">])]</span>
        <span class="s1">b = topngbytes(</span>
            <span class="s3">&quot;numpybool.png&quot;</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s1">greyscale=</span><span class="s4">True, </span><span class="s1">alpha=</span><span class="s4">False, </span><span class="s1">bitdepth=</span><span class="s5">1</span>
        <span class="s1">)</span>

    <span class="s4">def </span><span class="s1">testNumpyarray(self):</span>
        <span class="s2">&quot;&quot;&quot;numpy array.&quot;&quot;&quot;</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s4">import </span><span class="s1">numpy</span>
        <span class="s4">except </span><span class="s1">ImportError:</span>
            <span class="s1">sys.stderr.write(</span><span class="s3">&quot;skipping numpy test</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s4">return</span>

        <span class="s1">pixels = numpy.array([[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0x5555</span><span class="s1">]</span><span class="s4">, </span><span class="s1">[</span><span class="s5">0x5555</span><span class="s4">, </span><span class="s5">0xAAAA</span><span class="s1">]]</span><span class="s4">, </span><span class="s1">numpy.uint16)</span>
        <span class="s1">img = from_array(pixels</span><span class="s4">, </span><span class="s3">&quot;L&quot;</span><span class="s1">)</span>
        <span class="s1">img.save(</span><span class="s3">&quot;testnumpyL16.png&quot;</span><span class="s1">)</span>


<span class="s0"># === Command Line Support ===</span>


<span class="s4">def </span><span class="s1">_dehex(s):</span>
    <span class="s2">&quot;&quot;&quot;Liberally convert from hex string to binary string.&quot;&quot;&quot;</span>
    <span class="s4">import </span><span class="s1">re</span>
    <span class="s4">import </span><span class="s1">binascii</span>

    <span class="s0"># Remove all non-hexadecimal digits</span>
    <span class="s1">s = re.sub(</span><span class="s3">r&quot;[^a-fA-F\d]&quot;</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s4">, </span><span class="s1">s)</span>
    <span class="s0"># binscii.unhexlify works in Python 2 and Python 3 (unlike</span>
    <span class="s0"># thing.decode('hex')).</span>
    <span class="s4">return </span><span class="s1">binascii.unhexlify(strtobytes(s))</span>


<span class="s4">def </span><span class="s1">_enhex(s):</span>
    <span class="s2">&quot;&quot;&quot;Convert from binary string (bytes) to hex string (str).&quot;&quot;&quot;</span>

    <span class="s4">import </span><span class="s1">binascii</span>

    <span class="s4">return </span><span class="s1">bytestostr(binascii.hexlify(s))</span>


<span class="s0"># Copies of PngSuite test files taken</span>
<span class="s0"># from http://www.schaik.com/pngsuite/pngsuite_bas_png.html</span>
<span class="s0"># on 2009-02-19 by drj and converted to hex.</span>
<span class="s0"># Some of these are not actually in PngSuite (but maybe they should</span>
<span class="s0"># be?), they use the same naming scheme, but start with a capital</span>
<span class="s0"># letter.</span>
<span class="s1">_pngsuite = {</span>
    <span class="s3">&quot;basi0g01&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000200000002001000000012c0677 
cf0000000467414d41000186a031e8965f0000009049444154789c2d8d310ec2 
300c45dfc682c415187a00a42e197ab81e83b127e00c5639001363a580d8582c 
65c910357c4b78b0bfbfdf4f70168c19e7acb970a3f2d1ded9695ce5bf5963df 
d92aaf4c9fd927ea449e6487df5b9c36e799b91bdf082b4d4bd4014fe4014b01 
ab7a17aee694d28d328a2d63837a70451e1648702d9a9ff4a11d2f7a51aa21e5 
a18c7ffd0094e3511d661822f20000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi0g02&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000200000002002000000016ba60d 
1f0000000467414d41000186a031e8965f0000005149444154789c635062e860 
00e17286bb609c93c370ec189494960631366e4467b3ae675dcf10f521ea0303 
90c1ca006444e11643482064114a4852c710baea3f18c31918020c30410403a6 
0ac1a09239009c52804d85b6d97d0000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi0g04&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000200400000001e4e6f8 
bf0000000467414d41000186a031e8965f000000ae49444154789c658e5111c2 
301044171c141c141c041c843a287510ea20d441c041c141c141c04191102454 
03994998cecd7edcecedbb9bdbc3b2c2b6457545fbc4bac1be437347f7c66a77 
3c23d60db15e88f5c5627338a5416c2e691a9b475a89cd27eda12895ae8dfdab 
43d61e590764f5c83a226b40d669bec307f93247701687723abf31ff83a2284b 
a5b4ae6b63ac6520ad730ca4ed7b06d20e030369bd6720ed383290360406d24e 
13811f2781eba9d34d07160000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi0g08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000200800000001211615 
be0000000467414d41000186a031e8965f000000b549444154789cb5905d0ac2 
3010849dbac81c42c47bf843cf253e8878b0aa17110f214bdca6be240f5d21a5 
94ced3e49bcd322c1624115515154998aa424822a82a5624a1aa8a8b24c58f99 
999908130989a04a00d76c2c09e76cf21adcb209393a6553577da17140a2c59e 
70ecbfa388dff1f03b82fb82bd07f05f7cb13f80bb07ad2fd60c011c3c588eef 
f1f4e03bbec7ce832dca927aea005e431b625796345307b019c845e6bfc3bb98 
769d84f9efb02ea6c00f9bb9ff45e81f9f280000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi0g16&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000200000002010000000017186c9 
fd0000000467414d41000186a031e8965f000000e249444154789cb5913b0ec2 
301044c7490aa8f85d81c3e4301c8f53a4ca0da8902c8144b3920b4043111282 
23bc4956681a6bf5fc3c5a3ba0448912d91a4de2c38dd8e380231eede4c4f7a1 
4677700bec7bd9b1d344689315a3418d1a6efbe5b8305ba01f8ff4808c063e26 
c60d5c81edcf6c58c535e252839e93801b15c0a70d810ae0d306b205dc32b187 
272b64057e4720ff0502154034831520154034c3df81400510cdf0015c86e5cc 
5c79c639fddba9dcb5456b51d7980eb52d8e7d7fa620a75120d6064641a05120 
b606771a05626b401a05f1f589827cf0fe44c1f0bae0055698ee8914fffffe00 
00000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi2c08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000200000002008020000018b1fdd 
350000000467414d41000186a031e8965f000000f249444154789cd59341aa04 
210c44abc07b78133d59d37333bd89d76868b566d10cf4675af8596431a11662 
7c5688919280e312257dd6a0a4cf1a01008ee312a5f3c69c37e6fcc3f47e6776 
a07f8bdaf5b40feed2d33e025e2ff4fe2d4a63e1a16d91180b736d8bc45854c5 
6d951863f4a7e0b66dcf09a900f3ffa2948d4091e53ca86c048a64390f662b50 
4a999660ced906182b9a01a8be00a56404a6ede182b1223b4025e32c4de34304 
63457680c93aada6c99b73865aab2fc094920d901a203f5ddfe1970d28456783 
26cffbafeffcd30654f46d119be4793f827387fc0d189d5bc4d69a3c23d45a7f 
db803146578337df4d0a3121fc3d330000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi2c16&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000201002000001db8f01 
760000000467414d41000186a031e8965f0000020a49444154789cd5962173e3 
3010853fcf1838cc61a1818185a53e56787fa13fa130852e3b5878b4b0b03081 
b97f7030070b53e6b057a0a8912bbb9163b9f109ececbc59bd7dcf2b45492409 
d66f00eb1dd83cb5497d65456aeb8e1040913b3b2c04504c936dd5a9c7e2c6eb 
b1b8f17a58e8d043da56f06f0f9f62e5217b6ba3a1b76f6c9e99e8696a2a72e2 
c4fb1e4d452e92ec9652b807486d12b6669be00db38d9114b0c1961e375461a5 
5f76682a85c367ad6f682ff53a9c2a353191764b78bb07d8ddc3c97c1950f391 
6745c7b9852c73c2f212605a466a502705c8338069c8b9e84efab941eb393a97 
d4c9fd63148314209f1c1d3434e847ead6380de291d6f26a25c1ebb5047f5f24 
d85c49f0f22cc1d34282c72709cab90477bf25b89d49f0f351822297e0ea9704 
f34c82bc94002448ede51866e5656aef5d7c6a385cb4d80e6a538ceba04e6df2 
480e9aa84ddedb413bb5c97b3838456df2d4fec2c7a706983e7474d085fae820 
a841776a83073838973ac0413fea2f1dc4a06e71108fda73109bdae48954ad60 
bf867aac3ce44c7c1589a711cf8a81df9b219679d96d1cec3d8bbbeaa2012626 
df8c7802eda201b2d2e0239b409868171fc104ba8b76f10b4da09f6817ffc609 
c413ede267fd1fbab46880c90f80eccf0013185eb48b47ba03df2bdaadef3181 
cb8976f18e13188768170f98c0f844bb78cb04c62ddac59d09fc3fa25dfc1da4 
14deb3df1344f70000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi3p08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020080300000133a3ba 
500000000467414d41000186a031e8965f00000300504c5445224400f5ffed77 
ff77cbffff110a003a77002222ffff11ff110000222200ffac5566ff66ff6666 
ff01ff221200dcffffccff994444ff005555220000cbcbff44440055ff55cbcb 
00331a00ffecdcedffffe4ffcbffdcdc44ff446666ff330000442200ededff66 
6600ffa444ffffaaeded0000cbcbfefffffdfffeffff0133ff33552a000101ff 
8888ff00aaaa010100440000888800ffe4cbba5b0022ff22663200ffff99aaaa 
ff550000aaaa00cb630011ff11d4ffaa773a00ff4444dc6b0066000001ff0188 
4200ecffdc6bdc00ffdcba00333300ed00ed7300ffff88994a0011ffff770000 
ff8301ffbabafe7b00fffeff00cb00ff999922ffff880000ffff77008888ffdc 
ff1a33000000aa33ffff009900990000000001326600ffbaff44ffffffaaff00 
770000fefeaa00004a9900ffff66ff22220000998bff1155ffffff0101ff88ff 
005500001111fffffefffdfea4ff4466ffffff66ff003300ffff55ff77770000 
88ff44ff00110077ffff006666ffffed000100fff5ed1111ffffff44ff22ffff 
eded11110088ffff00007793ff2200dcdc3333fffe00febabaff99ffff333300 
63cb00baba00acff55ffffdcffff337bfe00ed00ed5555ffaaffffdcdcff5555 
00000066dcdc00dc00dc83ff017777fffefeffffffcbff5555777700fefe00cb 
00cb0000fe010200010000122200ffff220044449bff33ffd4aa0000559999ff 
999900ba00ba2a5500ffcbcbb4ff66ff9b33ffffbaaa00aa42880053aa00ffaa 
aa0000ed00babaffff1100fe00000044009999990099ffcc99ba000088008800 
dc00ff93220000dcfefffeaa5300770077020100cb0000000033ffedff00ba00 
ff3333edffedffc488bcff7700aa00660066002222dc0000ffcbffdcffdcff8b 
110000cb00010155005500880000002201ffffcbffcbed0000ff88884400445b 
ba00ffbc77ff99ff006600baffba00777773ed00fe00003300330000baff77ff 
004400aaffaafffefe000011220022c4ff8800eded99ff99ff55ff002200ffb4 
661100110a1100ff1111dcffbabaffff88ff88010001ff33ffb98ed362000002 
a249444154789c65d0695c0b001806f03711a9904a94d24dac63292949e5a810 
d244588a14ca5161d1a1323973252242d62157d12ae498c8124d25ca3a11398a 
16e55a3cdffab0ffe7f77d7fcff3528645349b584c3187824d9d19d4ec2e3523 
9eb0ae975cf8de02f2486d502191841b42967a1ad49e5ddc4265f69a899e26b5 
e9e468181baae3a71a41b95669da8df2ea3594c1b31046d7b17bfb86592e4cbe 
d89b23e8db0af6304d756e60a8f4ad378bdc2552ae5948df1d35b52143141533 
33bbbbababebeb3b3bc9c9c9c6c6c0c0d7b7b535323225a5aa8a02024a4bedec 
0a0a2a2bcdcd7d7cf2f3a9a9c9cdcdd8b8adcdd5b5ababa828298982824a4ab2 
b21212acadbdbc1414e2e24859b9a72730302f4f49292c4c57373c9c0a0b7372 
8c8c1c1c3a3a92936d6dfdfd293e3e26262a4a4eaea2424b4b5fbfbc9c323278 
3c0b0ba1303abaae8ecdeeed950d6669a9a7a7a141d4de9e9d5d5cdcd2229b94 
c572716132f97cb1d8db9bc3110864a39795d9db6b6a26267a7a9a98d4d6a6a7 
cb76090ef6f030354d4d75766e686030545464cb393a1a1ac6c68686eae8f8f9 
a9aa4644c8b66d6e1689dcdd2512a994cb35330b0991ad9f9b6b659596a6addd 
d8282fafae5e5323fb8f41d01f76c22fd8061be01bfc041a0323e1002c81cd30 
0b9ec027a0c930014ec035580fc3e112bc069a0b53e11c0c8095f00176c163a0 
e5301baec06a580677600ddc05ba0f13e120bc81a770133ec355a017300d4ec2 
0c7800bbe1219c02fa08f3e13c1c85dbb00a2ec05ea0dff00a6ec15a98027360 
070c047a06d7e1085c84f1b014f6c03fa0b33018b6c0211801ebe018fc00da0a 
6f61113c877eb01d4ec317a085700f26c130f80efbe132bc039a0733e106fc81 
f7f017f6c10aa0d1300a0ec374780943e1382c06fa0a9b60238c83473016cec0 
02f80f73fefe1072afc1e50000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basi6a08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000200806000001047d4a 
620000000467414d41000186a031e8965f0000012049444154789cc595414ec3 
3010459fa541b8bbb26641b8069b861e8b4d12c1c112c1452a710a2a65d840d5 
949041fc481ec98ae27c7f3f8d27e3e4648047600fec0d1f390fbbe2633a31e2 
9389e4e4ea7bfdbf3d9a6b800ab89f1bd6b553cfcbb0679e960563d72e0a9293 
b7337b9f988cc67f5f0e186d20e808042f1c97054e1309da40d02d7e27f92e03 
6cbfc64df0fc3117a6210a1b6ad1a00df21c1abcf2a01944c7101b0cb568a001 
909c9cf9e399cf3d8d9d4660a875405d9a60d000b05e2de55e25780b7a5268e0 
622118e2399aab063a815808462f1ab86890fc2e03e48bb109ded7d26ce4bf59 
0db91bac0050747fec5015ce80da0e5700281be533f0ce6d5900b59bcb00ea6d 
200314cf801faab200ea752803a8d7a90c503a039f824a53f4694e7342000000 
0049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn0g01&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000200000002001000000005b0147 
590000000467414d41000186a031e8965f0000005b49444154789c2dccb10903 
300c05d1ebd204b24a200b7a346f90153c82c18d0a61450751f1e08a2faaead2 
a4846ccea9255306e753345712e211b221bf4b263d1b427325255e8bdab29e6f 
6aca30692e9d29616ee96f3065f0bf1f1087492fd02f14c90000000049454e44 
ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn0g02&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000200000002002000000001ca13d 
890000000467414d41000186a031e8965f0000001f49444154789c6360085df5 
1f8cf1308850c20053868f0133091f6390b90700bd497f818b0989a900000000 
49454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s0"># A version of basn0g04 dithered down to 3 bits.</span>
    <span class="s3">&quot;Basn0g03&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020040000000093e1c8 
2900000001734249540371d88211000000fd49444154789c6d90d18906210c84 
c356f22356b2889588604301b112112b11d94a96bb495cf7fe87f32d996f2689 
44741cc658e39c0b118f883e1f63cc89dafbc04c0f619d7d898396c54b875517 
83f3a2e7ac09a2074430e7f497f00f1138a5444f82839c5206b1f51053cca968 
63258821e7f2b5438aac16fbecc052b646e709de45cf18996b29648508728612 
952ca606a73566d44612b876845e9a347084ea4868d2907ff06be4436c4b41a3 
a3e1774285614c5affb40dbd931a526619d9fa18e4c2be420858de1df0e69893 
a0e3e5523461be448561001042b7d4a15309ce2c57aef2ba89d1c13794a109d7 
b5880aa27744fc5c4aecb5e7bcef5fe528ec6293a930690000000049454e44ae 
426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn0g04&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020040000000093e1c8 
290000000467414d41000186a031e8965f0000004849444154789c6360601014 
545232367671090d4d4b2b2f6720430095dbd1418e002a77e64c720450b9ab56 
912380caddbd9b1c0154ee9933e408a072efde25470095fbee1d1902001f14ee 
01eaff41fa0000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn0g08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000200800000000561125 
280000000467414d41000186a031e8965f0000004149444154789c6364602400 
1408c8b30c05058c0f0829f8f71f3f6079301c1430ca11906764a2795c0c0605 
8c8ff0cafeffcff887e67131181430cae0956564040050e5fe7135e2d8590000 
000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn0g16&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000200000002010000000000681f9 
6b0000000467414d41000186a031e8965f0000005e49444154789cd5d2310ac0 
300c4351395bef7fc6dca093c0287b32d52a04a3d98f3f3880a7b857131363a0 
3a82601d089900dd82f640ca04e816dc06422640b7a03d903201ba05b7819009 
d02d680fa44c603f6f07ec4ff41938cf7f0016d84bd85fae2b9fd70000000049 
454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn2c08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000200802000000fc18ed 
a30000000467414d41000186a031e8965f0000004849444154789cedd5c10900 
300c024085ec91fdb772133b442bf4a1f8cee12bb40d043b800a14f81ca0ede4 
7d4c784081020f4a871fc284071428f0a0743823a94081bb7077a3c00182b1f9 
5e0f40cf4b0000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn2c16&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000201002000000ac8831 
e00000000467414d41000186a031e8965f000000e549444154789cd596c10a83 
301044a7e0417fcb7eb7fdadf6961e06039286266693cc7a188645e43dd6a08f 
1042003e2fe09aef6472737e183d27335fcee2f35a77b702ebce742870a23397 
f3edf2705dd10160f3b2815fe8ecf2027974a6b0c03f74a6e4192843e75c6c03 
35e8ec3202f5e84c0181bbe8cca967a00d9df3491bb040671f2e6087ce1c2860 
8d1e05f8c7ee0f1d00b667e70df44467ef26d01fbd9bc028f42860f71d188bce 
fb8d3630039dbd59601e7ab3c06cf428507f0634d039afdc80123a7bb1801e7a 
b1802a7a14c89f016d74ce331bf080ce9e08f8414f04bca133bfe642fe5e07bb 
c4ec0000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn6a08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000200806000000737a7a 
f40000000467414d41000186a031e8965f0000006f49444154789cedd6310a80 
300c46e12764684fa1f73f55048f21c4ddc545781d52e85028fc1f4d28d98a01 
305e7b7e9cffba33831d75054703ca06a8f90d58a0074e351e227d805c8254e3 
1bb0420f5cdc2e0079208892ffe2a00136a07b4007943c1004d900195036407f 
011bf00052201a9c160fb84c0000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;cs3n3p08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020080300000044a48a 
c60000000467414d41000186a031e8965f0000000373424954030303a392a042 
00000054504c544592ff0000ff9200ffff00ff0000dbff00ff6dffb600006dff 
b6ff00ff9200dbff000049ffff2400ff000024ff0049ff0000ffdb00ff4900ff 
b6ffff0000ff2400b6ffffdb000092ffff6d000024ffff49006dff00df702b17 
0000004b49444154789c85cac70182000000b1b3625754b0edbfa72324ef7486 
184ed0177a437b680bcdd0031c0ed00ea21f74852ed00a1c9ed0086da0057487 
6ed0121cd6d004bda0013a421ff803224033e177f4ae260000000049454e44ae 
426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;s09n3p02&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d49484452000000090000000902030000009dffee 
830000000467414d41000186a031e8965f000000037342495404040477f8b5a3 
0000000c504c544500ff000077ffff00ffff7700ff5600640000001f49444154 
789c63600002fbff0c0c56ab19182ca381581a4283f82071200000696505c36a 
437f230000000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;tbgn3p08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020080300000044a48a 
c60000000467414d41000186a031e8965f00000207504c54457f7f7fafafafab 
abab110000222200737300999999510d00444400959500959595e6e600919191 
8d8d8d620d00898989666600b7b700911600000000730d007373736f6f6faaaa 
006b6b6b676767c41a00cccc0000f30000ef00d51e0055555567670000dd0051 
515100d1004d4d4de61e0038380000b700160d0d00ab00560d00090900009500 
009100008d003333332f2f2f2f2b2f2b2b000077007c7c001a05002b27000073 
002b2b2b006f00bb1600272727780d002323230055004d4d00cc1e00004d00cc 
1a000d00003c09006f6f00002f003811271111110d0d0d55554d090909001100 
4d0900050505000d00e2e200000900000500626200a6a6a6a2a2a29e9e9e8484 
00fb00fbd5d500801100800d00ea00ea555500a6a600e600e6f7f700e200e233 
0500888888d900d9848484c01a007777003c3c05c8c8008080804409007c7c7c 
bb00bbaa00aaa600a61e09056262629e009e9a009af322005e5e5e05050000ee 
005a5a5adddd00a616008d008d00e20016050027270088110078780000c40078 
00787300736f006f44444400aa00c81e004040406600663c3c3c090000550055 
1a1a00343434d91e000084004d004d007c004500453c3c00ea1e00222222113c 
113300331e1e1efb22001a1a1a004400afaf00270027003c001616161e001e0d 
160d2f2f00808000001e00d1d1001100110d000db7b7b7090009050005b3b3b3 
6d34c4230000000174524e530040e6d86600000001624b474402660b7c640000 
01f249444154789c6360c0048c8c58049100575f215ee92e6161ef109cd2a15e 
4b9645ce5d2c8f433aa4c24f3cbd4c98833b2314ab74a186f094b9c2c27571d2 
6a2a58e4253c5cda8559057a392363854db4d9d0641973660b0b0bb76bb16656 
06970997256877a07a95c75a1804b2fbcd128c80b482a0b0300f8a824276a9a8 
ec6e61612b3e57ee06fbf0009619d5fac846ac5c60ed20e754921625a2daadc6 
1967e29e97d2239c8aec7e61fdeca9cecebef54eb36c848517164514af16169e 
866444b2b0b7b55534c815cc2ec22d89cd1353800a8473100a4485852d924a6a 
412adc74e7ad1016ceed043267238c901716f633a812022998a4072267c4af02 
92127005c0f811b62830054935ce017b38bf0948cc5c09955f030a24617d9d46 
63371fd940b0827931cbfdf4956076ac018b592f72d45594a9b1f307f3261b1a 
084bc2ad50018b1900719ba6ba4ca325d0427d3f6161449486f981144cf3100e 
2a5f2a1ce8683e4ddf1b64275240c8438d98af0c729bbe07982b8a1c94201dc2 
b3174c9820bcc06201585ad81b25b64a2146384e3798290c05ad280a18c0a62e 
e898260c07fca80a24c076cc864b777131a00190cdfa3069035eccbc038c30e1 
3e88b46d16b6acc5380d6ac202511c392f4b789aa7b0b08718765990111606c2 
9e854c38e5191878fbe471e749b0112bb18902008dc473b2b2e8e72700000000 
49454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;Tp2n3p08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020080300000044a48a 
c60000000467414d41000186a031e8965f00000300504c544502ffff80ff05ff 
7f0703ff7f0180ff04ff00ffff06ff000880ff05ff7f07ffff06ff000804ff00 
0180ff02ffff03ff7f02ffff80ff0503ff7f0180ffff0008ff7f0704ff00ffff 
06ff000802ffffff7f0704ff0003ff7fffff0680ff050180ff04ff000180ffff 
0008ffff0603ff7f80ff05ff7f0702ffffff000880ff05ffff0603ff7f02ffff 
ff7f070180ff04ff00ffff06ff000880ff050180ffff7f0702ffff04ff0003ff 
7fff7f0704ff0003ff7f0180ffffff06ff000880ff0502ffffffff0603ff7fff 
7f0702ffff04ff000180ff80ff05ff0008ff7f07ffff0680ff0504ff00ff0008 
0180ff03ff7f02ffff02ffffffff0604ff0003ff7f0180ffff000880ff05ff7f 
0780ff05ff00080180ff02ffffff7f0703ff7fffff0604ff00ff7f07ff0008ff 
ff0680ff0504ff0002ffff0180ff03ff7fff0008ffff0680ff0504ff000180ff 
02ffff03ff7fff7f070180ff02ffff04ff00ffff06ff0008ff7f0780ff0503ff 
7fffff06ff0008ff7f0780ff0502ffff03ff7f0180ff04ff0002ffffff7f07ff 
ff0604ff0003ff7fff00080180ff80ff05ffff0603ff7f0180ffff000804ff00 
80ff0502ffffff7f0780ff05ffff0604ff000180ffff000802ffffff7f0703ff 
7fff0008ff7f070180ff03ff7f02ffff80ff05ffff0604ff00ff0008ffff0602 
ffff0180ff04ff0003ff7f80ff05ff7f070180ff04ff00ff7f0780ff0502ffff 
ff000803ff7fffff0602ffffff7f07ffff0680ff05ff000804ff0003ff7f0180 
ff02ffff0180ffff7f0703ff7fff000804ff0080ff05ffff0602ffff04ff00ff 
ff0603ff7fff7f070180ff80ff05ff000803ff7f0180ffff7f0702ffffff0008 
04ff00ffff0680ff0503ff7f0180ff04ff0080ff05ffff06ff000802ffffff7f 
0780ff05ff0008ff7f070180ff03ff7f04ff0002ffffffff0604ff00ff7f07ff 
000880ff05ffff060180ff02ffff03ff7f80ff05ffff0602ffff0180ff03ff7f 
04ff00ff7f07ff00080180ffff000880ff0502ffff04ff00ff7f0703ff7fffff 
06ff0008ffff0604ff00ff7f0780ff0502ffff03ff7f0180ffdeb83387000000 
f874524e53000000000000000008080808080808081010101010101010181818 
1818181818202020202020202029292929292929293131313131313131393939 
393939393941414141414141414a4a4a4a4a4a4a4a52525252525252525a5a5a 
5a5a5a5a5a62626262626262626a6a6a6a6a6a6a6a73737373737373737b7b7b 
7b7b7b7b7b83838383838383838b8b8b8b8b8b8b8b94949494949494949c9c9c 
9c9c9c9c9ca4a4a4a4a4a4a4a4acacacacacacacacb4b4b4b4b4b4b4b4bdbdbd 
bdbdbdbdbdc5c5c5c5c5c5c5c5cdcdcdcdcdcdcdcdd5d5d5d5d5d5d5d5dedede 
dededededee6e6e6e6e6e6e6e6eeeeeeeeeeeeeeeef6f6f6f6f6f6f6f6b98ac5 
ca0000012c49444154789c6360e7169150d230b475f7098d4ccc28a96ced9e32 
63c1da2d7b8e9fb97af3d1fb8f3f18e8a0808953544a4dd7c4c2c9233c2621bf 
b4aab17fdacce5ab36ee3a72eafaad87efbefea68702362e7159652d031b07cf 
c0b8a4cce28aa68e89f316aedfb4ffd0b92bf79fbcfcfe931e0a183904e55435 
8decdcbcc22292b3caaadb7b27cc5db67af3be63e72fdf78fce2d31f7a2860e5 
119356d037b374f10e8a4fc92eaa6fee99347fc9caad7b0f9ebd74f7c1db2fbf 
e8a180995f484645dbdccad12f38363dafbcb6a573faeca5ebb6ed3e7ce2c29d 
e76fbefda38702063e0149751d537b67ff80e8d4dcc29a86bea97316add9b0e3 
c0e96bf79ebdfafc971e0a587885e515f58cad5d7d43a2d2720aeadaba26cf5a 
bc62fbcea3272fde7efafac37f3a28000087c0fe101bc2f85f0000000049454e 
44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;tbbn1g04&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020040000000093e1c8 
290000000467414d41000186a031e8965f0000000274524e530007e8f7589b00 
000002624b47440000aa8d23320000013e49444154789c55d1cd4b024118c7f1 
efbe6419045b6a48a72d352808b435284f9187ae9b098627a1573a19945beba5 
e8129e8222af11d81e3a4545742de8ef6af6d5762e0fbf0fc33c33f36085cb76 
bc4204778771b867260683ee57e13f0c922df5c719c2b3b6c6c25b2382cea4b9 
9f7d4f244370746ac71f4ca88e0f173a6496749af47de8e44ba8f3bf9bdfa98a 
0faf857a7dd95c7dc8d7c67c782c99727997f41eb2e3c1e554152465bb00fe8e 
b692d190b718d159f4c0a45c4435915a243c58a7a4312a7a57913f05747594c6 
46169866c57101e4d4ce4d511423119c419183a3530cc63db88559ae28e7342a 
1e9c8122b71139b8872d6e913153224bc1f35b60e4445bd4004e20ed6682c759 
1d9873b3da0fbf50137dc5c9bde84fdb2ec8bde1189e0448b63584735993c209 
7a601bd2710caceba6158797285b7f2084a2f82c57c01a0000000049454e44ae 
426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;tbrn2c08&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d4948445200000020000000200802000000fc18ed 
a30000000467414d41000186a031e8965f0000000674524e53007f007f007f8a 
33334f00000006624b474400ff0000000033277cf3000004d649444154789cad 
965f68537714c73fd912d640235e692f34d0406fa0c1663481045ab060065514 
56660a295831607df0a1488715167060840a1614e6431e9cb34fd2c00a762c85 
f6a10f816650c13b0cf40612e1822ddc4863bd628a8924d23d6464f9d3665dd9 
f7e977ce3dbff3cd3939bfdfef6bb87dfb364782dbed065ebe7cd93acc78b4ec 
a228debd7bb7bfbfbfbbbbfb7f261045311a8d261209405194274f9ea4d3e916 
f15f1c3eb5dd6e4fa5fecce526239184a2b0b8486f6f617171b1f5ae4311381c 
8e57af5e5dbd7a351088150a78bd389d44222c2f93cdfe66b7db8f4ee07038b6 
b6b6bebf766d7e7e7e60a06432313b4ba984c3c1c4049a46b95c5a58583822c1 
dbb76f27272733d1b9df853c3030c0f232562b9108cf9eb1b888d7cbf030abab 
31abd5fa1f08dc6ef7e7cf9f1f3f7e1c8944745d4f1400c62c001313acad21cb 
b8dd2c2c603271eb1640341aad4c6d331aa7e8c48913a150a861307ecc11e964 
74899919bc5e14e56fffc404f1388502f178dceff7ef4bf0a5cfe7abb533998c 
e5f9ea2f1dd88c180d64cb94412df3dd57e83a6b3b3c7a84c98420100c72fd3a 
636348bae726379fe69e8e8d8dbd79f3a6558b0607079796965256479b918085 
7b02db12712b6181950233023f3f647494ee6e2e5ea45864cce5b8a7fe3acffc 
3aebb22c2bd5d20e22d0757d7b7bbbbdbd3d94a313bed1b0aa3cd069838b163a 
8d4c59585f677292d0b84d9a995bd337def3fe6bbe5e6001989b9b6bfe27ea08 
36373781542ab56573248b4c5bc843ac4048c7ab21aa24ca00534c25482828a3 
8c9ee67475bbaaaab22cb722c8e57240a150301a8d219de94e44534d7d90e885 
87acb0e2c4f9800731629b6c5ee14a35a6b9887d2a0032994cb9cf15dbe59650 
ff7b46a04c9a749e7cc5112214266cc65c31354d5b5d5d3d90209bcd5616a552 
a95c2e87f2a659bd9ee01c2cd73964e438f129a6aa9e582c363838b80f81d7eb 
5555b56a2a8ad2d9d7affd0409f8015c208013fea00177b873831b0282c964f2 
783c1e8fa7582cee5f81a669b5e6eeeeaee58e8559b0c233d8843c7c0b963a82 
34e94b5cb2396d7d7d7db22c8ba258fb0afd43f0e2c58b919191ba9de9b4d425 
118329b0c3323c8709d02041b52b4ea7f39de75d2a934a2693c0a953a76a93d4 
5d157ebf7f6565a5542a553df97c5e10045dd731c130b86113cc300cbd489224 
08422a952a140a95788fc763b1d41558d7a2d7af5f5fb870a1d6a3aaaacd6603 
18802da84c59015bd2e6897b745d9765b99a1df0f97c0daf74e36deaf7fbcd66 
73ad2797cb89a2c839880188a2e8743a8bc5a22ccbba5e376466b3b9bdbdbd21 
6123413a9d0e0402b51e4dd3bababa788eb022b85caeb6b6364551b6b7b76942 
43f7f727007a7a7a04a1ee8065b3595fde2768423299ac1ec6669c3973e65004 
c0f8f878ad69341a33994ced2969c0d0d0502412f9f8f163f3a7fd654b474787 
288ad53e74757535df6215b85cae60302849d2410aecc037f9f2e5cbd5b5c160 
680eb0dbede170381c0e7ff8f0a185be3b906068684892a4ca7a6f6faff69328 
8ad3d3d3f7efdfdfdbdbfb57e96868a14d0d0643381c96242997cbe5f3794010 
84603078fcf8f1d6496bd14a3aba5c2ea7d369341a5555b5582c8140e0fcf9f3 
1b1b1b87cf4eeb0a8063c78e45a3d19e9e1ebfdfdf5a831e844655d18093274f 
9e3d7bf6d3a74f3b3b3b47c80efc05ff7af28fefb70d9b0000000049454e44ae 
426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
    <span class="s3">&quot;basn6a16&quot;</span><span class="s1">: _dehex(</span>
        <span class="s3">&quot;&quot;&quot; 
89504e470d0a1a0a0000000d494844520000002000000020100600000023eaa6 
b70000000467414d41000186a031e8965f00000d2249444154789cdd995f6c1c 
d775c67ff38fb34b724d2ee55a8e4b04a0ac87049100cab4dbd8c6528902cb4d 
10881620592e52d4325ac0905bc98a94025e71fd622cb5065ac98a0c283050c0 
728a00b6e542a1d126885cd3298928891d9a0444037e904434951d4b90b84b2f 
c9dde1fcebc33977a95555348f411e16dfce9d3b77ee77eebde77ce78c95a669 
0ad07c17009a13edd898b87dfb1fcb7d2b4d1bff217f33df80deb1e6267df0ff 
c1e6e6dfafdf1f5a7fd30f9aef66b6d546dd355bf02c40662e3307f9725a96c6 
744c3031f83782f171c148dbc3bf1774f5dad1e79d6f095a3f54d4fbec5234ef 
d9a2f8d73afe4f14f57ef4f42def7b44f19060f06b45bddf1c5534d77fd922be 
2973a15a82e648661c6e3240aa3612ead952b604bde57458894f29deaf133bac 
13d2766f5227a4a3b8cf08da7adfd6fbd6bd8a4fe9dbb43d35e3dfa3f844fbf8 
9119bf4f7144094fb56333abf8a86063ca106f94b3a3b512343765e60082097f 
1bb86ba72439a653519b09f5cee1ce61c897d37eedf5553580ae60f4af8af33a 
b14fd400b6a0f34535c0434afc0b3a9f07147527a5fa7ca218ff56c74d74dc3f 
155cfd3325fc278acf2ae1cb4a539f5f9937c457263b0bd51234c732a300cdd1 
cc1840f0aaff54db0e4874ed5a9b5d6d27d4bb36746d80de72baa877ff4b275a 
d7895ed1897ea4139b5143fcbb1a62560da1ed9662aaed895ec78a91c18795b8 
5e07ab4af8ba128e95e682e0728bf8f2e5ae815a091a53d902ac1920d8e05f06 
589de8d8d66680789f4e454fb9d9ec66cd857af796ee2d902fa73fd5bba775a2 
153580ae44705ed0d37647d15697cb8f14bfa3e3e8fdf8031d47af571503357c 
f30d25acedcbbf135c9a35c49766ba07ab255859e8ec03684e66860182dff8f7 
0304bff6ff1c20fc81b7afdd00a71475539a536e36bb5973a19e3b923b02bde5 
e4efd4003ac170eb2d13fe274157afedbd82d6fb3a9a1e85e4551d47cf7078f8 
9671fe4289ebf5f2bf08d63f37c4eb4773c55a0996efeefa0ca011671d8060ca 
2f0004c7fcc300e166ef0240f825efe3361f106d57d423d0723f7acacd66376b 
2ed47b7a7a7a205f4ef4ac4691e0aad9aa0d41cf13741c3580a506487574ddca 
61a8c403c1863ebfbcac3475168b2de28b8b3d77544bb05ce92a02aceced3c0d 
d0cc65ea371b201cf1c601c24dde1c4078cedbdeb60322f50126a019bf6edc9b 
39e566b39b3517eaf97c3e0fbde5e4491d45bd74537145d155b476aa0176e868 
c6abebf30dbd5e525c54ac8e18e2d56abeb756827a3d970358a97416019a6f64 
f60004fdfe1580d5c98e618070cc1b05887eee7e0d209a70db7d8063029889b4 
c620ead78d7b33a7dc6c76b3e6427ddddbebde867c393aa7845e5403e8ca794a 
d0d6fb897af5f03525fe5782f5e7046bdaef468bf88d1debc6ab25583cd17310 
6079b9ab0ba059c914018245bf076075b5a303200c3c1f209a733701444fbbaf 
00c4134ebb016c5d0b23614c243701cdf875e3decce9349bddacb9505fbf7dfd 
76e82d87736a00f5d2b5ffd4b7dce2719a4d25ae717ee153c1abef18e257cfad 
7fa45682da48ef38c052b53b0fd06864b300c151ff08c0ea431de701a287dd5f 
004497dc7b01a253ee3e80b8c7f91c20f967fb6fdb7c80ada7d8683723614c24 
3701cdf875e3decc29379bddacb950ef3fd47f08f2e5a61ea4aa2a3eb757cd55 
13345efcfa59c12b2f19e2578ef77fb75a82854ffbee01a83f977b11a031931d 
040802df07082b5e11207cc17b1e209a770700e2df0a83e409fb7580f827c230 
99b06fd901fb058d6835dacd481813c94d40337eddb83773cacd66376b2ed437 
bebcf165e82d2f4e4beb7f3fa6e652c2d7ee10bc78c010bfb87fe3c95a09ae9f 
bd732740bd2fb700d0f865f64180e059ff044018ca0ca28a5b04883f701e0088 
bfec7c0c909cb71f0448c6ec518074b375012079d9dedf66004bcfbc51eb2dd1 
aadacd481813c94d40337eddb83773cacd66376b2ed487868686205fbe7c49ef 
5605a73f34c4a7a787eeab96e0da81bb4e022c15ba27019a5b339300e16bf286 
a8eae601e25866907cdf3e0890acb36f00245fb57f05904e59c300e92561946e 
b2e600d209ab7d07f04d458dfb46ad1bd16ab49b913026929b8066fcba716fe6 
949bcd6ed65ca8ef7e7cf7e3d05b7e7c8f217ee6cdddbb6a25a856f37980e0c7 
fe4e80a82623c48193014846ec7180f4acf518409aca0cd28a5504e03b32c374 
de1a00608a0240faaa327a4b19fe946fb6f90054dbb5f2333d022db56eb4966a 
3723614c243701cdf8f556bea8a7dc6c76b3e66bd46584ddbbcebc0990cf4b0f 
ff4070520c282338a7e26700ec725202b01e4bcf0258963c6f1d4d8f0030cb20 
805549c520930c03584fa522b676f11600ffc03fde3e1b3489a9c9054c9aa23b 
c08856a3dd8c843191dc0434e3d78d7b33a75c36fb993761f7ae5a69f72ef97f 
e6ad336fed7e1c60e8bee96980bbdebbb60da07b7069062033d9dc0ae03d296f 
70ab511ec071640676252902d833c916007b3e1900b0a6d2028035968e025861 
ea01581369fb11488c34d18cbc95989afccca42baad65ba2d5683723614c24d7 
8066fcbab8b7e96918baaf5aaa56219f975fb50a43f7c9bde90fa73f1c1a02d8 
78f2e27e803b77ca08b90519315b6fe400fc1392097a9eccc0ad444500e70199 
a1331f0f00d8934901c07e5d526ceb87c2d07e2579badd005a2b31a5089391b7 
1253358049535a6add8856dd0146c298482e01ede27ed878b256ba7600ee3a09 
c18fc1df09fe01084ec25defc1b56db0f1a4f4bd78e0e2818d2f0334e7330300 
7df7c888b917e50dd9c1c60c80efcb0cbc63e1f700bce7c31700dccbd1060027 
8add9b0de06c8e2f00d84962b7d7030e2a61538331b98051f92631bd253f336a 
dd8856a3dd44c25c390efddfad96ae9f853b77c25201ba27c533b8bdf28b6ad0 
3d084b33d2e7fa59099e9901b8f2d29597fa0f01848f78e70082117f1ca07b76 
6910209b9519f895a008d031bbba05c09d8f06005c5b18b8fba25300cea6780e 
c03e911c6ccf06d507b48a4fa606634a114609de929f9934c5a87511ad57cfc1 
fa476aa5854fa1ef1e3910b905686e85cc24c40138198915f133d2d6dc2a7dea 
7df2ccc2a752faf2cec1d577aebeb37e3b4034eeee0008dff3be0e6b923773b4 
7904c0ef9119767cb4fa1500ef1361e08e452500f71561e84cc4ed3e20fab6a2 
c905f40cb76a3026bf3319b91ac2e46792a6dcd801ebc6aba5da08f48ecb81c8 
bd088d5f42f6417191de93908c803d0e76199292b485af41b60e8d9c3c537f0e 
8211f0c7211a077707dc18b931b2ee6d80a4d7ae024491ebc24d4a708ff70680 
7f25e807e8785f1878e322d6ddaf453f0770ff2dfa769b01423dbbad72a391b6 
5a7c3235985629423372494cab55c8f7d64a8b27a0e7202c55a13b0f8d19c80e 
4ae9ca3f015115dc3ca467c17a4c7ee95970ab10e5a54ff0ac3cd39881ee5958 
1a84f03df0be0e492fd855a8d6aa35d10b4962dbb0a604a3d3ee5e80a8eee600 
a24977f8660378bf0bbf00e01d0a8fb7f980f04b8aa6ce6aca8d5a7533c52753 
839152c4e222f4dc512dd5eb90cbc981e8ea12cf90cd8a8bf47d89159e2741d3 
7124f65b96fcd254dae258fa84a13c13043246a32129574787e49eae2b49b86d 
c3e2e78b9ff7f4002415bb08907c66df0d103b4e0c104db90500ff70700c203a 
ee1e82dba4c3e16e256c0acca6ceaae9afd1f612d7eb472157ac95962bd05594 
7dd1598466053245088e827f44628657942a825b84e4fb601f84b4025611aca3 
901e01bb024911dc0a4445f08e41f83df02b10142173149ab71baf027611ea95 
7a257704201d14cd9af4d90b00f194530088cb4e09c0df1c5c0088f7393f6833 
c0aa3ac156655de3bca9b34ab9716906ba07aba5e5bba1eb3358d90b9da7c533 
64f6888bf47b60f521e8380fe10be03d2feac17900927560df40f4e48f805960 
50328d648bf4893f9067c217a0631656b7c898c122847bc07b03a2d3e0ee85e4 
33b0ef867450c4fad2ecd26cf7168074c0ba0c904cdac300c9cfec4701924df6 
1cdca61e10685c6f7d52d0caba1498972f43d740adb4b2009d7d7220b20e3473 
90a943d00ffe959bb6eac3e0fe42ea49ee00c45f06e76329b1dabf127d690d80 
5581b408f63c2403e0cc433c00ee658836803b0fd100747c04ab5f917704fd10 
d5c1cd41ec801343d207f602a403605d86e5f9e5f9ae0d00e994556833806685 
c931fb709b0f08b4e869bea5c827859549e82c544b8d29c816a0390999613920 
7e610d5727a16318c2003c1fa24be0de2b32caf92224e7c17e5004b6350c4c01 
05601218066b0ad28224e149019c086257ca315102de2712903bde97b8144d82 
3b2c6ac52d403c054e019249b087f53d0558995a99ea946c70cc927458b3c1ff 
550f30050df988d4284376b4566a8e416654cc921985e037e0df0fc131f00f4b 
acf0c6211c036f14a239703741740adc7da227edd7e56b833d0ae92549b4d357 
25dfb49ed2ff63908e6adf27d6d0dda7638d4154d2778daca17f58e61297c129 
41f233b01f5dc3740cac51688c35c6b22580f48224fee9b83502569a66b629f1 
09f3713473413e2666e7fe6f6c6efefdfafda1f56f6e06f93496d9d67cb7366a 
9964b6f92e64b689196ec6c604646fd3fe4771ff1bf03f65d8ecc3addbb5f300 
00000049454e44ae426082 
&quot;&quot;&quot;</span>
    <span class="s1">)</span><span class="s4">,</span>
<span class="s1">}</span>


<span class="s4">def </span><span class="s1">test_suite(options</span><span class="s4">, </span><span class="s1">args):</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a PNG test image and write the file to stdout. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Below is a big stack of test image generators.</span>
    <span class="s0"># They're all really tiny, so PEP 8 rules are suspended.</span>

    <span class="s4">def </span><span class="s1">test_gradient_horizontal_lr(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">test_gradient_horizontal_rl(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s5">1 </span><span class="s1">- x</span>

    <span class="s4">def </span><span class="s1">test_gradient_vertical_tb(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">y</span>

    <span class="s4">def </span><span class="s1">test_gradient_vertical_bt(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s5">1 </span><span class="s1">- y</span>

    <span class="s4">def </span><span class="s1">test_radial_tl(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">max(</span><span class="s5">1 </span><span class="s1">- math.sqrt(x * x + y * y)</span><span class="s4">, </span><span class="s5">0.0</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_radial_center(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_radial_tl(x - </span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">y - </span><span class="s5">0.5</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_radial_tr(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_radial_tl(</span><span class="s5">1 </span><span class="s1">- x</span><span class="s4">, </span><span class="s1">y)</span>

    <span class="s4">def </span><span class="s1">test_radial_bl(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_radial_tl(x</span><span class="s4">, </span><span class="s5">1 </span><span class="s1">- y)</span>

    <span class="s4">def </span><span class="s1">test_radial_br(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_radial_tl(</span><span class="s5">1 </span><span class="s1">- x</span><span class="s4">, </span><span class="s5">1 </span><span class="s1">- y)</span>

    <span class="s4">def </span><span class="s1">test_stripe(x</span><span class="s4">, </span><span class="s1">n):</span>
        <span class="s4">return </span><span class="s1">float(int(x * n) &amp; </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_h_2(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(x</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_h_4(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(x</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_h_10(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(x</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_v_2(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(y</span><span class="s4">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_v_4(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(y</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_v_10(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(y</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_lr_10(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(x + y</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_stripe_rl_10(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_stripe(</span><span class="s5">1 </span><span class="s1">+ x - y</span><span class="s4">, </span><span class="s5">10</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_checker(x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">n):</span>
        <span class="s4">return </span><span class="s1">float((int(x * n) &amp; </span><span class="s5">1</span><span class="s1">) ^ (int(y * n) &amp; </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s4">def </span><span class="s1">test_checker_8(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_checker(x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s5">8</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_checker_15(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s1">test_checker(x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s5">15</span><span class="s1">)</span>

    <span class="s4">def </span><span class="s1">test_zero(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s5">0</span>

    <span class="s4">def </span><span class="s1">test_one(x</span><span class="s4">, </span><span class="s1">y):</span>
        <span class="s4">return </span><span class="s5">1</span>

    <span class="s1">test_patterns = {</span>
        <span class="s3">&quot;GLR&quot;</span><span class="s1">: test_gradient_horizontal_lr</span><span class="s4">,</span>
        <span class="s3">&quot;GRL&quot;</span><span class="s1">: test_gradient_horizontal_rl</span><span class="s4">,</span>
        <span class="s3">&quot;GTB&quot;</span><span class="s1">: test_gradient_vertical_tb</span><span class="s4">,</span>
        <span class="s3">&quot;GBT&quot;</span><span class="s1">: test_gradient_vertical_bt</span><span class="s4">,</span>
        <span class="s3">&quot;RTL&quot;</span><span class="s1">: test_radial_tl</span><span class="s4">,</span>
        <span class="s3">&quot;RTR&quot;</span><span class="s1">: test_radial_tr</span><span class="s4">,</span>
        <span class="s3">&quot;RBL&quot;</span><span class="s1">: test_radial_bl</span><span class="s4">,</span>
        <span class="s3">&quot;RBR&quot;</span><span class="s1">: test_radial_br</span><span class="s4">,</span>
        <span class="s3">&quot;RCTR&quot;</span><span class="s1">: test_radial_center</span><span class="s4">,</span>
        <span class="s3">&quot;HS2&quot;</span><span class="s1">: test_stripe_h_2</span><span class="s4">,</span>
        <span class="s3">&quot;HS4&quot;</span><span class="s1">: test_stripe_h_4</span><span class="s4">,</span>
        <span class="s3">&quot;HS10&quot;</span><span class="s1">: test_stripe_h_10</span><span class="s4">,</span>
        <span class="s3">&quot;VS2&quot;</span><span class="s1">: test_stripe_v_2</span><span class="s4">,</span>
        <span class="s3">&quot;VS4&quot;</span><span class="s1">: test_stripe_v_4</span><span class="s4">,</span>
        <span class="s3">&quot;VS10&quot;</span><span class="s1">: test_stripe_v_10</span><span class="s4">,</span>
        <span class="s3">&quot;LRS&quot;</span><span class="s1">: test_stripe_lr_10</span><span class="s4">,</span>
        <span class="s3">&quot;RLS&quot;</span><span class="s1">: test_stripe_rl_10</span><span class="s4">,</span>
        <span class="s3">&quot;CK8&quot;</span><span class="s1">: test_checker_8</span><span class="s4">,</span>
        <span class="s3">&quot;CK15&quot;</span><span class="s1">: test_checker_15</span><span class="s4">,</span>
        <span class="s3">&quot;ZERO&quot;</span><span class="s1">: test_zero</span><span class="s4">,</span>
        <span class="s3">&quot;ONE&quot;</span><span class="s1">: test_one</span><span class="s4">,</span>
    <span class="s1">}</span>

    <span class="s4">def </span><span class="s1">test_pattern(width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">bitdepth</span><span class="s4">, </span><span class="s1">pattern):</span>
        <span class="s2">&quot;&quot;&quot;Create a single plane (monochrome) test pattern.  Returns a 
        flat row flat pixel array. 
        &quot;&quot;&quot;</span>

        <span class="s1">maxval = </span><span class="s5">2</span><span class="s1">**bitdepth - </span><span class="s5">1</span>
        <span class="s4">if </span><span class="s1">maxval &gt; </span><span class="s5">255</span><span class="s1">:</span>
            <span class="s1">a = array(</span><span class="s3">&quot;H&quot;</span><span class="s1">)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">a = array(</span><span class="s3">&quot;B&quot;</span><span class="s1">)</span>
        <span class="s1">fw = float(width)</span>
        <span class="s1">fh = float(height)</span>
        <span class="s1">pfun = test_patterns[pattern]</span>
        <span class="s4">for </span><span class="s1">y </span><span class="s4">in </span><span class="s1">range(height):</span>
            <span class="s1">fy = float(y) / fh</span>
            <span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">range(width):</span>
                <span class="s1">a.append(int(round(pfun(float(x) / fw</span><span class="s4">, </span><span class="s1">fy) * maxval)))</span>
        <span class="s4">return </span><span class="s1">a</span>

    <span class="s4">def </span><span class="s1">test_rgba(size=</span><span class="s5">256</span><span class="s4">, </span><span class="s1">bitdepth=</span><span class="s5">8</span><span class="s4">, </span><span class="s1">red=</span><span class="s3">&quot;GTB&quot;</span><span class="s4">, </span><span class="s1">green=</span><span class="s3">&quot;GLR&quot;</span><span class="s4">, </span><span class="s1">blue=</span><span class="s3">&quot;RTL&quot;</span><span class="s4">, </span><span class="s1">alpha=</span><span class="s4">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a test image.  Each channel is generated from the 
        specified pattern; any channel apart from red can be set to 
        None, which will cause it not to be in the image.  It 
        is possible to create all PNG channel types (L, RGB, LA, RGBA), 
        as well as non PNG channel types (RGA, and so on). 
        &quot;&quot;&quot;</span>

        <span class="s1">i = test_pattern(size</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">bitdepth</span><span class="s4">, </span><span class="s1">red)</span>
        <span class="s1">psize = </span><span class="s5">1</span>
        <span class="s4">for </span><span class="s1">channel </span><span class="s4">in </span><span class="s1">(green</span><span class="s4">, </span><span class="s1">blue</span><span class="s4">, </span><span class="s1">alpha):</span>
            <span class="s4">if </span><span class="s1">channel:</span>
                <span class="s1">c = test_pattern(size</span><span class="s4">, </span><span class="s1">size</span><span class="s4">, </span><span class="s1">bitdepth</span><span class="s4">, </span><span class="s1">channel)</span>
                <span class="s1">i = interleave_planes(i</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">psize</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">psize += </span><span class="s5">1</span>
        <span class="s4">return </span><span class="s1">i</span>

    <span class="s4">def </span><span class="s1">pngsuite_image(name):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a test image by reading an internal copy of the files 
        from the PngSuite.  Returned in flat row flat pixel format. 
        &quot;&quot;&quot;</span>

        <span class="s4">if </span><span class="s1">name </span><span class="s4">not in </span><span class="s1">_pngsuite:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">f&quot;cannot find PngSuite file </span><span class="s4">{</span><span class="s1">name</span><span class="s4">} </span><span class="s3">(use -L for a list)&quot;</span>
            <span class="s1">)</span>
        <span class="s1">r = Reader(bytes=_pngsuite[name])</span>
        <span class="s1">w</span><span class="s4">, </span><span class="s1">h</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = r.asDirect()</span>
        <span class="s4">assert </span><span class="s1">w == h</span>
        <span class="s0"># LAn for n &lt; 8 is a special case for which we need to rescale</span>
        <span class="s0"># the data.</span>
        <span class="s4">if </span><span class="s1">meta[</span><span class="s3">&quot;greyscale&quot;</span><span class="s1">] </span><span class="s4">and </span><span class="s1">meta[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] </span><span class="s4">and </span><span class="s1">meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &lt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s1">factor = </span><span class="s5">255 </span><span class="s1">// (</span><span class="s5">2 </span><span class="s1">** meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s4">def </span><span class="s1">rescale(data):</span>
                <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">data:</span>
                    <span class="s4">yield </span><span class="s1">map(factor.__mul__</span><span class="s4">, </span><span class="s1">row)</span>

            <span class="s1">pixels = rescale(pixels)</span>
            <span class="s1">meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] = </span><span class="s5">8</span>
        <span class="s1">arraycode = </span><span class="s3">&quot;BH&quot;</span><span class="s1">[meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">] &gt; </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s4">return </span><span class="s1">w</span><span class="s4">, </span><span class="s1">array(arraycode</span><span class="s4">, </span><span class="s1">itertools.chain(*pixels))</span><span class="s4">, </span><span class="s1">meta</span>

    <span class="s0"># The body of test_suite()</span>
    <span class="s1">size = </span><span class="s5">256</span>
    <span class="s4">if </span><span class="s1">options.test_size:</span>
        <span class="s1">size = options.test_size</span>
    <span class="s1">options.bitdepth = options.test_depth</span>
    <span class="s1">options.greyscale = bool(options.test_black)</span>

    <span class="s1">kwargs = {}</span>
    <span class="s4">if </span><span class="s1">options.test_red:</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;red&quot;</span><span class="s1">] = options.test_red</span>
    <span class="s4">if </span><span class="s1">options.test_green:</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;green&quot;</span><span class="s1">] = options.test_green</span>
    <span class="s4">if </span><span class="s1">options.test_blue:</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;blue&quot;</span><span class="s1">] = options.test_blue</span>
    <span class="s4">if </span><span class="s1">options.test_alpha:</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">] = options.test_alpha</span>
    <span class="s4">if </span><span class="s1">options.greyscale:</span>
        <span class="s4">if </span><span class="s1">options.test_red </span><span class="s4">or </span><span class="s1">options.test_green </span><span class="s4">or </span><span class="s1">options.test_blue:</span>
            <span class="s4">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;cannot specify colours (R, G, B) when greyscale image (black channel, K) is specified&quot;</span>
            <span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;red&quot;</span><span class="s1">] = options.test_black</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;green&quot;</span><span class="s1">] = </span><span class="s4">None</span>
        <span class="s1">kwargs[</span><span class="s3">&quot;blue&quot;</span><span class="s1">] = </span><span class="s4">None</span>
    <span class="s1">options.alpha = bool(options.test_alpha)</span>
    <span class="s4">if not </span><span class="s1">args:</span>
        <span class="s1">pixels = test_rgba(size</span><span class="s4">, </span><span class="s1">options.bitdepth</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">size</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = pngsuite_image(args[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s4">, </span><span class="s3">&quot;alpha&quot;</span><span class="s4">, </span><span class="s3">&quot;greyscale&quot;</span><span class="s1">]:</span>
            <span class="s1">setattr(options</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">meta[k])</span>

    <span class="s1">writer = Writer(</span>
        <span class="s1">size</span><span class="s4">,</span>
        <span class="s1">size</span><span class="s4">,</span>
        <span class="s1">bitdepth=options.bitdepth</span><span class="s4">,</span>
        <span class="s1">transparent=options.transparent</span><span class="s4">,</span>
        <span class="s1">background=options.background</span><span class="s4">,</span>
        <span class="s1">gamma=options.gamma</span><span class="s4">,</span>
        <span class="s1">greyscale=options.greyscale</span><span class="s4">,</span>
        <span class="s1">alpha=options.alpha</span><span class="s4">,</span>
        <span class="s1">compression=options.compression</span><span class="s4">,</span>
        <span class="s1">interlace=options.interlace</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">writer.write_array(sys.stdout</span><span class="s4">, </span><span class="s1">pixels)</span>


<span class="s4">def </span><span class="s1">read_pam_header(infile):</span>
    <span class="s2">&quot;&quot;&quot; 
    Read (the rest of a) PAM header.  `infile` should be positioned 
    immediately after the initial 'P7' line (at the beginning of the 
    second line).  Returns are as for `read_pnm_header`. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Unlike PBM, PGM, and PPM, we can read the header a line at a time.</span>
    <span class="s1">header = dict()</span>
    <span class="s4">while True</span><span class="s1">:</span>
        <span class="s1">l = infile.readline().strip()</span>
        <span class="s4">if </span><span class="s1">l == strtobytes(</span><span class="s3">&quot;ENDHDR&quot;</span><span class="s1">):</span>
            <span class="s4">break</span>
        <span class="s4">if not </span><span class="s1">l:</span>
            <span class="s4">raise </span><span class="s1">EOFError(</span><span class="s3">&quot;PAM ended prematurely&quot;</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">l[</span><span class="s5">0</span><span class="s1">] == strtobytes(</span><span class="s3">&quot;#&quot;</span><span class="s1">):</span>
            <span class="s4">continue</span>
        <span class="s1">l = l.split(</span><span class="s4">None, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">if </span><span class="s1">l[</span><span class="s5">0</span><span class="s1">] </span><span class="s4">not in </span><span class="s1">header:</span>
            <span class="s1">header[l[</span><span class="s5">0</span><span class="s1">]] = l[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">header[l[</span><span class="s5">0</span><span class="s1">]] += strtobytes(</span><span class="s3">&quot; &quot;</span><span class="s1">) + l[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">required = [</span><span class="s3">&quot;WIDTH&quot;</span><span class="s4">, </span><span class="s3">&quot;HEIGHT&quot;</span><span class="s4">, </span><span class="s3">&quot;DEPTH&quot;</span><span class="s4">, </span><span class="s3">&quot;MAXVAL&quot;</span><span class="s1">]</span>
    <span class="s1">required = [strtobytes(x) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">required]</span>
    <span class="s1">WIDTH</span><span class="s4">, </span><span class="s1">HEIGHT</span><span class="s4">, </span><span class="s1">DEPTH</span><span class="s4">, </span><span class="s1">MAXVAL = required</span>
    <span class="s1">present = [x </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">required </span><span class="s4">if </span><span class="s1">x </span><span class="s4">in </span><span class="s1">header]</span>
    <span class="s4">if </span><span class="s1">len(present) != len(required):</span>
        <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;PAM file must specify WIDTH, HEIGHT, DEPTH, and MAXVAL&quot;</span><span class="s1">)</span>
    <span class="s1">width = int(header[WIDTH])</span>
    <span class="s1">height = int(header[HEIGHT])</span>
    <span class="s1">depth = int(header[DEPTH])</span>
    <span class="s1">maxval = int(header[MAXVAL])</span>
    <span class="s4">if </span><span class="s1">width &lt;= </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">height &lt;= </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">depth &lt;= </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">maxval &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;WIDTH, HEIGHT, DEPTH, MAXVAL must all be positive integers&quot;</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s3">&quot;P7&quot;</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">, </span><span class="s1">maxval</span>


<span class="s4">def </span><span class="s1">read_pnm_header(infile</span><span class="s4">, </span><span class="s1">supported=(</span><span class="s3">&quot;P5&quot;</span><span class="s4">, </span><span class="s3">&quot;P6&quot;</span><span class="s1">)):</span>
    <span class="s2">&quot;&quot;&quot; 
    Read a PNM header, returning (format,width,height,depth,maxval). 
    `width` and `height` are in pixels.  `depth` is the number of 
    channels in the image; for PBM and PGM it is synthesized as 1, for 
    PPM as 3; for PAM images it is read from the header.  `maxval` is 
    synthesized (as 1) for PBM images. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Generally, see http://netpbm.sourceforge.net/doc/ppm.html</span>
    <span class="s0"># and http://netpbm.sourceforge.net/doc/pam.html</span>

    <span class="s1">supported = [strtobytes(x) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">supported]</span>

    <span class="s0"># Technically 'P7' must be followed by a newline, so by using</span>
    <span class="s0"># rstrip() we are being liberal in what we accept.  I think this</span>
    <span class="s0"># is acceptable.</span>
    <span class="s1">type = infile.read(</span><span class="s5">3</span><span class="s1">).rstrip()</span>
    <span class="s4">if </span><span class="s1">type </span><span class="s4">not in </span><span class="s1">supported:</span>
        <span class="s4">raise </span><span class="s1">NotImplementedError(</span><span class="s3">f&quot;file format </span><span class="s4">{</span><span class="s1">type</span><span class="s4">} </span><span class="s3">not supported&quot;</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">type == strtobytes(</span><span class="s3">&quot;P7&quot;</span><span class="s1">):</span>
        <span class="s0"># PAM header parsing is completely different.</span>
        <span class="s4">return </span><span class="s1">read_pam_header(infile)</span>
    <span class="s0"># Expected number of tokens in header (3 for P4, 4 for P6)</span>
    <span class="s1">expected = </span><span class="s5">4</span>
    <span class="s1">pbm = (</span><span class="s3">&quot;P1&quot;</span><span class="s4">, </span><span class="s3">&quot;P4&quot;</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">type </span><span class="s4">in </span><span class="s1">pbm:</span>
        <span class="s1">expected = </span><span class="s5">3</span>
    <span class="s1">header = [type]</span>

    <span class="s0"># We have to read the rest of the header byte by byte because the</span>
    <span class="s0"># final whitespace character (immediately following the MAXVAL in</span>
    <span class="s0"># the case of P6) may not be a newline.  Of course all PNM files in</span>
    <span class="s0"># the wild use a newline at this point, so it's tempting to use</span>
    <span class="s0"># readline; but it would be wrong.</span>
    <span class="s4">def </span><span class="s1">getc():</span>
        <span class="s1">c = infile.read(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4">if not </span><span class="s1">c:</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">&quot;premature EOF reading PNM header&quot;</span><span class="s1">)</span>
        <span class="s4">return </span><span class="s1">c</span>

    <span class="s1">c = getc()</span>
    <span class="s4">while True</span><span class="s1">:</span>
        <span class="s0"># Skip whitespace that precedes a token.</span>
        <span class="s4">while </span><span class="s1">c.isspace():</span>
            <span class="s1">c = getc()</span>
        <span class="s0"># Skip comments.</span>
        <span class="s4">while </span><span class="s1">c == </span><span class="s3">&quot;#&quot;</span><span class="s1">:</span>
            <span class="s4">while </span><span class="s1">c </span><span class="s4">not in </span><span class="s3">&quot;</span><span class="s4">\n\r</span><span class="s3">&quot;</span><span class="s1">:</span>
                <span class="s1">c = getc()</span>
        <span class="s4">if not </span><span class="s1">c.isdigit():</span>
            <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">f&quot;unexpected character </span><span class="s4">{</span><span class="s1">c</span><span class="s4">} </span><span class="s3">found in header&quot;</span><span class="s1">)</span>
        <span class="s0"># According to the specification it is legal to have comments</span>
        <span class="s0"># that appear in the middle of a token.</span>
        <span class="s0"># This is bonkers; I've never seen it; and it's a bit awkward to</span>
        <span class="s0"># code good lexers in Python (no goto).  So we break on such</span>
        <span class="s0"># cases.</span>
        <span class="s1">token = strtobytes(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s4">while </span><span class="s1">c.isdigit():</span>
            <span class="s1">token += c</span>
            <span class="s1">c = getc()</span>
        <span class="s0"># Slight hack.  All &quot;tokens&quot; are decimal integers, so convert</span>
        <span class="s0"># them here.</span>
        <span class="s1">header.append(int(token))</span>
        <span class="s4">if </span><span class="s1">len(header) == expected:</span>
            <span class="s4">break</span>
    <span class="s0"># Skip comments (again)</span>
    <span class="s4">while </span><span class="s1">c == </span><span class="s3">&quot;#&quot;</span><span class="s1">:</span>
        <span class="s4">while </span><span class="s1">c </span><span class="s4">not in </span><span class="s3">&quot;</span><span class="s4">\n\r</span><span class="s3">&quot;</span><span class="s1">:</span>
            <span class="s1">c = getc()</span>
    <span class="s4">if not </span><span class="s1">c.isspace():</span>
        <span class="s4">raise </span><span class="s1">Error(</span><span class="s3">f&quot;expected header to end with whitespace, not </span><span class="s4">{</span><span class="s1">c</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s4">if </span><span class="s1">type </span><span class="s4">in </span><span class="s1">pbm:</span>
        <span class="s0"># synthesize a MAXVAL</span>
        <span class="s1">header.append(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">depth = (</span><span class="s5">1</span><span class="s4">, </span><span class="s5">3</span><span class="s1">)[type == strtobytes(</span><span class="s3">&quot;P6&quot;</span><span class="s1">)]</span>
    <span class="s4">return </span><span class="s1">header[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">header[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">header[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">, </span><span class="s1">header[</span><span class="s5">3</span><span class="s1">]</span>


<span class="s4">def </span><span class="s1">write_pnm(file</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta):</span>
    <span class="s2">&quot;&quot;&quot;Write a Netpbm PNM/PAM file.&quot;&quot;&quot;</span>

    <span class="s1">bitdepth = meta[</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">]</span>
    <span class="s1">maxval = </span><span class="s5">2</span><span class="s1">**bitdepth - </span><span class="s5">1</span>
    <span class="s0"># Rudely, the number of image planes can be used to determine</span>
    <span class="s0"># whether we are L (PGM), LA (PAM), RGB (PPM), or RGBA (PAM).</span>
    <span class="s1">planes = meta[</span><span class="s3">&quot;planes&quot;</span><span class="s1">]</span>
    <span class="s0"># Can be an assert as long as we assume that pixels and meta came</span>
    <span class="s0"># from a PNG file.</span>
    <span class="s4">assert </span><span class="s1">planes </span><span class="s4">in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">planes </span><span class="s4">in </span><span class="s1">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">3</span><span class="s1">):</span>
        <span class="s4">if </span><span class="s5">1 </span><span class="s1">== planes:</span>
            <span class="s0"># PGM</span>
            <span class="s0"># Could generate PBM if maxval is 1, but we don't (for one</span>
            <span class="s0"># thing, we'd have to convert the data, not just blat it</span>
            <span class="s0"># out).</span>
            <span class="s1">fmt = </span><span class="s3">&quot;P5&quot;</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># PPM</span>
            <span class="s1">fmt = </span><span class="s3">&quot;P6&quot;</span>
        <span class="s1">file.write(</span><span class="s3">&quot;%s %d %d %d</span><span class="s4">\n</span><span class="s3">&quot; </span><span class="s1">% (fmt</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">maxval))</span>
    <span class="s4">if </span><span class="s1">planes </span><span class="s4">in </span><span class="s1">(</span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s1">):</span>
        <span class="s0"># PAM</span>
        <span class="s0"># See http://netpbm.sourceforge.net/doc/pam.html</span>
        <span class="s4">if </span><span class="s5">2 </span><span class="s1">== planes:</span>
            <span class="s1">tupltype = </span><span class="s3">&quot;GRAYSCALE_ALPHA&quot;</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">tupltype = </span><span class="s3">&quot;RGB_ALPHA&quot;</span>
        <span class="s1">file.write(</span>
            <span class="s3">&quot;P7</span><span class="s4">\n</span><span class="s3">WIDTH %d</span><span class="s4">\n</span><span class="s3">HEIGHT %d</span><span class="s4">\n</span><span class="s3">DEPTH %d</span><span class="s4">\n</span><span class="s3">MAXVAL %d</span><span class="s4">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;TUPLTYPE %s</span><span class="s4">\n</span><span class="s3">ENDHDR</span><span class="s4">\n</span><span class="s3">&quot; </span><span class="s1">% (width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">planes</span><span class="s4">, </span><span class="s1">maxval</span><span class="s4">, </span><span class="s1">tupltype)</span>
        <span class="s1">)</span>
    <span class="s0"># Values per row</span>
    <span class="s1">vpr = planes * width</span>
    <span class="s0"># struct format</span>
    <span class="s1">fmt = </span><span class="s3">&quot;&gt;%d&quot; </span><span class="s1">% vpr</span>
    <span class="s4">if </span><span class="s1">maxval &gt; </span><span class="s5">0xFF</span><span class="s1">:</span>
        <span class="s1">fmt = fmt + </span><span class="s3">&quot;H&quot;</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">fmt = fmt + </span><span class="s3">&quot;B&quot;</span>
    <span class="s4">for </span><span class="s1">row </span><span class="s4">in </span><span class="s1">pixels:</span>
        <span class="s1">file.write(struct.pack(fmt</span><span class="s4">, </span><span class="s1">*row))</span>
    <span class="s1">file.flush()</span>


<span class="s4">def </span><span class="s1">color_triple(color):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a command line colour value to a RGB triple of integers. 
    FIXME: Somewhere we need support for greyscale backgrounds etc. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">color.startswith(</span><span class="s3">&quot;#&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">len(color) == </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">(int(color[</span><span class="s5">1</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">, </span><span class="s1">int(color[</span><span class="s5">2</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">, </span><span class="s1">int(color[</span><span class="s5">3</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">))</span>
    <span class="s4">if </span><span class="s1">color.startswith(</span><span class="s3">&quot;#&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">len(color) == </span><span class="s5">7</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">(int(color[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">, </span><span class="s1">int(color[</span><span class="s5">3</span><span class="s1">:</span><span class="s5">5</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">, </span><span class="s1">int(color[</span><span class="s5">5</span><span class="s1">:</span><span class="s5">7</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">))</span>
    <span class="s4">elif </span><span class="s1">color.startswith(</span><span class="s3">&quot;#&quot;</span><span class="s1">) </span><span class="s4">and </span><span class="s1">len(color) == </span><span class="s5">13</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">(int(color[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">5</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">, </span><span class="s1">int(color[</span><span class="s5">5</span><span class="s1">:</span><span class="s5">9</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">)</span><span class="s4">, </span><span class="s1">int(color[</span><span class="s5">9</span><span class="s1">:</span><span class="s5">13</span><span class="s1">]</span><span class="s4">, </span><span class="s5">16</span><span class="s1">))</span>


<span class="s4">def </span><span class="s1">_main(argv):</span>
    <span class="s2">&quot;&quot;&quot; 
    Run the PNG encoder with options from the command line. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Parse command line arguments</span>
    <span class="s4">from </span><span class="s1">optparse </span><span class="s4">import </span><span class="s1">OptionParser</span>
    <span class="s4">import </span><span class="s1">re</span>

    <span class="s1">version = </span><span class="s3">&quot;%prog &quot; </span><span class="s1">+ re.sub(</span><span class="s3">r&quot;( ?\$|URL: |Rev:)&quot;</span><span class="s4">, </span><span class="s3">&quot;&quot;</span><span class="s4">, </span><span class="s1">__version__)</span>
    <span class="s1">parser = OptionParser(version=version)</span>
    <span class="s1">parser.set_usage(</span><span class="s3">&quot;%prog [options] [imagefile]&quot;</span><span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-r&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--read-png&quot;</span><span class="s4">,</span>
        <span class="s1">default=</span><span class="s4">False,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Read PNG, write PNM&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-i&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--interlace&quot;</span><span class="s4">,</span>
        <span class="s1">default=</span><span class="s4">False,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;create an interlaced PNG file (Adam7)&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-t&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--transparent&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;color&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;mark the specified colour (#RRGGBB) as transparent&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-b&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--background&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;color&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;save the specified background colour&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-a&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--alpha&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;pgmfile&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;alpha channel transparency (RGBA)&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-g&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--gamma&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;float&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;value&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;save the specified gamma value&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-c&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--compression&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;int&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;level&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;zlib compression level (0-9)&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-T&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test&quot;</span><span class="s4">,</span>
        <span class="s1">default=</span><span class="s4">False,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;create a test image (a named PngSuite image if an argument is supplied)&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-L&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--list&quot;</span><span class="s4">,</span>
        <span class="s1">default=</span><span class="s4">False,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;print list of named test images&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-R&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test-red&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;pattern&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;test pattern for the red image layer&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-G&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test-green&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;pattern&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;test pattern for the green image layer&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-B&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test-blue&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;pattern&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;test pattern for the blue image layer&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-A&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test-alpha&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;pattern&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;test pattern for the alpha image layer&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-K&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test-black&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;pattern&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;test pattern for greyscale image&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-d&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test-depth&quot;</span><span class="s4">,</span>
        <span class="s1">default=</span><span class="s5">8</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;int&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;NBITS&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;create test PNGs that are NBITS bits per channel&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_option(</span>
        <span class="s3">&quot;-S&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;--test-size&quot;</span><span class="s4">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s3">&quot;int&quot;</span><span class="s4">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;size&quot;</span><span class="s4">,</span>
        <span class="s1">help=</span><span class="s3">&quot;width and height of the test image&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>
    <span class="s1">(options</span><span class="s4">, </span><span class="s1">args) = parser.parse_args(args=argv[</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s0"># Convert options</span>
    <span class="s4">if </span><span class="s1">options.transparent </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">options.transparent = color_triple(options.transparent)</span>
    <span class="s4">if </span><span class="s1">options.background </span><span class="s4">is not None</span><span class="s1">:</span>
        <span class="s1">options.background = color_triple(options.background)</span>

    <span class="s4">if </span><span class="s1">options.list:</span>
        <span class="s1">names = list(_pngsuite)</span>
        <span class="s1">names.sort()</span>
        <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">names:</span>
            <span class="s1">print(name)</span>
        <span class="s4">return</span>

    <span class="s0"># Run regression tests</span>
    <span class="s4">if </span><span class="s1">options.test:</span>
        <span class="s4">return </span><span class="s1">test_suite(options</span><span class="s4">, </span><span class="s1">args)</span>

    <span class="s0"># Prepare input and output files</span>
    <span class="s4">if </span><span class="s1">len(args) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">infilename = </span><span class="s3">&quot;-&quot;</span>
        <span class="s1">infile = sys.stdin</span>
    <span class="s4">elif </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">infilename = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">infile = open(infilename</span><span class="s4">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">parser.error(</span><span class="s3">&quot;more than one input file&quot;</span><span class="s1">)</span>
    <span class="s1">outfile = sys.stdout</span>

    <span class="s4">if </span><span class="s1">options.read_png:</span>
        <span class="s0"># Encode PNG to PPM</span>
        <span class="s1">png = Reader(file=infile)</span>
        <span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta = png.asDirect()</span>
        <span class="s1">write_pnm(outfile</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">pixels</span><span class="s4">, </span><span class="s1">meta)</span>
    <span class="s4">else</span><span class="s1">:</span>
        <span class="s0"># Encode PNM to PNG</span>
        <span class="s1">format</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">, </span><span class="s1">maxval = read_pnm_header(</span>
            <span class="s1">infile</span><span class="s4">, </span><span class="s1">(</span><span class="s3">&quot;P5&quot;</span><span class="s4">, </span><span class="s3">&quot;P6&quot;</span><span class="s4">, </span><span class="s3">&quot;P7&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s0"># When it comes to the variety of input formats, we do something</span>
        <span class="s0"># rather rude.  Observe that L, LA, RGB, RGBA are the 4 colour</span>
        <span class="s0"># types supported by PNG and that they correspond to 1, 2, 3, 4</span>
        <span class="s0"># channels respectively.  So we use the number of channels in</span>
        <span class="s0"># the source image to determine which one we have.  We do not</span>
        <span class="s0"># care about TUPLTYPE.</span>
        <span class="s1">greyscale = depth &lt;= </span><span class="s5">2</span>
        <span class="s1">pamalpha = depth </span><span class="s4">in </span><span class="s1">(</span><span class="s5">2</span><span class="s4">, </span><span class="s5">4</span><span class="s1">)</span>
        <span class="s1">supported = map(</span><span class="s4">lambda </span><span class="s1">x: </span><span class="s5">2</span><span class="s1">**x - </span><span class="s5">1</span><span class="s4">, </span><span class="s1">range(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">17</span><span class="s1">))</span>
        <span class="s4">try</span><span class="s1">:</span>
            <span class="s1">mi = supported.index(maxval)</span>
        <span class="s4">except </span><span class="s1">ValueError:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s3">f&quot;your maxval (</span><span class="s4">{</span><span class="s1">maxval</span><span class="s4">}</span><span class="s3">) not in supported list </span><span class="s4">{</span><span class="s1">str(supported)</span><span class="s4">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
        <span class="s1">bitdepth = mi + </span><span class="s5">1</span>
        <span class="s1">writer = Writer(</span>
            <span class="s1">width</span><span class="s4">,</span>
            <span class="s1">height</span><span class="s4">,</span>
            <span class="s1">greyscale=greyscale</span><span class="s4">,</span>
            <span class="s1">bitdepth=bitdepth</span><span class="s4">,</span>
            <span class="s1">interlace=options.interlace</span><span class="s4">,</span>
            <span class="s1">transparent=options.transparent</span><span class="s4">,</span>
            <span class="s1">background=options.background</span><span class="s4">,</span>
            <span class="s1">alpha=bool(pamalpha </span><span class="s4">or </span><span class="s1">options.alpha)</span><span class="s4">,</span>
            <span class="s1">gamma=options.gamma</span><span class="s4">,</span>
            <span class="s1">compression=options.compression</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s4">if </span><span class="s1">options.alpha:</span>
            <span class="s1">pgmfile = open(options.alpha</span><span class="s4">, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
            <span class="s1">format</span><span class="s4">, </span><span class="s1">awidth</span><span class="s4">, </span><span class="s1">aheight</span><span class="s4">, </span><span class="s1">adepth</span><span class="s4">, </span><span class="s1">amaxval = read_pnm_header(pgmfile</span><span class="s4">, </span><span class="s3">&quot;P5&quot;</span><span class="s1">)</span>
            <span class="s4">if </span><span class="s1">amaxval != </span><span class="s3">&quot;255&quot;</span><span class="s1">:</span>
                <span class="s4">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">f&quot;maxval </span><span class="s4">{</span><span class="s1">amaxval</span><span class="s4">} </span><span class="s3">not supported for alpha channel&quot;</span>
                <span class="s1">)</span>
            <span class="s4">if </span><span class="s1">(awidth</span><span class="s4">, </span><span class="s1">aheight) != (width</span><span class="s4">, </span><span class="s1">height):</span>
                <span class="s4">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;alpha channel image size mismatch&quot;</span>
                    <span class="s3">&quot; (%s has %sx%s but %s has %sx%s)&quot;</span>
                    <span class="s1">% (infilename</span><span class="s4">, </span><span class="s1">width</span><span class="s4">, </span><span class="s1">height</span><span class="s4">, </span><span class="s1">options.alpha</span><span class="s4">, </span><span class="s1">awidth</span><span class="s4">, </span><span class="s1">aheight)</span>
                <span class="s1">)</span>
            <span class="s1">writer.convert_ppm_and_pgm(infile</span><span class="s4">, </span><span class="s1">pgmfile</span><span class="s4">, </span><span class="s1">outfile)</span>
        <span class="s4">else</span><span class="s1">:</span>
            <span class="s1">writer.convert_pnm(infile</span><span class="s4">, </span><span class="s1">outfile)</span>


<span class="s4">if </span><span class="s1">__name__ == </span><span class="s3">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">_main(sys.argv)</span>
    <span class="s4">except </span><span class="s1">Error </span><span class="s4">as </span><span class="s1">e:</span>
        <span class="s1">sys.stderr.write(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">e</span><span class="s4">}\n</span><span class="s3">&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>