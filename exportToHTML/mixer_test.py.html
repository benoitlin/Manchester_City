<html>
<head>
<title>mixer_test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mixer_test.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">unittest</span>
<span class="s0">import </span><span class="s1">pathlib</span>
<span class="s0">import </span><span class="s1">platform</span>

<span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">example_path</span><span class="s0">, </span><span class="s1">AssertRaisesRegexMixin</span>

<span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame </span><span class="s0">import </span><span class="s1">mixer</span>

<span class="s1">IS_PYPY = </span><span class="s2">&quot;PyPy&quot; </span><span class="s1">== platform.python_implementation()</span>

<span class="s3">################################### CONSTANTS ##################################</span>

<span class="s1">FREQUENCIES = [</span><span class="s4">11025</span><span class="s0">, </span><span class="s4">22050</span><span class="s0">, </span><span class="s4">44100</span><span class="s0">, </span><span class="s4">48000</span><span class="s1">]</span>
<span class="s1">SIZES = [-</span><span class="s4">16</span><span class="s0">, </span><span class="s1">-</span><span class="s4">8</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">16</span><span class="s1">]  </span><span class="s3"># fixme</span>
<span class="s3"># size 32 failed in test_get_init__returns_exact_values_used_for_init</span>
<span class="s1">CHANNELS = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>
<span class="s1">BUFFERS = [</span><span class="s4">3024</span><span class="s1">]</span>

<span class="s1">CONFIGS = [</span>
    <span class="s1">{</span><span class="s2">&quot;frequency&quot;</span><span class="s1">: f</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: s</span><span class="s0">, </span><span class="s2">&quot;channels&quot;</span><span class="s1">: c}</span>
    <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">FREQUENCIES</span>
    <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">SIZES</span>
    <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">CHANNELS</span>
<span class="s1">]</span>
<span class="s3"># Using all CONFIGS fails on a Mac; probably older SDL_mixer; we could do:</span>
<span class="s3"># if platform.system() == 'Darwin':</span>
<span class="s3"># But using all CONFIGS is very slow (&gt; 10 sec for example)</span>
<span class="s3"># And probably, we don't need to be so exhaustive, hence:</span>

<span class="s1">CONFIG = {</span><span class="s2">&quot;frequency&quot;</span><span class="s1">: </span><span class="s4">44100</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s4">32</span><span class="s0">, </span><span class="s2">&quot;channels&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;allowedchanges&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span>


<span class="s0">class </span><span class="s1">InvalidBool:</span>
    <span class="s5">&quot;&quot;&quot;To help test invalid bool values.&quot;&quot;&quot;</span>

    <span class="s1">__bool__ = </span><span class="s0">None</span>


<span class="s3">############################## MODULE LEVEL TESTS #############################</span>


<span class="s0">class </span><span class="s1">MixerModuleTest(unittest.TestCase):</span>
    <span class="s0">def </span><span class="s1">tearDown(self):</span>
        <span class="s1">mixer.quit()</span>
        <span class="s1">mixer.pre_init(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_init__keyword_args(self):</span>
        <span class="s3"># note: this test used to loop over all CONFIGS, but it's very slow..</span>
        <span class="s1">mixer.init(**CONFIG)</span>
        <span class="s1">mixer_conf = mixer.get_init()</span>

        <span class="s1">self.assertEqual(mixer_conf[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">CONFIG[</span><span class="s2">&quot;frequency&quot;</span><span class="s1">])</span>
        <span class="s3"># Not all &quot;sizes&quot; are supported on all systems,  hence &quot;abs&quot;.</span>
        <span class="s1">self.assertEqual(abs(mixer_conf[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">abs(CONFIG[</span><span class="s2">&quot;size&quot;</span><span class="s1">]))</span>
        <span class="s1">self.assertGreaterEqual(mixer_conf[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">CONFIG[</span><span class="s2">&quot;channels&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_pre_init__keyword_args(self):</span>
        <span class="s3"># note: this test used to loop over all CONFIGS, but it's very slow..</span>
        <span class="s1">mixer.pre_init(**CONFIG)</span>
        <span class="s1">mixer.init()</span>

        <span class="s1">mixer_conf = mixer.get_init()</span>

        <span class="s1">self.assertEqual(mixer_conf[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">CONFIG[</span><span class="s2">&quot;frequency&quot;</span><span class="s1">])</span>
        <span class="s3"># Not all &quot;sizes&quot; are supported on all systems,  hence &quot;abs&quot;.</span>
        <span class="s1">self.assertEqual(abs(mixer_conf[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">abs(CONFIG[</span><span class="s2">&quot;size&quot;</span><span class="s1">]))</span>
        <span class="s1">self.assertGreaterEqual(mixer_conf[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">CONFIG[</span><span class="s2">&quot;channels&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_pre_init__zero_values(self):</span>
        <span class="s3"># Ensure that argument values of 0 are replaced with</span>
        <span class="s3"># default values. No way to check buffer size though.</span>
        <span class="s1">mixer.pre_init(</span><span class="s4">22050</span><span class="s0">, </span><span class="s1">-</span><span class="s4">8</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)  </span><span class="s3"># Non default values</span>
        <span class="s1">mixer.pre_init(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)  </span><span class="s3"># Should reset to default values</span>
        <span class="s1">mixer.init(allowedchanges=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(mixer.get_init()[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">44100</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(mixer.get_init()[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">self.assertGreaterEqual(mixer.get_init()[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_init__zero_values(self):</span>
        <span class="s3"># Ensure that argument values of 0 are replaced with</span>
        <span class="s3"># preset values. No way to check buffer size though.</span>
        <span class="s1">mixer.pre_init(</span><span class="s4">44100</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">allowedchanges=</span><span class="s4">0</span><span class="s1">)  </span><span class="s3"># None default values</span>
        <span class="s1">mixer.init(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(mixer.get_init()</span><span class="s0">, </span><span class="s1">(</span><span class="s4">44100</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_get_init__returns_exact_values_used_for_init(self):</span>
        <span class="s3"># TODO: size 32 fails in this test (maybe SDL_mixer bug)</span>

        <span class="s0">for </span><span class="s1">init_conf </span><span class="s0">in </span><span class="s1">CONFIGS:</span>
            <span class="s1">frequency</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">channels = init_conf.values()</span>
            <span class="s0">if </span><span class="s1">(frequency</span><span class="s0">, </span><span class="s1">size) == (</span><span class="s4">22050</span><span class="s0">, </span><span class="s4">16</span><span class="s1">):</span>
                <span class="s0">continue</span>
            <span class="s1">mixer.init(frequency</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">channels)</span>

            <span class="s1">mixer_conf = mixer.get_init()</span>

            <span class="s1">self.assertEqual(tuple(init_conf.values())</span><span class="s0">, </span><span class="s1">mixer_conf)</span>
            <span class="s1">mixer.quit()</span>

    <span class="s0">def </span><span class="s1">test_get_init__returns_None_if_mixer_not_initialized(self):</span>
        <span class="s1">self.assertIsNone(mixer.get_init())</span>

    <span class="s0">def </span><span class="s1">test_get_num_channels__defaults_eight_after_init(self):</span>
        <span class="s1">mixer.init()</span>
        <span class="s1">self.assertEqual(mixer.get_num_channels()</span><span class="s0">, </span><span class="s4">8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_set_num_channels(self):</span>
        <span class="s1">mixer.init()</span>

        <span class="s1">default_num_channels = mixer.get_num_channels()</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">default_num_channels + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">mixer.set_num_channels(i)</span>
            <span class="s1">self.assertEqual(mixer.get_num_channels()</span><span class="s0">, </span><span class="s1">i)</span>

    <span class="s0">def </span><span class="s1">test_quit(self):</span>
        <span class="s5">&quot;&quot;&quot;get_num_channels() Should throw pygame.error if uninitialized 
        after mixer.quit()&quot;&quot;&quot;</span>
        <span class="s1">mixer.init()</span>
        <span class="s1">mixer.quit()</span>
        <span class="s1">self.assertRaises(pygame.error</span><span class="s0">, </span><span class="s1">mixer.get_num_channels)</span>

    <span class="s3"># TODO: FIXME: appveyor and pypy (on linux) fails here sometimes.</span>
    <span class="s1">@unittest.skipIf(sys.platform.startswith(</span><span class="s2">&quot;win&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;See github issue 892.&quot;</span><span class="s1">)</span>
    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;random errors here with pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_sound_args(self):</span>
        <span class="s0">def </span><span class="s1">get_bytes(snd):</span>
            <span class="s0">return </span><span class="s1">snd.get_raw()</span>

        <span class="s1">mixer.init()</span>

        <span class="s1">sample = </span><span class="s6">b&quot;</span><span class="s0">\x00\xff</span><span class="s6">&quot; </span><span class="s1">* </span><span class="s4">24</span>
        <span class="s1">wave_path = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
        <span class="s1">uwave_path = str(wave_path)</span>
        <span class="s1">bwave_path = uwave_path.encode(sys.getfilesystemencoding())</span>
        <span class="s1">snd = mixer.Sound(file=wave_path)</span>
        <span class="s1">self.assertTrue(snd.get_length() &gt; </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">snd_bytes = get_bytes(snd)</span>
        <span class="s1">self.assertTrue(len(snd_bytes) &gt; </span><span class="s4">1000</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(get_bytes(mixer.Sound(wave_path))</span><span class="s0">, </span><span class="s1">snd_bytes)</span>

        <span class="s1">self.assertEqual(get_bytes(mixer.Sound(file=uwave_path))</span><span class="s0">, </span><span class="s1">snd_bytes)</span>
        <span class="s1">self.assertEqual(get_bytes(mixer.Sound(uwave_path))</span><span class="s0">, </span><span class="s1">snd_bytes)</span>
        <span class="s1">arg_emsg = </span><span class="s2">&quot;Sound takes either 1 positional or 1 keyword argument&quot;</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound()</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">arg_emsg)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound(wave_path</span><span class="s0">, </span><span class="s1">buffer=sample)</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">arg_emsg)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound(sample</span><span class="s0">, </span><span class="s1">file=wave_path)</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">arg_emsg)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound(buffer=sample</span><span class="s0">, </span><span class="s1">file=wave_path)</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">arg_emsg)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound(foobar=sample)</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s2">&quot;Unrecognized keyword argument 'foobar'&quot;</span><span class="s1">)</span>

        <span class="s1">snd = mixer.Sound(wave_path</span><span class="s0">, </span><span class="s1">**{})</span>
        <span class="s1">self.assertEqual(get_bytes(snd)</span><span class="s0">, </span><span class="s1">snd_bytes)</span>
        <span class="s1">snd = mixer.Sound(*[]</span><span class="s0">, </span><span class="s1">**{</span><span class="s2">&quot;file&quot;</span><span class="s1">: wave_path})</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound([])</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s2">&quot;Unrecognized argument (type list)&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">snd = mixer.Sound(buffer=[])</span>
        <span class="s1">emsg = </span><span class="s2">&quot;Expected object with buffer interface: got a list&quot;</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">emsg)</span>

        <span class="s1">ufake_path = </span><span class="s2">&quot;12345678&quot;</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s0">, </span><span class="s1">mixer.Sound</span><span class="s0">, </span><span class="s1">ufake_path)</span>
        <span class="s1">self.assertRaises(IOError</span><span class="s0">, </span><span class="s1">mixer.Sound</span><span class="s0">, </span><span class="s2">&quot;12345678&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound(buffer=</span><span class="s2">&quot;something&quot;</span><span class="s1">)</span>
        <span class="s1">emsg = </span><span class="s2">&quot;Unicode object not allowed as buffer object&quot;</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">emsg)</span>
        <span class="s1">self.assertEqual(get_bytes(mixer.Sound(buffer=sample))</span><span class="s0">, </span><span class="s1">sample)</span>
        <span class="s0">if </span><span class="s1">type(sample) != str:</span>
            <span class="s1">somebytes = get_bytes(mixer.Sound(sample))</span>
            <span class="s3"># on python 2 we do not allow using string except as file name.</span>
            <span class="s1">self.assertEqual(somebytes</span><span class="s0">, </span><span class="s1">sample)</span>
        <span class="s1">self.assertEqual(get_bytes(mixer.Sound(file=bwave_path))</span><span class="s0">, </span><span class="s1">snd_bytes)</span>
        <span class="s1">self.assertEqual(get_bytes(mixer.Sound(bwave_path))</span><span class="s0">, </span><span class="s1">snd_bytes)</span>

        <span class="s1">snd = mixer.Sound(wave_path)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound(wave_path</span><span class="s0">, </span><span class="s1">array=snd)</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">arg_emsg)</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError) </span><span class="s0">as </span><span class="s1">cm:</span>
            <span class="s1">mixer.Sound(buffer=sample</span><span class="s0">, </span><span class="s1">array=snd)</span>
        <span class="s1">self.assertEqual(str(cm.exception)</span><span class="s0">, </span><span class="s1">arg_emsg)</span>
        <span class="s1">snd2 = mixer.Sound(array=snd)</span>
        <span class="s1">self.assertEqual(snd.get_raw()</span><span class="s0">, </span><span class="s1">snd2.get_raw())</span>

    <span class="s0">def </span><span class="s1">test_sound_unicode(self):</span>
        <span class="s5">&quot;&quot;&quot;test non-ASCII unicode path&quot;&quot;&quot;</span>
        <span class="s1">mixer.init()</span>
        <span class="s0">import </span><span class="s1">shutil</span>

        <span class="s1">ep = example_path(</span><span class="s2">&quot;data&quot;</span><span class="s1">)</span>
        <span class="s1">temp_file = os.path.join(ep</span><span class="s0">, </span><span class="s2">&quot;你好.wav&quot;</span><span class="s1">)</span>
        <span class="s1">org_file = os.path.join(ep</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">)</span>
        <span class="s1">shutil.copy(org_file</span><span class="s0">, </span><span class="s1">temp_file)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">open(temp_file</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s0">pass</span>
        <span class="s0">except </span><span class="s1">OSError:</span>
            <span class="s0">raise </span><span class="s1">unittest.SkipTest(</span><span class="s2">&quot;the path cannot be opened&quot;</span><span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">sound = mixer.Sound(temp_file)</span>
            <span class="s0">del </span><span class="s1">sound</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">os.remove(temp_file)</span>

    <span class="s1">@unittest.skipIf(</span>
        <span class="s1">os.environ.get(</span><span class="s2">&quot;SDL_AUDIODRIVER&quot;</span><span class="s1">) == </span><span class="s2">&quot;disk&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;this test fails without real sound card&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_array_keyword(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">(</span>
                <span class="s1">array</span><span class="s0">,</span>
                <span class="s1">arange</span><span class="s0">,</span>
                <span class="s1">zeros</span><span class="s0">,</span>
                <span class="s1">int8</span><span class="s0">,</span>
                <span class="s1">uint8</span><span class="s0">,</span>
                <span class="s1">int16</span><span class="s0">,</span>
                <span class="s1">uint16</span><span class="s0">,</span>
                <span class="s1">int32</span><span class="s0">,</span>
                <span class="s1">uint32</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ImportError:</span>
            <span class="s1">self.skipTest(</span><span class="s2">&quot;requires numpy&quot;</span><span class="s1">)</span>

        <span class="s1">freq = </span><span class="s4">22050</span>
        <span class="s1">format_list = [-</span><span class="s4">8</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s1">-</span><span class="s4">16</span><span class="s0">, </span><span class="s4">16</span><span class="s1">]</span>
        <span class="s1">channels_list = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>

        <span class="s1">a_lists = {f: [] </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">format_list}</span>
        <span class="s1">a32u_mono = arange(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">256</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">uint32)</span>
        <span class="s1">a16u_mono = a32u_mono.astype(uint16)</span>
        <span class="s1">a8u_mono = a32u_mono.astype(uint8)</span>
        <span class="s1">au_list_mono = [(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">[a8u_mono</span><span class="s0">, </span><span class="s1">a16u_mono</span><span class="s0">, </span><span class="s1">a32u_mono]]</span>
        <span class="s0">for </span><span class="s1">format </span><span class="s0">in </span><span class="s1">format_list:</span>
            <span class="s0">if </span><span class="s1">format &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">a_lists[format].extend(au_list_mono)</span>
        <span class="s1">a32s_mono = arange(-</span><span class="s4">128</span><span class="s0">, </span><span class="s4">128</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">int32)</span>
        <span class="s1">a16s_mono = a32s_mono.astype(int16)</span>
        <span class="s1">a8s_mono = a32s_mono.astype(int8)</span>
        <span class="s1">as_list_mono = [(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">[a8s_mono</span><span class="s0">, </span><span class="s1">a16s_mono</span><span class="s0">, </span><span class="s1">a32s_mono]]</span>
        <span class="s0">for </span><span class="s1">format </span><span class="s0">in </span><span class="s1">format_list:</span>
            <span class="s0">if </span><span class="s1">format &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">a_lists[format].extend(as_list_mono)</span>
        <span class="s1">a32u_stereo = zeros([a32u_mono.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">uint32)</span>
        <span class="s1">a32u_stereo[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = a32u_mono</span>
        <span class="s1">a32u_stereo[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] = </span><span class="s4">255 </span><span class="s1">- a32u_mono</span>
        <span class="s1">a16u_stereo = a32u_stereo.astype(uint16)</span>
        <span class="s1">a8u_stereo = a32u_stereo.astype(uint8)</span>
        <span class="s1">au_list_stereo = [(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">[a8u_stereo</span><span class="s0">, </span><span class="s1">a16u_stereo</span><span class="s0">, </span><span class="s1">a32u_stereo]]</span>
        <span class="s0">for </span><span class="s1">format </span><span class="s0">in </span><span class="s1">format_list:</span>
            <span class="s0">if </span><span class="s1">format &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">a_lists[format].extend(au_list_stereo)</span>
        <span class="s1">a32s_stereo = zeros([a32s_mono.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">int32)</span>
        <span class="s1">a32s_stereo[:</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = a32s_mono</span>
        <span class="s1">a32s_stereo[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] = -</span><span class="s4">1 </span><span class="s1">- a32s_mono</span>
        <span class="s1">a16s_stereo = a32s_stereo.astype(int16)</span>
        <span class="s1">a8s_stereo = a32s_stereo.astype(int8)</span>
        <span class="s1">as_list_stereo = [(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">[a8s_stereo</span><span class="s0">, </span><span class="s1">a16s_stereo</span><span class="s0">, </span><span class="s1">a32s_stereo]]</span>
        <span class="s0">for </span><span class="s1">format </span><span class="s0">in </span><span class="s1">format_list:</span>
            <span class="s0">if </span><span class="s1">format &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">a_lists[format].extend(as_list_stereo)</span>

        <span class="s0">for </span><span class="s1">format </span><span class="s0">in </span><span class="s1">format_list:</span>
            <span class="s0">for </span><span class="s1">channels </span><span class="s0">in </span><span class="s1">channels_list:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">mixer.init(freq</span><span class="s0">, </span><span class="s1">format</span><span class="s0">, </span><span class="s1">channels)</span>
                <span class="s0">except </span><span class="s1">pygame.error:</span>
                    <span class="s3"># Some formats (e.g. 16) may not be supported.</span>
                    <span class="s0">continue</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">__</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">c = mixer.get_init()</span>
                    <span class="s0">if </span><span class="s1">f != format </span><span class="s0">or </span><span class="s1">c != channels:</span>
                        <span class="s3"># Some formats (e.g. -8) may not be supported.</span>
                        <span class="s0">continue</span>
                    <span class="s0">for </span><span class="s1">c</span><span class="s0">, </span><span class="s1">a </span><span class="s0">in </span><span class="s1">a_lists[format]:</span>
                        <span class="s1">self._test_array_argument(format</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">c == channels)</span>
                <span class="s0">finally</span><span class="s1">:</span>
                    <span class="s1">mixer.quit()</span>

    <span class="s0">def </span><span class="s1">_test_array_argument(self</span><span class="s0">, </span><span class="s1">format</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">test_pass):</span>
        <span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">array</span><span class="s0">, </span><span class="s1">all </span><span class="s0">as </span><span class="s1">all_</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">snd = mixer.Sound(array=a)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">if not </span><span class="s1">test_pass:</span>
                <span class="s0">return</span>
            <span class="s1">self.fail(</span><span class="s2">&quot;Raised ValueError: Format %i, dtype %s&quot; </span><span class="s1">% (format</span><span class="s0">, </span><span class="s1">a.dtype))</span>
        <span class="s0">if not </span><span class="s1">test_pass:</span>
            <span class="s1">self.fail(</span>
                <span class="s2">&quot;Did not raise ValueError: Format %i, dtype %s&quot; </span><span class="s1">% (format</span><span class="s0">, </span><span class="s1">a.dtype)</span>
            <span class="s1">)</span>
        <span class="s1">a2 = array(snd)</span>
        <span class="s1">a3 = a.astype(a2.dtype)</span>
        <span class="s1">lshift = abs(format) - </span><span class="s4">8 </span><span class="s1">* a.itemsize</span>
        <span class="s0">if </span><span class="s1">lshift &gt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3"># This is asymmetric with respect to downcasting.</span>
            <span class="s1">a3 &lt;&lt;= lshift</span>
        <span class="s1">self.assertTrue(all_(a2 == a3)</span><span class="s0">, </span><span class="s2">&quot;Format %i, dtype %s&quot; </span><span class="s1">% (format</span><span class="s0">, </span><span class="s1">a.dtype))</span>

    <span class="s0">def </span><span class="s1">_test_array_interface_fail(self</span><span class="s0">, </span><span class="s1">a):</span>
        <span class="s1">self.assertRaises(ValueError</span><span class="s0">, </span><span class="s1">mixer.Sound</span><span class="s0">, </span><span class="s1">array=a)</span>

    <span class="s0">def </span><span class="s1">test_array_interface(self):</span>
        <span class="s1">mixer.init(</span><span class="s4">22050</span><span class="s0">, </span><span class="s1">-</span><span class="s4">16</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">allowedchanges=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">snd = mixer.Sound(buffer=</span><span class="s6">b&quot;</span><span class="s0">\x00\x7f</span><span class="s6">&quot; </span><span class="s1">* </span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">d = snd.__array_interface__</span>
        <span class="s1">self.assertTrue(isinstance(d</span><span class="s0">, </span><span class="s1">dict))</span>
        <span class="s0">if </span><span class="s1">pygame.get_sdl_byteorder() == pygame.LIL_ENDIAN:</span>
            <span class="s1">typestr = </span><span class="s2">&quot;&lt;i2&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">typestr = </span><span class="s2">&quot;&gt;i2&quot;</span>
        <span class="s1">self.assertEqual(d[</span><span class="s2">&quot;typestr&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">typestr)</span>
        <span class="s1">self.assertEqual(d[</span><span class="s2">&quot;shape&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">20</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(d[</span><span class="s2">&quot;strides&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(d[</span><span class="s2">&quot;data&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(snd._samples_address</span><span class="s0">, False</span><span class="s1">))</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">&quot;newbuf not implemented&quot;</span><span class="s1">)</span>
    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;pypy no likey&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf__one_channel(self):</span>
        <span class="s1">mixer.init(</span><span class="s4">22050</span><span class="s0">, </span><span class="s1">-</span><span class="s4">16</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self._NEWBUF_export_check()</span>

    <span class="s1">@unittest.skipIf(</span><span class="s0">not </span><span class="s1">pygame.HAVE_NEWBUF</span><span class="s0">, </span><span class="s2">&quot;newbuf not implemented&quot;</span><span class="s1">)</span>
    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;pypy no likey&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_newbuf__twho_channel(self):</span>
        <span class="s1">mixer.init(</span><span class="s4">22050</span><span class="s0">, </span><span class="s1">-</span><span class="s4">16</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self._NEWBUF_export_check()</span>

    <span class="s0">def </span><span class="s1">_NEWBUF_export_check(self):</span>
        <span class="s1">freq</span><span class="s0">, </span><span class="s1">fmt</span><span class="s0">, </span><span class="s1">channels = mixer.get_init()</span>
        <span class="s1">ndim = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">(channels == </span><span class="s4">1</span><span class="s1">) </span><span class="s0">else </span><span class="s4">2</span>
        <span class="s1">itemsize = abs(fmt) // </span><span class="s4">8</span>
        <span class="s1">formats = {</span>
            <span class="s4">8</span><span class="s1">: </span><span class="s2">&quot;B&quot;</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s4">8</span><span class="s1">: </span><span class="s2">&quot;b&quot;</span><span class="s0">,</span>
            <span class="s4">16</span><span class="s1">: </span><span class="s2">&quot;=H&quot;</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s4">16</span><span class="s1">: </span><span class="s2">&quot;=h&quot;</span><span class="s0">,</span>
            <span class="s4">32</span><span class="s1">: </span><span class="s2">&quot;=I&quot;</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s4">32</span><span class="s1">: </span><span class="s2">&quot;=i&quot;</span><span class="s0">,  </span><span class="s3"># 32 and 64 for future consideration</span>
            <span class="s4">64</span><span class="s1">: </span><span class="s2">&quot;=Q&quot;</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s4">64</span><span class="s1">: </span><span class="s2">&quot;=q&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">format = formats[fmt]</span>
        <span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">buftools</span>

        <span class="s1">Exporter = buftools.Exporter</span>
        <span class="s1">Importer = buftools.Importer</span>
        <span class="s1">is_lil_endian = pygame.get_sdl_byteorder() == pygame.LIL_ENDIAN</span>
        <span class="s1">fsys</span><span class="s0">, </span><span class="s1">frev = (</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s1">) </span><span class="s0">if </span><span class="s1">is_lil_endian </span><span class="s0">else </span><span class="s1">(</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;&quot;</span><span class="s1">)</span>
        <span class="s1">shape = (</span><span class="s4">10</span><span class="s0">, </span><span class="s1">channels)[:ndim]</span>
        <span class="s1">strides = (channels * itemsize</span><span class="s0">, </span><span class="s1">itemsize)[</span><span class="s4">2 </span><span class="s1">- ndim :]</span>
        <span class="s1">exp = Exporter(shape</span><span class="s0">, </span><span class="s1">format=frev + </span><span class="s2">&quot;i&quot;</span><span class="s1">)</span>
        <span class="s1">snd = mixer.Sound(array=exp)</span>
        <span class="s1">buflen = len(exp) * itemsize * channels</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_SIMPLE)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.len</span><span class="s0">, </span><span class="s1">buflen)</span>
        <span class="s1">self.assertEqual(imp.itemsize</span><span class="s0">, </span><span class="s1">itemsize)</span>
        <span class="s1">self.assertTrue(imp.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(imp.readonly)</span>
        <span class="s1">self.assertEqual(imp.buf</span><span class="s0">, </span><span class="s1">snd._samples_address)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_WRITABLE)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.len</span><span class="s0">, </span><span class="s1">buflen)</span>
        <span class="s1">self.assertEqual(imp.itemsize</span><span class="s0">, </span><span class="s1">itemsize)</span>
        <span class="s1">self.assertTrue(imp.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(imp.readonly)</span>
        <span class="s1">self.assertEqual(imp.buf</span><span class="s0">, </span><span class="s1">snd._samples_address)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FORMAT)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.format</span><span class="s0">, </span><span class="s1">format)</span>
        <span class="s1">self.assertEqual(imp.len</span><span class="s0">, </span><span class="s1">buflen)</span>
        <span class="s1">self.assertEqual(imp.itemsize</span><span class="s0">, </span><span class="s1">itemsize)</span>
        <span class="s1">self.assertTrue(imp.shape </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(imp.readonly)</span>
        <span class="s1">self.assertEqual(imp.buf</span><span class="s0">, </span><span class="s1">snd._samples_address)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ND)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s1">ndim)</span>
        <span class="s1">self.assertTrue(imp.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.len</span><span class="s0">, </span><span class="s1">buflen)</span>
        <span class="s1">self.assertEqual(imp.itemsize</span><span class="s0">, </span><span class="s1">itemsize)</span>
        <span class="s1">self.assertEqual(imp.shape</span><span class="s0">, </span><span class="s1">shape)</span>
        <span class="s1">self.assertTrue(imp.strides </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertTrue(imp.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(imp.readonly)</span>
        <span class="s1">self.assertEqual(imp.buf</span><span class="s0">, </span><span class="s1">snd._samples_address)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_STRIDES)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s1">ndim)</span>
        <span class="s1">self.assertTrue(imp.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.len</span><span class="s0">, </span><span class="s1">buflen)</span>
        <span class="s1">self.assertEqual(imp.itemsize</span><span class="s0">, </span><span class="s1">itemsize)</span>
        <span class="s1">self.assertEqual(imp.shape</span><span class="s0">, </span><span class="s1">shape)</span>
        <span class="s1">self.assertEqual(imp.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">self.assertTrue(imp.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(imp.readonly)</span>
        <span class="s1">self.assertEqual(imp.buf</span><span class="s0">, </span><span class="s1">snd._samples_address)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FULL_RO)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s1">ndim)</span>
        <span class="s1">self.assertEqual(imp.format</span><span class="s0">, </span><span class="s1">format)</span>
        <span class="s1">self.assertEqual(imp.len</span><span class="s0">, </span><span class="s1">buflen)</span>
        <span class="s1">self.assertEqual(imp.itemsize</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.shape</span><span class="s0">, </span><span class="s1">shape)</span>
        <span class="s1">self.assertEqual(imp.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">self.assertTrue(imp.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(imp.readonly)</span>
        <span class="s1">self.assertEqual(imp.buf</span><span class="s0">, </span><span class="s1">snd._samples_address)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_FULL_RO)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s1">ndim)</span>
        <span class="s1">self.assertEqual(imp.format</span><span class="s0">, </span><span class="s1">format)</span>
        <span class="s1">self.assertEqual(imp.len</span><span class="s0">, </span><span class="s1">buflen)</span>
        <span class="s1">self.assertEqual(imp.itemsize</span><span class="s0">, </span><span class="s1">itemsize)</span>
        <span class="s1">self.assertEqual(imp.shape</span><span class="s0">, </span><span class="s1">exp.shape)</span>
        <span class="s1">self.assertEqual(imp.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">self.assertTrue(imp.suboffsets </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertFalse(imp.readonly)</span>
        <span class="s1">self.assertEqual(imp.buf</span><span class="s0">, </span><span class="s1">snd._samples_address)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_C_CONTIGUOUS)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s1">ndim)</span>
        <span class="s1">self.assertTrue(imp.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_ANY_CONTIGUOUS)</span>
        <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s1">ndim)</span>
        <span class="s1">self.assertTrue(imp.format </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(imp.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s0">if </span><span class="s1">ndim == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">imp = Importer(snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_F_CONTIGUOUS)</span>
            <span class="s1">self.assertEqual(imp.ndim</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self.assertTrue(imp.format </span><span class="s0">is None</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(imp.strides</span><span class="s0">, </span><span class="s1">strides)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.assertRaises(BufferError</span><span class="s0">, </span><span class="s1">Importer</span><span class="s0">, </span><span class="s1">snd</span><span class="s0">, </span><span class="s1">buftools.PyBUF_F_CONTIGUOUS)</span>

    <span class="s0">def </span><span class="s1">todo_test_fadeout(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.fadeout:</span>

        <span class="s3"># pygame.mixer.fadeout(time): return None</span>
        <span class="s3"># fade out the volume on all sounds before stopping</span>
        <span class="s3">#</span>
        <span class="s3"># This will fade out the volume on all active channels over the time</span>
        <span class="s3"># argument in milliseconds. After the sound is muted the playback will</span>
        <span class="s3"># stop.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_find_channel(self):</span>
        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.find_channel:</span>

        <span class="s3"># pygame.mixer.find_channel(force=False): return Channel</span>
        <span class="s3"># find an unused channel</span>
        <span class="s1">mixer.init()</span>

        <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
        <span class="s1">sound = mixer.Sound(file=filename)</span>

        <span class="s1">num_channels = mixer.get_num_channels()</span>

        <span class="s0">if </span><span class="s1">num_channels &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">found_channel = mixer.find_channel()</span>
            <span class="s1">self.assertIsNotNone(found_channel)</span>

            <span class="s3"># try playing on all channels</span>
            <span class="s1">channels = []</span>
            <span class="s0">for </span><span class="s1">channel_id </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">num_channels):</span>
                <span class="s1">channel = mixer.Channel(channel_id)</span>
                <span class="s1">channel.play(sound)</span>
                <span class="s1">channels.append(channel)</span>

            <span class="s3"># should fail without being forceful</span>
            <span class="s1">found_channel = mixer.find_channel()</span>
            <span class="s1">self.assertIsNone(found_channel)</span>

            <span class="s3"># try forcing without keyword</span>
            <span class="s1">found_channel = mixer.find_channel(</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self.assertIsNotNone(found_channel)</span>

            <span class="s3"># try forcing with keyword</span>
            <span class="s1">found_channel = mixer.find_channel(force=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self.assertIsNotNone(found_channel)</span>

            <span class="s0">for </span><span class="s1">channel </span><span class="s0">in </span><span class="s1">channels:</span>
                <span class="s1">channel.stop()</span>
            <span class="s1">found_channel = mixer.find_channel()</span>
            <span class="s1">self.assertIsNotNone(found_channel)</span>

    <span class="s0">def </span><span class="s1">todo_test_get_busy(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.get_busy:</span>

        <span class="s3"># pygame.mixer.get_busy(): return bool</span>
        <span class="s3"># test if any sound is being mixed</span>
        <span class="s3">#</span>
        <span class="s3"># Returns True if the mixer is busy mixing any channels. If the mixer</span>
        <span class="s3"># is idle then this return False.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_pause(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.pause:</span>

        <span class="s3"># pygame.mixer.pause(): return None</span>
        <span class="s3"># temporarily stop playback of all sound channels</span>
        <span class="s3">#</span>
        <span class="s3"># This will temporarily stop all playback on the active mixer</span>
        <span class="s3"># channels. The playback can later be resumed with</span>
        <span class="s3"># pygame.mixer.unpause()</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_set_reserved(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.set_reserved:</span>

        <span class="s3"># pygame.mixer.set_reserved(count): return count</span>
        <span class="s1">mixer.init()</span>
        <span class="s1">default_num_channels = mixer.get_num_channels()</span>

        <span class="s3"># try reserving all the channels</span>
        <span class="s1">result = mixer.set_reserved(default_num_channels)</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">default_num_channels)</span>

        <span class="s3"># try reserving all the channels + 1</span>
        <span class="s1">result = mixer.set_reserved(default_num_channels + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3"># should still be default</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">default_num_channels)</span>

        <span class="s3"># try unreserving all</span>
        <span class="s1">result = mixer.set_reserved(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># should still be default</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s3"># try reserving half</span>
        <span class="s1">result = mixer.set_reserved(int(default_num_channels / </span><span class="s4">2</span><span class="s1">))</span>
        <span class="s3"># should still be default</span>
        <span class="s1">self.assertEqual(result</span><span class="s0">, </span><span class="s1">int(default_num_channels / </span><span class="s4">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">todo_test_stop(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.stop:</span>

        <span class="s3"># pygame.mixer.stop(): return None</span>
        <span class="s3"># stop playback of all sound channels</span>
        <span class="s3">#</span>
        <span class="s3"># This will stop all playback of all active mixer channels.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_unpause(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.unpause:</span>

        <span class="s3"># pygame.mixer.unpause(): return None</span>
        <span class="s3"># resume paused playback of sound channels</span>
        <span class="s3">#</span>
        <span class="s3"># This will resume all active sound channels after they have been paused.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_get_sdl_mixer_version(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensures get_sdl_mixer_version works correctly with no args.&quot;&quot;&quot;</span>
        <span class="s1">expected_length = </span><span class="s4">3</span>
        <span class="s1">expected_type = tuple</span>
        <span class="s1">expected_item_type = int</span>

        <span class="s1">version = pygame.mixer.get_sdl_mixer_version()</span>

        <span class="s1">self.assertIsInstance(version</span><span class="s0">, </span><span class="s1">expected_type)</span>
        <span class="s1">self.assertEqual(len(version)</span><span class="s0">, </span><span class="s1">expected_length)</span>

        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">version:</span>
            <span class="s1">self.assertIsInstance(item</span><span class="s0">, </span><span class="s1">expected_item_type)</span>

    <span class="s0">def </span><span class="s1">test_get_sdl_mixer_version__args(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensures get_sdl_mixer_version works correctly using args.&quot;&quot;&quot;</span>
        <span class="s1">expected_length = </span><span class="s4">3</span>
        <span class="s1">expected_type = tuple</span>
        <span class="s1">expected_item_type = int</span>

        <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">version = pygame.mixer.get_sdl_mixer_version(value)</span>

            <span class="s1">self.assertIsInstance(version</span><span class="s0">, </span><span class="s1">expected_type)</span>
            <span class="s1">self.assertEqual(len(version)</span><span class="s0">, </span><span class="s1">expected_length)</span>

            <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">version:</span>
                <span class="s1">self.assertIsInstance(item</span><span class="s0">, </span><span class="s1">expected_item_type)</span>

    <span class="s0">def </span><span class="s1">test_get_sdl_mixer_version__kwargs(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensures get_sdl_mixer_version works correctly using kwargs.&quot;&quot;&quot;</span>
        <span class="s1">expected_length = </span><span class="s4">3</span>
        <span class="s1">expected_type = tuple</span>
        <span class="s1">expected_item_type = int</span>

        <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">version = pygame.mixer.get_sdl_mixer_version(linked=value)</span>

            <span class="s1">self.assertIsInstance(version</span><span class="s0">, </span><span class="s1">expected_type)</span>
            <span class="s1">self.assertEqual(len(version)</span><span class="s0">, </span><span class="s1">expected_length)</span>

            <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">version:</span>
                <span class="s1">self.assertIsInstance(item</span><span class="s0">, </span><span class="s1">expected_item_type)</span>

    <span class="s0">def </span><span class="s1">test_get_sdl_mixer_version__invalid_args_kwargs(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensures get_sdl_mixer_version handles invalid args and kwargs.&quot;&quot;&quot;</span>
        <span class="s1">invalid_bool = InvalidBool()</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">version = pygame.mixer.get_sdl_mixer_version(invalid_bool)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">version = pygame.mixer.get_sdl_mixer_version(linked=invalid_bool)</span>

    <span class="s0">def </span><span class="s1">test_get_sdl_mixer_version__linked_equals_compiled(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensures get_sdl_mixer_version's linked/compiled versions are equal.&quot;&quot;&quot;</span>
        <span class="s1">linked_version = pygame.mixer.get_sdl_mixer_version(linked=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">complied_version = pygame.mixer.get_sdl_mixer_version(linked=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">self.assertTupleEqual(linked_version</span><span class="s0">, </span><span class="s1">complied_version)</span>


<span class="s3">############################## CHANNEL CLASS TESTS #############################</span>


<span class="s0">class </span><span class="s1">ChannelTypeTest(AssertRaisesRegexMixin</span><span class="s0">, </span><span class="s1">unittest.TestCase):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setUpClass(cls):</span>
        <span class="s3"># Initializing the mixer is slow, so minimize the times it is called.</span>
        <span class="s1">mixer.init()</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">tearDownClass(cls):</span>
        <span class="s1">mixer.quit()</span>

    <span class="s0">def </span><span class="s1">setUp(cls):</span>
        <span class="s3"># This makes sure the mixer is always initialized before each test (in</span>
        <span class="s3"># case a test calls pygame.mixer.quit()).</span>
        <span class="s0">if </span><span class="s1">mixer.get_init() </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mixer.init()</span>

    <span class="s0">def </span><span class="s1">test_channel(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure Channel() creation works.&quot;&quot;&quot;</span>
        <span class="s1">channel = mixer.Channel(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(channel</span><span class="s0">, </span><span class="s1">mixer.ChannelType)</span>
        <span class="s1">self.assertEqual(channel.__class__.__name__</span><span class="s0">, </span><span class="s2">&quot;Channel&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_channel__without_arg(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure exception for Channel() creation with no argument.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">mixer.Channel()</span>

    <span class="s0">def </span><span class="s1">test_channel__invalid_id(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure exception for Channel() creation with an invalid id.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mixer.Channel(-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_channel__before_init(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure exception for Channel() creation with non-init mixer.&quot;&quot;&quot;</span>
        <span class="s1">mixer.quit()</span>

        <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
            <span class="s1">mixer.Channel(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">todo_test_fadeout(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.fadeout:</span>

        <span class="s3"># Channel.fadeout(time): return None</span>
        <span class="s3"># stop playback after fading channel out</span>
        <span class="s3">#</span>
        <span class="s3"># Stop playback of a channel after fading out the sound over the given</span>
        <span class="s3"># time argument in milliseconds.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_get_busy(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure an idle channel's busy state is correct.&quot;&quot;&quot;</span>
        <span class="s1">expected_busy = </span><span class="s0">False</span>
        <span class="s1">channel = mixer.Channel(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">busy = channel.get_busy()</span>

        <span class="s1">self.assertEqual(busy</span><span class="s0">, </span><span class="s1">expected_busy)</span>

    <span class="s0">def </span><span class="s1">todo_test_get_busy__active(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure an active channel's busy state is correct.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_endevent(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.get_endevent:</span>

        <span class="s3"># Channel.get_endevent(): return type</span>
        <span class="s3"># get the event a channel sends when playback stops</span>
        <span class="s3">#</span>
        <span class="s3"># Returns the event type to be sent every time the Channel finishes</span>
        <span class="s3"># playback of a Sound. If there is no endevent the function returns</span>
        <span class="s3"># pygame.NOEVENT.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_queue(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.get_queue:</span>

        <span class="s3"># Channel.get_queue(): return Sound</span>
        <span class="s3"># return any Sound that is queued</span>
        <span class="s3">#</span>
        <span class="s3"># If a Sound is already queued on this channel it will be returned.</span>
        <span class="s3"># Once the queued sound begins playback it will no longer be on the</span>
        <span class="s3"># queue.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_sound(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.get_sound:</span>

        <span class="s3"># Channel.get_sound(): return Sound</span>
        <span class="s3"># get the currently playing Sound</span>
        <span class="s3">#</span>
        <span class="s3"># Return the actual Sound object currently playing on this channel. If</span>
        <span class="s3"># the channel is idle None is returned.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_get_volume(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure a channel's volume can be retrieved.&quot;&quot;&quot;</span>
        <span class="s1">expected_volume = </span><span class="s4">1.0  </span><span class="s3"># default</span>
        <span class="s1">channel = mixer.Channel(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">volume = channel.get_volume()</span>

        <span class="s1">self.assertAlmostEqual(volume</span><span class="s0">, </span><span class="s1">expected_volume)</span>

    <span class="s0">def </span><span class="s1">todo_test_get_volume__while_playing(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure a channel's volume can be retrieved while playing.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_pause(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.pause:</span>

        <span class="s3"># Channel.pause(): return None</span>
        <span class="s3"># temporarily stop playback of a channel</span>
        <span class="s3">#</span>
        <span class="s3"># Temporarily stop the playback of sound on a channel. It can be</span>
        <span class="s3"># resumed at a later time with Channel.unpause()</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_play(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.play:</span>

        <span class="s3"># Channel.play(Sound, loops=0, maxtime=0, fade_ms=0): return None</span>
        <span class="s3"># play a Sound on a specific Channel</span>
        <span class="s3">#</span>
        <span class="s3"># This will begin playback of a Sound on a specific Channel. If the</span>
        <span class="s3"># Channel is currently playing any other Sound it will be stopped.</span>
        <span class="s3">#</span>
        <span class="s3"># The loops argument has the same meaning as in Sound.play(): it is</span>
        <span class="s3"># the number of times to repeat the sound after the first time. If it</span>
        <span class="s3"># is 3, the sound will be played 4 times (the first time, then three</span>
        <span class="s3"># more). If loops is -1 then the playback will repeat indefinitely.</span>
        <span class="s3">#</span>
        <span class="s3"># As in Sound.play(), the maxtime argument can be used to stop</span>
        <span class="s3"># playback of the Sound after a given number of milliseconds.</span>
        <span class="s3">#</span>
        <span class="s3"># As in Sound.play(), the fade_ms argument can be used fade in the sound.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_queue(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.queue:</span>

        <span class="s3"># Channel.queue(Sound): return None</span>
        <span class="s3"># queue a Sound object to follow the current</span>
        <span class="s3">#</span>
        <span class="s3"># When a Sound is queued on a Channel, it will begin playing</span>
        <span class="s3"># immediately after the current Sound is finished. Each channel can</span>
        <span class="s3"># only have a single Sound queued at a time. The queued Sound will</span>
        <span class="s3"># only play if the current playback finished automatically. It is</span>
        <span class="s3"># cleared on any other call to Channel.stop() or Channel.play().</span>
        <span class="s3">#</span>
        <span class="s3"># If there is no sound actively playing on the Channel then the Sound</span>
        <span class="s3"># will begin playing immediately.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_set_endevent(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.set_endevent:</span>

        <span class="s3"># Channel.set_endevent(): return None</span>
        <span class="s3"># Channel.set_endevent(type): return None</span>
        <span class="s3"># have the channel send an event when playback stops</span>
        <span class="s3">#</span>
        <span class="s3"># When an endevent is set for a channel, it will send an event to the</span>
        <span class="s3"># pygame queue every time a sound finishes playing on that channel</span>
        <span class="s3"># (not just the first time). Use pygame.event.get() to retrieve the</span>
        <span class="s3"># endevent once it's sent.</span>
        <span class="s3">#</span>
        <span class="s3"># Note that if you called Sound.play(n) or Channel.play(sound,n), the</span>
        <span class="s3"># end event is sent only once: after the sound has been played &quot;n+1&quot;</span>
        <span class="s3"># times (see the documentation of Sound.play).</span>
        <span class="s3">#</span>
        <span class="s3"># If Channel.stop() or Channel.play() is called while the sound was</span>
        <span class="s3"># still playing, the event will be posted immediately.</span>
        <span class="s3">#</span>
        <span class="s3"># The type argument will be the event id sent to the queue. This can</span>
        <span class="s3"># be any valid event type, but a good choice would be a value between</span>
        <span class="s3"># pygame.locals.USEREVENT and pygame.locals.NUMEVENTS. If no type</span>
        <span class="s3"># argument is given then the Channel will stop sending endevents.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_set_volume(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.set_volume:</span>

        <span class="s3"># Channel.set_volume(value): return None</span>
        <span class="s3"># Channel.set_volume(left, right): return None</span>
        <span class="s3"># set the volume of a playing channel</span>
        <span class="s3">#</span>
        <span class="s3"># Set the volume (loudness) of a playing sound. When a channel starts</span>
        <span class="s3"># to play its volume value is reset. This only affects the current</span>
        <span class="s3"># sound. The value argument is between 0.0 and 1.0.</span>
        <span class="s3">#</span>
        <span class="s3"># If one argument is passed, it will be the volume of both speakers.</span>
        <span class="s3"># If two arguments are passed and the mixer is in stereo mode, the</span>
        <span class="s3"># first argument will be the volume of the left speaker and the second</span>
        <span class="s3"># will be the volume of the right speaker. (If the second argument is</span>
        <span class="s3"># None, the first argument will be the volume of both speakers.)</span>
        <span class="s3">#</span>
        <span class="s3"># If the channel is playing a Sound on which set_volume() has also</span>
        <span class="s3"># been called, both calls are taken into account. For example:</span>
        <span class="s3">#</span>
        <span class="s3">#     sound = pygame.mixer.Sound(&quot;s.wav&quot;)</span>
        <span class="s3">#     channel = s.play()      # Sound plays at full volume by default</span>
        <span class="s3">#     sound.set_volume(0.9)   # Now plays at 90% of full volume.</span>
        <span class="s3">#     sound.set_volume(0.6)   # Now plays at 60% (previous value replaced).</span>
        <span class="s3">#     channel.set_volume(0.5) # Now plays at 30% (0.6 * 0.5).</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_stop(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.stop:</span>

        <span class="s3"># Channel.stop(): return None</span>
        <span class="s3"># stop playback on a Channel</span>
        <span class="s3">#</span>
        <span class="s3"># Stop sound playback on a channel. After playback is stopped the</span>
        <span class="s3"># channel becomes available for new Sounds to play on it.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_unpause(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Channel.unpause:</span>

        <span class="s3"># Channel.unpause(): return None</span>
        <span class="s3"># resume pause playback of a channel</span>
        <span class="s3">#</span>
        <span class="s3"># Resume the playback on a paused channel.</span>

        <span class="s1">self.fail()</span>


<span class="s3">############################### SOUND CLASS TESTS ##############################</span>


<span class="s0">class </span><span class="s1">SoundTypeTest(AssertRaisesRegexMixin</span><span class="s0">, </span><span class="s1">unittest.TestCase):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">tearDownClass(cls):</span>
        <span class="s1">mixer.quit()</span>

    <span class="s0">def </span><span class="s1">setUp(cls):</span>
        <span class="s3"># This makes sure the mixer is always initialized before each test (in</span>
        <span class="s3"># case a test calls pygame.mixer.quit()).</span>
        <span class="s0">if </span><span class="s1">mixer.get_init() </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mixer.init()</span>

    <span class="s3"># See MixerModuleTest's methods test_sound_args(), test_sound_unicode(),</span>
    <span class="s3"># and test_array_keyword() for additional testing of Sound() creation.</span>
    <span class="s0">def </span><span class="s1">test_sound(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure Sound() creation with a filename works.&quot;&quot;&quot;</span>
        <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
        <span class="s1">sound1 = mixer.Sound(filename)</span>
        <span class="s1">sound2 = mixer.Sound(file=filename)</span>

        <span class="s1">self.assertIsInstance(sound1</span><span class="s0">, </span><span class="s1">mixer.Sound)</span>
        <span class="s1">self.assertIsInstance(sound2</span><span class="s0">, </span><span class="s1">mixer.Sound)</span>

    <span class="s0">def </span><span class="s1">test_sound__from_file_object(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure Sound() creation with a file object works.&quot;&quot;&quot;</span>
        <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>

        <span class="s3"># Using 'with' ensures the file is closed even if test fails.</span>
        <span class="s0">with </span><span class="s1">open(filename</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">file_obj:</span>
            <span class="s1">sound = mixer.Sound(file_obj)</span>

            <span class="s1">self.assertIsInstance(sound</span><span class="s0">, </span><span class="s1">mixer.Sound)</span>

    <span class="s0">def </span><span class="s1">test_sound__from_sound_object(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure Sound() creation with a Sound() object works.&quot;&quot;&quot;</span>
        <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
        <span class="s1">sound_obj = mixer.Sound(file=filename)</span>

        <span class="s1">sound = mixer.Sound(sound_obj)</span>

        <span class="s1">self.assertIsInstance(sound</span><span class="s0">, </span><span class="s1">mixer.Sound)</span>

    <span class="s0">def </span><span class="s1">test_sound__from_pathlib(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure Sound() creation with a pathlib.Path object works.&quot;&quot;&quot;</span>
        <span class="s1">path = pathlib.Path(example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">)))</span>
        <span class="s1">sound1 = mixer.Sound(path)</span>
        <span class="s1">sound2 = mixer.Sound(file=path)</span>
        <span class="s1">self.assertIsInstance(sound1</span><span class="s0">, </span><span class="s1">mixer.Sound)</span>
        <span class="s1">self.assertIsInstance(sound2</span><span class="s0">, </span><span class="s1">mixer.Sound)</span>

    <span class="s0">def </span><span class="s1">todo_test_sound__from_buffer(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure Sound() creation with a buffer works.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_sound__from_array(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure Sound() creation with an array works.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_sound__without_arg(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure exception raised for Sound() creation with no argument.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">mixer.Sound()</span>

    <span class="s0">def </span><span class="s1">test_sound__before_init(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure exception raised for Sound() creation with non-init mixer.&quot;&quot;&quot;</span>
        <span class="s1">mixer.quit()</span>
        <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
            <span class="s1">mixer.Sound(file=filename)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;pypy skip&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_samples_address(self):</span>
        <span class="s5">&quot;&quot;&quot;Test the _samples_address getter.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">ctypes </span><span class="s0">import </span><span class="s1">pythonapi</span><span class="s0">, </span><span class="s1">c_void_p</span><span class="s0">, </span><span class="s1">py_object</span>

            <span class="s1">Bytes_FromString = pythonapi.PyBytes_FromString</span>

            <span class="s1">Bytes_FromString.restype = c_void_p</span>
            <span class="s1">Bytes_FromString.argtypes = [py_object]</span>
            <span class="s1">samples = </span><span class="s6">b&quot;abcdefgh&quot;  </span><span class="s3"># keep byte size a multiple of 4</span>
            <span class="s1">sample_bytes = Bytes_FromString(samples)</span>

            <span class="s1">snd = mixer.Sound(buffer=samples)</span>

            <span class="s1">self.assertNotEqual(snd._samples_address</span><span class="s0">, </span><span class="s1">sample_bytes)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.mixer.quit()</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
                <span class="s1">snd._samples_address</span>

    <span class="s0">def </span><span class="s1">todo_test_fadeout(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Sound.fadeout:</span>

        <span class="s3"># Sound.fadeout(time): return None</span>
        <span class="s3"># stop sound playback after fading out</span>
        <span class="s3">#</span>
        <span class="s3"># This will stop playback of the sound after fading it out over the</span>
        <span class="s3"># time argument in milliseconds. The Sound will fade and stop on all</span>
        <span class="s3"># actively playing channels.</span>
        <span class="s3">#</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_get_length(self):</span>
        <span class="s5">&quot;&quot;&quot;Tests if get_length returns a correct length.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">SIZES:</span>
                <span class="s1">pygame.mixer.quit()</span>
                <span class="s1">pygame.mixer.init(size=size)</span>
                <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;punch.wav&quot;</span><span class="s1">))</span>
                <span class="s1">sound = mixer.Sound(file=filename)</span>
                <span class="s3"># The sound data is in the mixer output format. So dividing the</span>
                <span class="s3"># length of the raw sound data by the mixer settings gives</span>
                <span class="s3"># the expected length of the sound.</span>
                <span class="s1">sound_bytes = sound.get_raw()</span>
                <span class="s1">mix_freq</span><span class="s0">, </span><span class="s1">mix_bits</span><span class="s0">, </span><span class="s1">mix_channels = pygame.mixer.get_init()</span>
                <span class="s1">mix_bytes = abs(mix_bits) / </span><span class="s4">8</span>
                <span class="s1">expected_length = (</span>
                    <span class="s1">float(len(sound_bytes)) / mix_freq / mix_bytes / mix_channels</span>
                <span class="s1">)</span>
                <span class="s1">self.assertAlmostEqual(expected_length</span><span class="s0">, </span><span class="s1">sound.get_length())</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.mixer.quit()</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
                <span class="s1">sound.get_length()</span>

    <span class="s0">def </span><span class="s1">test_get_num_channels(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Tests if Sound.get_num_channels returns the correct number 
        of channels playing a specific sound. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
            <span class="s1">sound = mixer.Sound(file=filename)</span>

            <span class="s1">self.assertEqual(sound.get_num_channels()</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">sound.play()</span>
            <span class="s1">self.assertEqual(sound.get_num_channels()</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">sound.play()</span>
            <span class="s1">self.assertEqual(sound.get_num_channels()</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">sound.stop()</span>
            <span class="s1">self.assertEqual(sound.get_num_channels()</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.mixer.quit()</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
                <span class="s1">sound.get_num_channels()</span>

    <span class="s0">def </span><span class="s1">test_get_volume(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure a sound's volume can be retrieved.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">expected_volume = </span><span class="s4">1.0  </span><span class="s3"># default</span>
            <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
            <span class="s1">sound = mixer.Sound(file=filename)</span>

            <span class="s1">volume = sound.get_volume()</span>

            <span class="s1">self.assertAlmostEqual(volume</span><span class="s0">, </span><span class="s1">expected_volume)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.mixer.quit()</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
                <span class="s1">sound.get_volume()</span>

    <span class="s0">def </span><span class="s1">todo_test_get_volume__while_playing(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure a sound's volume can be retrieved while playing.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">todo_test_play(self):</span>

        <span class="s3"># __doc__ (as of 2008-08-02) for pygame.mixer.Sound.play:</span>

        <span class="s3"># Sound.play(loops=0, maxtime=0, fade_ms=0): return Channel</span>
        <span class="s3"># begin sound playback</span>
        <span class="s3">#</span>
        <span class="s3"># Begin playback of the Sound (i.e., on the computer's speakers) on an</span>
        <span class="s3"># available Channel. This will forcibly select a Channel, so playback</span>
        <span class="s3"># may cut off a currently playing sound if necessary.</span>
        <span class="s3">#</span>
        <span class="s3"># The loops argument controls how many times the sample will be</span>
        <span class="s3"># repeated after being played the first time. A value of 5 means that</span>
        <span class="s3"># the sound will be played once, then repeated five times, and so is</span>
        <span class="s3"># played a total of six times. The default value (zero) means the</span>
        <span class="s3"># Sound is not repeated, and so is only played once. If loops is set</span>
        <span class="s3"># to -1 the Sound will loop indefinitely (though you can still call</span>
        <span class="s3"># stop() to stop it).</span>
        <span class="s3">#</span>
        <span class="s3"># The maxtime argument can be used to stop playback after a given</span>
        <span class="s3"># number of milliseconds.</span>
        <span class="s3">#</span>
        <span class="s3"># The fade_ms argument will make the sound start playing at 0 volume</span>
        <span class="s3"># and fade up to full volume over the time given. The sample may end</span>
        <span class="s3"># before the fade-in is complete.</span>
        <span class="s3">#</span>
        <span class="s3"># This returns the Channel object for the channel that was selected.</span>

        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_set_volume(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure a sound's volume can be set.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">float_delta = </span><span class="s4">1.0 </span><span class="s1">/ </span><span class="s4">128  </span><span class="s3"># SDL volume range is 0 to 128</span>
            <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
            <span class="s1">sound = mixer.Sound(file=filename)</span>
            <span class="s1">current_volume = sound.get_volume()</span>

            <span class="s3"># (volume_set_value : expected_volume)</span>
            <span class="s1">volumes = (</span>
                <span class="s1">(-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">current_volume)</span><span class="s0">,  </span><span class="s3"># value &lt; 0 won't change volume</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">0.01</span><span class="s0">, </span><span class="s4">0.01</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">0.9</span><span class="s0">, </span><span class="s4">0.9</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">0.99</span><span class="s0">, </span><span class="s4">0.99</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">1.1</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s0">for </span><span class="s1">volume_set_value</span><span class="s0">, </span><span class="s1">expected_volume </span><span class="s0">in </span><span class="s1">volumes:</span>
                <span class="s1">sound.set_volume(volume_set_value)</span>

                <span class="s1">self.assertAlmostEqual(</span>
                    <span class="s1">sound.get_volume()</span><span class="s0">, </span><span class="s1">expected_volume</span><span class="s0">, </span><span class="s1">delta=float_delta</span>
                <span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.mixer.quit()</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
                <span class="s1">sound.set_volume(</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">todo_test_set_volume__while_playing(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure a sound's volume can be set while playing.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_stop(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure stop can be called while not playing a sound.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">expected_channels = </span><span class="s4">0</span>
            <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
            <span class="s1">sound = mixer.Sound(file=filename)</span>

            <span class="s1">sound.stop()</span>

            <span class="s1">self.assertEqual(sound.get_num_channels()</span><span class="s0">, </span><span class="s1">expected_channels)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.mixer.quit()</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
                <span class="s1">sound.stop()</span>

    <span class="s0">def </span><span class="s1">todo_test_stop__while_playing(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure stop stops a playing sound.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_get_raw(self):</span>
        <span class="s5">&quot;&quot;&quot;Ensure get_raw returns the correct bytestring.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">samples = </span><span class="s6">b&quot;abcdefgh&quot;  </span><span class="s3"># keep byte size a multiple of 4</span>
            <span class="s1">snd = mixer.Sound(buffer=samples)</span>

            <span class="s1">raw = snd.get_raw()</span>

            <span class="s1">self.assertIsInstance(raw</span><span class="s0">, </span><span class="s1">bytes)</span>
            <span class="s1">self.assertEqual(raw</span><span class="s0">, </span><span class="s1">samples)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">pygame.mixer.quit()</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(pygame.error</span><span class="s0">, </span><span class="s2">&quot;mixer not initialized&quot;</span><span class="s1">):</span>
                <span class="s1">snd.get_raw()</span>

    <span class="s0">def </span><span class="s1">test_correct_subclassing(self):</span>
        <span class="s0">class </span><span class="s1">CorrectSublass(mixer.Sound):</span>
            <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">file):</span>
                <span class="s1">super().__init__(file=file)</span>

        <span class="s1">filename = example_path(os.path.join(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s2">&quot;house_lo.wav&quot;</span><span class="s1">))</span>
        <span class="s1">correct = CorrectSublass(filename)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">correct.get_volume()</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s1">self.fail(</span><span class="s2">&quot;This should not raise an exception.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_incorrect_subclassing(self):</span>
        <span class="s0">class </span><span class="s1">IncorrectSuclass(mixer.Sound):</span>
            <span class="s0">def </span><span class="s1">__init__(self):</span>
                <span class="s0">pass</span>

        <span class="s1">incorrect = IncorrectSuclass()</span>

        <span class="s1">self.assertRaises(RuntimeError</span><span class="s0">, </span><span class="s1">incorrect.get_volume)</span>


<span class="s3">##################################### MAIN #####################################</span>

<span class="s0">if </span><span class="s1">__name__ == </span><span class="s2">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">unittest.main()</span>
</pre>
</body>
</html>