<html>
<head>
<title>sprite.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sprite.py</font>
</center></td></tr></table>
<pre><span class="s0">#    pygame - Python Game Library</span>
<span class="s0">#    Copyright (C) 2000-2003, 2007  Pete Shinners</span>
<span class="s0">#              (C) 2004 Joe Wreschnig</span>
<span class="s0">#    This library is free software; you can redistribute it and/or</span>
<span class="s0">#    modify it under the terms of the GNU Library General Public</span>
<span class="s0">#    License as published by the Free Software Foundation; either</span>
<span class="s0">#    version 2 of the License, or (at your option) any later version.</span>
<span class="s0">#</span>
<span class="s0">#    This library is distributed in the hope that it will be useful,</span>
<span class="s0">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="s0">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="s0">#    Library General Public License for more details.</span>
<span class="s0">#</span>
<span class="s0">#    You should have received a copy of the GNU Library General Public</span>
<span class="s0">#    License along with this library; if not, write to the Free</span>
<span class="s0">#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="s0">#</span>
<span class="s0">#    Pete Shinners</span>
<span class="s0">#    pete@shinners.org</span>

<span class="s2">&quot;&quot;&quot;pygame module with basic game object classes 
 
This module contains several simple classes to be used within games. There 
are the main Sprite class and several Group classes that contain Sprites. 
The use of these classes is entirely optional when using Pygame. The classes 
are fairly lightweight and only provide a starting place for the code 
that is common to most games. 
 
The Sprite class is intended to be used as a base class for the different 
types of objects in the game. There is also a base Group class that simply 
stores sprites. A game could create new types of Group classes that operate 
on specially customized Sprite instances they contain. 
 
The basic Sprite class can draw the Sprites it contains to a Surface. The 
Group.draw() method requires that each Sprite have a Surface.image attribute 
and a Surface.rect. The Group.clear() method requires these same attributes 
and can be used to erase all the Sprites with background. There are also 
more advanced Groups: pygame.sprite.RenderUpdates() and 
pygame.sprite.OrderedUpdates(). 
 
Lastly, this module contains several collision functions. These help find 
sprites inside multiple groups that have intersecting bounding rectangles. 
To find the collisions, the Sprites are required to have a Surface.rect 
attribute assigned. 
 
The groups are designed for high efficiency in removing and adding Sprites 
to them. They also allow cheap testing to see if a Sprite already exists in 
a Group. A given Sprite can exist in any number of groups. A game could use 
some groups to control object rendering, and a completely separate set of 
groups to control interaction or player movement. Instead of adding type 
attributes or bools to a derived Sprite class, consider keeping the 
Sprites inside organized Groups. This will allow for easier lookup later 
in the game. 
 
Sprites and Groups manage their relationships with the add() and remove() 
methods. These methods can accept a single or multiple group arguments for 
membership.  The default initializers for these classes also take a 
single group or list of groups as arguments for initial membership. It is safe 
to repeatedly add and remove the same Sprite from a Group. 
 
While it is possible to design sprite and group classes that don't derive 
from the Sprite and AbstractGroup classes below, it is strongly recommended 
that you extend those when you create a new Sprite or Group class. 
 
Sprites are not thread safe, so lock them yourself if using threads. 
 
&quot;&quot;&quot;</span>

<span class="s0"># TODO:  a group that holds only the 'n' most recent elements.</span>
<span class="s0">#        sort of like the GroupSingle class, but holding more</span>
<span class="s0">#        than one sprite</span>
<span class="s0">#</span>
<span class="s0"># drawing groups that can 'automatically' store the area</span>
<span class="s0"># underneath so they can &quot;clear&quot; without needing a background</span>
<span class="s0"># function. obviously a little slower than normal, but nice</span>
<span class="s0"># to use in many situations. (also remember it must &quot;clear&quot;</span>
<span class="s0"># in the reverse order that it draws :])</span>
<span class="s0">#</span>
<span class="s0"># the drawing groups should also be able to take a background</span>
<span class="s0"># function, instead of just a background surface. the function</span>
<span class="s0"># would take a surface and a rectangle on that surface to erase.</span>
<span class="s0">#</span>
<span class="s0"># perhaps more types of collision functions? the current two</span>
<span class="s0"># should handle just about every need, but perhaps more optimized</span>
<span class="s0"># specific ones that aren't quite so general but fit into common</span>
<span class="s0"># specialized cases.</span>

<span class="s3">from </span><span class="s1">warnings </span><span class="s3">import </span><span class="s1">warn</span>

<span class="s3">import </span><span class="s1">pygame</span>

<span class="s3">from </span><span class="s1">pygame.rect </span><span class="s3">import </span><span class="s1">Rect</span>
<span class="s3">from </span><span class="s1">pygame.time </span><span class="s3">import </span><span class="s1">get_ticks</span>
<span class="s3">from </span><span class="s1">pygame.mask </span><span class="s3">import </span><span class="s1">from_surface</span>


<span class="s3">class </span><span class="s1">Sprite:</span>
    <span class="s2">&quot;&quot;&quot;simple base class for visible game objects 
 
    pygame.sprite.Sprite(*groups): return Sprite 
 
    The base class for visible game objects. Derived classes will want to 
    override the Sprite.update() method and assign Sprite.image and Sprite.rect 
    attributes.  The initializer can accept any number of Group instances that 
    the Sprite will become a member of. 
 
    When subclassing the Sprite class, be sure to call the base initializer 
    before adding the Sprite to Groups. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*groups):</span>
        <span class="s1">self.__g = {}  </span><span class="s0"># The groups the sprite is in</span>
        <span class="s3">if </span><span class="s1">groups:</span>
            <span class="s1">self.add(*groups)</span>

    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">*groups):</span>
        <span class="s2">&quot;&quot;&quot;add the sprite to groups 
 
        Sprite.add(*groups): return None 
 
        Any number of Group instances can be passed as arguments. The 
        Sprite will be added to the Groups it is not already a member of. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">has = self.__g.__contains__</span>
        <span class="s3">for </span><span class="s1">group </span><span class="s3">in </span><span class="s1">groups:</span>
            <span class="s3">if </span><span class="s1">hasattr(group</span><span class="s3">, </span><span class="s4">&quot;_spritegroup&quot;</span><span class="s1">):</span>
                <span class="s3">if not </span><span class="s1">has(group):</span>
                    <span class="s1">group.add_internal(self)</span>
                    <span class="s1">self.add_internal(group)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.add(*group)</span>

    <span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">*groups):</span>
        <span class="s2">&quot;&quot;&quot;remove the sprite from groups 
 
        Sprite.remove(*groups): return None 
 
        Any number of Group instances can be passed as arguments. The Sprite 
        will be removed from the Groups it is currently a member of. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">has = self.__g.__contains__</span>
        <span class="s3">for </span><span class="s1">group </span><span class="s3">in </span><span class="s1">groups:</span>
            <span class="s3">if </span><span class="s1">hasattr(group</span><span class="s3">, </span><span class="s4">&quot;_spritegroup&quot;</span><span class="s1">):</span>
                <span class="s3">if </span><span class="s1">has(group):</span>
                    <span class="s1">group.remove_internal(self)</span>
                    <span class="s1">self.remove_internal(group)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.remove(*group)</span>

    <span class="s3">def </span><span class="s1">add_internal(self</span><span class="s3">, </span><span class="s1">group):</span>
        <span class="s2">&quot;&quot;&quot; 
        For adding this sprite to a group internally. 
 
        :param group: The group we are adding to. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__g[group] = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">remove_internal(self</span><span class="s3">, </span><span class="s1">group):</span>
        <span class="s2">&quot;&quot;&quot; 
        For removing this sprite from a group internally. 
 
        :param group: The group we are removing from. 
        &quot;&quot;&quot;</span>
        <span class="s3">del </span><span class="s1">self.__g[group]</span>

    <span class="s3">def </span><span class="s1">update(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;method to control sprite behavior 
 
        Sprite.update(*args, **kwargs): 
 
        The default implementation of this method does nothing; it's just a 
        convenient &quot;hook&quot; that you can override. This method is called by 
        Group.update() with whatever arguments you give it. 
 
        There is no need to use this method if not using the convenience 
        method by the same name in the Group class. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">kill(self):</span>
        <span class="s2">&quot;&quot;&quot;remove the Sprite from all Groups 
 
        Sprite.kill(): return None 
 
        The Sprite is removed from all the Groups that contain it. This won't 
        change anything about the state of the Sprite. It is possible to 
        continue to use the Sprite after this method has been called, including 
        adding it to Groups. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">group </span><span class="s3">in </span><span class="s1">self.__g:</span>
            <span class="s1">group.remove_internal(self)</span>
        <span class="s1">self.__g.clear()</span>

    <span class="s3">def </span><span class="s1">groups(self):</span>
        <span class="s2">&quot;&quot;&quot;list of Groups that contain this Sprite 
 
        Sprite.groups(): return group_list 
 
        Returns a list of all the Groups that contain this Sprite. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">list(self.__g)</span>

    <span class="s3">def </span><span class="s1">alive(self):</span>
        <span class="s2">&quot;&quot;&quot;does the sprite belong to any groups 
 
        Sprite.alive(): return bool 
 
        Returns True when the Sprite belongs to one or more Groups. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">bool(self.__g)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">f&quot;&lt;</span><span class="s3">{</span><span class="s1">self.__class__.__name__</span><span class="s3">} </span><span class="s4">Sprite(in </span><span class="s3">{</span><span class="s1">len(self.__g)</span><span class="s3">} </span><span class="s4">groups)&gt;&quot;</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">layer(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Dynamic, read only property for protected _layer attribute. 
        This will get the _layer variable if it exists. 
 
        If you try to get it before it is set it will raise an attribute error. 
 
        Layer property can only be set before the sprite is added to a group, 
        after that it is read only and a sprite's layer in a group should be 
        set via the group's change_layer() method. 
 
        :return: layer as an int, or raise AttributeError. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s1">)</span>

    <span class="s1">@layer.setter</span>
    <span class="s3">def </span><span class="s1">layer(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if not </span><span class="s1">self.alive():</span>
            <span class="s1">setattr(self</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">&quot;Can't set layer directly after &quot;</span>
                <span class="s4">&quot;adding to group. Use &quot;</span>
                <span class="s4">&quot;group.change_layer(sprite, new_layer) &quot;</span>
                <span class="s4">&quot;instead.&quot;</span>
            <span class="s1">)</span>


<span class="s3">class </span><span class="s1">DirtySprite(Sprite):</span>
    <span class="s2">&quot;&quot;&quot;a more featureful subclass of Sprite with more attributes 
 
    pygame.sprite.DirtySprite(*groups): return DirtySprite 
 
    Extra DirtySprite attributes with their default values: 
 
    dirty = 1 
        If set to 1, it is repainted and then set to 0 again. 
        If set to 2, it is always dirty (repainted each frame; 
        flag is not reset). 
        If set to 0, it is not dirty and therefore not repainted again. 
 
    blendmode = 0 
        It's the special_flags argument of Surface.blit; see the blendmodes in 
        the Surface.blit documentation 
 
    source_rect = None 
        This is the source rect to use. Remember that it is relative to the top 
        left corner (0, 0) of self.image. 
 
    visible = 1 
        Normally this is 1. If set to 0, it will not be repainted. (If you 
        change visible to 1, you must set dirty to 1 for it to be erased from 
        the screen.) 
 
    _layer = 0 
        0 is the default value but this is able to be set differently 
        when subclassing. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*groups):</span>

        <span class="s1">self.dirty = </span><span class="s5">1</span>

        <span class="s0"># referred to as special_flags in the documentation of Surface.blit</span>
        <span class="s1">self.blendmode = </span><span class="s5">0</span>
        <span class="s1">self._visible = </span><span class="s5">1</span>

        <span class="s0"># Default 0 unless initialized differently.</span>
        <span class="s1">self._layer = getattr(self</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.source_rect = </span><span class="s3">None</span>
        <span class="s1">Sprite.__init__(self</span><span class="s3">, </span><span class="s1">*groups)</span>

    <span class="s3">def </span><span class="s1">_set_visible(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s2">&quot;&quot;&quot;set the visible value (0 or 1) and makes the sprite dirty&quot;&quot;&quot;</span>
        <span class="s1">self._visible = val</span>
        <span class="s3">if </span><span class="s1">self.dirty &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">self.dirty = </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">_get_visible(self):</span>
        <span class="s2">&quot;&quot;&quot;return the visible value of that sprite&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._visible</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">visible(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        You can make this sprite disappear without removing it from the group 
        assign 0 for invisible and 1 for visible 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._get_visible()</span>

    <span class="s1">@visible.setter</span>
    <span class="s3">def </span><span class="s1">visible(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">self._set_visible(value)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">layer(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Layer property can only be set before the sprite is added to a group, 
        after that it is read only and a sprite's layer in a group should be 
        set via the group's change_layer() method. 
 
        Overwrites dynamic property from sprite class for speed. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._layer</span>

    <span class="s1">@layer.setter</span>
    <span class="s3">def </span><span class="s1">layer(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if not </span><span class="s1">self.alive():</span>
            <span class="s1">self._layer = value</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">&quot;Can't set layer directly after &quot;</span>
                <span class="s4">&quot;adding to group. Use &quot;</span>
                <span class="s4">&quot;group.change_layer(sprite, new_layer) &quot;</span>
                <span class="s4">&quot;instead.&quot;</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s4">f&quot;&lt;</span><span class="s3">{</span><span class="s1">self.__class__.__name__</span><span class="s3">} </span><span class="s4">DirtySprite(in </span><span class="s3">{</span><span class="s1">len(self.groups())</span><span class="s3">} </span><span class="s4">groups)&gt;&quot;</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">AbstractGroup:</span>
    <span class="s2">&quot;&quot;&quot;base class for containers of sprites 
 
    AbstractGroup does everything needed to behave as a normal group. You can 
    easily subclass a new group class from this or the other groups below if 
    you want to add more features. 
 
    Any AbstractGroup-derived sprite groups act like sequences and support 
    iteration, len, and so on. 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># dummy val to identify sprite groups, and avoid infinite recursion</span>
    <span class="s1">_spritegroup = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.spritedict = {}</span>
        <span class="s1">self.lostsprites = []</span>

    <span class="s3">def </span><span class="s1">sprites(self):</span>
        <span class="s2">&quot;&quot;&quot;get a list of sprites in the group 
 
        Group.sprite(): return list 
 
        Returns an object that can be looped over with a 'for' loop. (For now, 
        it is always a list, but this could change in a future version of 
        pygame.) Alternatively, you can get the same information by iterating 
        directly over the sprite group, e.g. 'for sprite in group'. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">list(self.spritedict)</span>

    <span class="s3">def </span><span class="s1">add_internal(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">sprite</span><span class="s3">,</span>
        <span class="s1">layer=</span><span class="s3">None,  </span><span class="s0"># noqa pylint: disable=unused-argument; supporting legacy derived classes that override in non-pythonic way</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        For adding a sprite to this group internally. 
 
        :param sprite: The sprite we are adding. 
        :param layer: the layer to add to, if the group type supports layers 
        &quot;&quot;&quot;</span>
        <span class="s1">self.spritedict[sprite] = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">remove_internal(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s2">&quot;&quot;&quot; 
        For removing a sprite from this group internally. 
 
        :param sprite: The sprite we are removing. 
        &quot;&quot;&quot;</span>
        <span class="s1">lost_rect = self.spritedict[sprite]</span>
        <span class="s3">if </span><span class="s1">lost_rect:</span>
            <span class="s1">self.lostsprites.append(lost_rect)</span>
        <span class="s3">del </span><span class="s1">self.spritedict[sprite]</span>

    <span class="s3">def </span><span class="s1">has_internal(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s2">&quot;&quot;&quot; 
        For checking if a sprite is in this group internally. 
 
        :param sprite: The sprite we are checking. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">self.spritedict</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s2">&quot;&quot;&quot;copy a group with all the same sprites 
 
        Group.copy(): return Group 
 
        Returns a copy of the group that is an instance of the same class 
        and has the same sprites in it. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.__class__(  </span><span class="s0"># noqa pylint: disable=too-many-function-args</span>
            <span class="s1">self.sprites()  </span><span class="s0"># Needed because copy() won't work on AbstractGroup</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s3">return </span><span class="s1">iter(self.sprites())</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s3">return </span><span class="s1">self.has(sprite)</span>

    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">*sprites):</span>
        <span class="s2">&quot;&quot;&quot;add sprite(s) to group 
 
        Group.add(sprite, list, group, ...): return None 
 
        Adds a sprite or sequence of sprites to a group. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">sprites:</span>
            <span class="s0"># It's possible that some sprite is also an iterator.</span>
            <span class="s0"># If this is the case, we should add the sprite itself,</span>
            <span class="s0"># and not the iterator object.</span>
            <span class="s3">if </span><span class="s1">isinstance(sprite</span><span class="s3">, </span><span class="s1">Sprite):</span>
                <span class="s3">if not </span><span class="s1">self.has_internal(sprite):</span>
                    <span class="s1">self.add_internal(sprite)</span>
                    <span class="s1">sprite.add_internal(self)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s0"># See if sprite is an iterator, like a list or sprite</span>
                    <span class="s0"># group.</span>
                    <span class="s1">self.add(*sprite)</span>
                <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError):</span>
                    <span class="s0"># Not iterable. This is probably a sprite that is not an</span>
                    <span class="s0"># instance of the Sprite class or is not an instance of a</span>
                    <span class="s0"># subclass of the Sprite class. Alternately, it could be an</span>
                    <span class="s0"># old-style sprite group.</span>
                    <span class="s3">if </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_spritegroup&quot;</span><span class="s1">):</span>
                        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">sprite.sprites():</span>
                            <span class="s3">if not </span><span class="s1">self.has_internal(spr):</span>
                                <span class="s1">self.add_internal(spr)</span>
                                <span class="s1">spr.add_internal(self)</span>
                    <span class="s3">elif not </span><span class="s1">self.has_internal(sprite):</span>
                        <span class="s1">self.add_internal(sprite)</span>
                        <span class="s1">sprite.add_internal(self)</span>

    <span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">*sprites):</span>
        <span class="s2">&quot;&quot;&quot;remove sprite(s) from group 
 
        Group.remove(sprite, list, or group, ...): return None 
 
        Removes a sprite or sequence of sprites from a group. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># This function behaves essentially the same as Group.add. It first</span>
        <span class="s0"># tries to handle each argument as an instance of the Sprite class. If</span>
        <span class="s0"># that fails, then it tries to handle the argument as an iterable</span>
        <span class="s0"># object. If that fails, then it tries to handle the argument as an</span>
        <span class="s0"># old-style sprite group. Lastly, if that fails, it assumes that the</span>
        <span class="s0"># normal Sprite methods should be used.</span>
        <span class="s3">for </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">sprites:</span>
            <span class="s3">if </span><span class="s1">isinstance(sprite</span><span class="s3">, </span><span class="s1">Sprite):</span>
                <span class="s3">if </span><span class="s1">self.has_internal(sprite):</span>
                    <span class="s1">self.remove_internal(sprite)</span>
                    <span class="s1">sprite.remove_internal(self)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self.remove(*sprite)</span>
                <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError):</span>
                    <span class="s3">if </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_spritegroup&quot;</span><span class="s1">):</span>
                        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">sprite.sprites():</span>
                            <span class="s3">if </span><span class="s1">self.has_internal(spr):</span>
                                <span class="s1">self.remove_internal(spr)</span>
                                <span class="s1">spr.remove_internal(self)</span>
                    <span class="s3">elif </span><span class="s1">self.has_internal(sprite):</span>
                        <span class="s1">self.remove_internal(sprite)</span>
                        <span class="s1">sprite.remove_internal(self)</span>

    <span class="s3">def </span><span class="s1">has(self</span><span class="s3">, </span><span class="s1">*sprites):</span>
        <span class="s2">&quot;&quot;&quot;ask if group has a sprite or sprites 
 
        Group.has(sprite or group, ...): return bool 
 
        Returns True if the given sprite or sprites are contained in the 
        group. Alternatively, you can get the same information using the 
        'in' operator, e.g. 'sprite in group', 'subgroup in group'. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">sprites:</span>
            <span class="s3">return False  </span><span class="s0"># return False if no sprites passed in</span>

        <span class="s3">for </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">sprites:</span>
            <span class="s3">if </span><span class="s1">isinstance(sprite</span><span class="s3">, </span><span class="s1">Sprite):</span>
                <span class="s0"># Check for Sprite instance's membership in this group</span>
                <span class="s3">if not </span><span class="s1">self.has_internal(sprite):</span>
                    <span class="s3">return False</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">if not </span><span class="s1">self.has(*sprite):</span>
                        <span class="s3">return False</span>
                <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError):</span>
                    <span class="s3">if </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_spritegroup&quot;</span><span class="s1">):</span>
                        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">sprite.sprites():</span>
                            <span class="s3">if not </span><span class="s1">self.has_internal(spr):</span>
                                <span class="s3">return False</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">if not </span><span class="s1">self.has_internal(sprite):</span>
                            <span class="s3">return False</span>

        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">update(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;call the update method of every member sprite 
 
        Group.update(*args, **kwargs): return None 
 
        Calls the update method of every member sprite. All arguments that 
        were passed to this method are passed to the Sprite update function. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">self.sprites():</span>
            <span class="s1">sprite.update(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">draw(self</span><span class="s3">, </span><span class="s1">surface):</span>
        <span class="s2">&quot;&quot;&quot;draw all sprites onto the surface 
 
        Group.draw(surface): return Rect_list 
 
        Draws all of the member sprites onto the given surface. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">sprites = self.sprites()</span>
        <span class="s3">if </span><span class="s1">hasattr(surface</span><span class="s3">, </span><span class="s4">&quot;blits&quot;</span><span class="s1">):</span>
            <span class="s1">self.spritedict.update(</span>
                <span class="s1">zip(sprites</span><span class="s3">, </span><span class="s1">surface.blits((spr.image</span><span class="s3">, </span><span class="s1">spr.rect) </span><span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">sprites))</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">sprites:</span>
                <span class="s1">self.spritedict[spr] = surface.blit(spr.image</span><span class="s3">, </span><span class="s1">spr.rect)</span>
        <span class="s1">self.lostsprites = []</span>
        <span class="s1">dirty = self.lostsprites</span>

        <span class="s3">return </span><span class="s1">dirty</span>

    <span class="s3">def </span><span class="s1">clear(self</span><span class="s3">, </span><span class="s1">surface</span><span class="s3">, </span><span class="s1">bgd):</span>
        <span class="s2">&quot;&quot;&quot;erase the previous position of all sprites 
 
        Group.clear(surface, bgd): return None 
 
        Clears the area under every drawn sprite in the group. The bgd 
        argument should be Surface which is the same dimensions as the 
        screen surface. The bgd could also be a function which accepts 
        the given surface and the area to be cleared as arguments. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">callable(bgd):</span>
            <span class="s3">for </span><span class="s1">lost_clear_rect </span><span class="s3">in </span><span class="s1">self.lostsprites:</span>
                <span class="s1">bgd(surface</span><span class="s3">, </span><span class="s1">lost_clear_rect)</span>
            <span class="s3">for </span><span class="s1">clear_rect </span><span class="s3">in </span><span class="s1">self.spritedict.values():</span>
                <span class="s3">if </span><span class="s1">clear_rect:</span>
                    <span class="s1">bgd(surface</span><span class="s3">, </span><span class="s1">clear_rect)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">surface_blit = surface.blit</span>
            <span class="s3">for </span><span class="s1">lost_clear_rect </span><span class="s3">in </span><span class="s1">self.lostsprites:</span>
                <span class="s1">surface_blit(bgd</span><span class="s3">, </span><span class="s1">lost_clear_rect</span><span class="s3">, </span><span class="s1">lost_clear_rect)</span>
            <span class="s3">for </span><span class="s1">clear_rect </span><span class="s3">in </span><span class="s1">self.spritedict.values():</span>
                <span class="s3">if </span><span class="s1">clear_rect:</span>
                    <span class="s1">surface_blit(bgd</span><span class="s3">, </span><span class="s1">clear_rect</span><span class="s3">, </span><span class="s1">clear_rect)</span>

    <span class="s3">def </span><span class="s1">empty(self):</span>
        <span class="s2">&quot;&quot;&quot;remove all sprites 
 
        Group.empty(): return None 
 
        Removes all the sprites from the group. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">self.sprites():</span>
            <span class="s1">self.remove_internal(sprite)</span>
            <span class="s1">sprite.remove_internal(self)</span>

    <span class="s3">def </span><span class="s1">__bool__(self):</span>
        <span class="s3">return </span><span class="s1">bool(self.sprites())</span>

    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s2">&quot;&quot;&quot;return number of sprites in group 
 
        Group.len(group): return int 
 
        Returns the number of sprites contained in the group. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len(self.sprites())</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">f&quot;&lt;</span><span class="s3">{</span><span class="s1">self.__class__.__name__</span><span class="s3">}</span><span class="s4">(</span><span class="s3">{</span><span class="s1">len(self)</span><span class="s3">} </span><span class="s4">sprites)&gt;&quot;</span>


<span class="s3">class </span><span class="s1">Group(AbstractGroup):</span>
    <span class="s2">&quot;&quot;&quot;container class for many Sprites 
 
    pygame.sprite.Group(*sprites): return Group 
 
    A simple container for Sprite objects. This class can be subclassed to 
    create containers with more specific behaviors. The constructor takes any 
    number of Sprite arguments to add to the Group. The group supports the 
    following standard Python operations: 
 
        in      test if a Sprite is contained 
        len     the number of Sprites contained 
        bool    test if any Sprites are contained 
        iter    iterate through all the Sprites 
 
    The Sprites in the Group are not ordered, so the Sprites are drawn and 
    iterated over in no particular order. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*sprites):</span>
        <span class="s1">AbstractGroup.__init__(self)</span>
        <span class="s1">self.add(*sprites)</span>


<span class="s1">RenderPlain = Group</span>
<span class="s1">RenderClear = Group</span>


<span class="s3">class </span><span class="s1">RenderUpdates(Group):</span>
    <span class="s2">&quot;&quot;&quot;Group class that tracks dirty updates 
 
    pygame.sprite.RenderUpdates(*sprites): return RenderUpdates 
 
    This class is derived from pygame.sprite.Group(). It has an enhanced draw 
    method that tracks the changed areas of the screen. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">draw(self</span><span class="s3">, </span><span class="s1">surface):</span>
        <span class="s1">surface_blit = surface.blit</span>
        <span class="s1">dirty = self.lostsprites</span>
        <span class="s1">self.lostsprites = []</span>
        <span class="s1">dirty_append = dirty.append</span>
        <span class="s3">for </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">self.sprites():</span>
            <span class="s1">old_rect = self.spritedict[sprite]</span>
            <span class="s1">new_rect = surface_blit(sprite.image</span><span class="s3">, </span><span class="s1">sprite.rect)</span>
            <span class="s3">if </span><span class="s1">old_rect:</span>
                <span class="s3">if </span><span class="s1">new_rect.colliderect(old_rect):</span>
                    <span class="s1">dirty_append(new_rect.union(old_rect))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">dirty_append(new_rect)</span>
                    <span class="s1">dirty_append(old_rect)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">dirty_append(new_rect)</span>
            <span class="s1">self.spritedict[sprite] = new_rect</span>
        <span class="s3">return </span><span class="s1">dirty</span>


<span class="s3">class </span><span class="s1">OrderedUpdates(RenderUpdates):</span>
    <span class="s2">&quot;&quot;&quot;RenderUpdates class that draws Sprites in order of addition 
 
    pygame.sprite.OrderedUpdates(*sprites): return OrderedUpdates 
 
    This class derives from pygame.sprite.RenderUpdates().  It maintains 
    the order in which the Sprites were added to the Group for rendering. 
    This makes adding and removing Sprites from the Group a little 
    slower than regular Groups. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*sprites):</span>
        <span class="s1">self._spritelist = []</span>
        <span class="s1">RenderUpdates.__init__(self</span><span class="s3">, </span><span class="s1">*sprites)</span>

    <span class="s3">def </span><span class="s1">sprites(self):</span>
        <span class="s3">return </span><span class="s1">list(self._spritelist)</span>

    <span class="s3">def </span><span class="s1">add_internal(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">layer=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">RenderUpdates.add_internal(self</span><span class="s3">, </span><span class="s1">sprite)</span>
        <span class="s1">self._spritelist.append(sprite)</span>

    <span class="s3">def </span><span class="s1">remove_internal(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s1">RenderUpdates.remove_internal(self</span><span class="s3">, </span><span class="s1">sprite)</span>
        <span class="s1">self._spritelist.remove(sprite)</span>


<span class="s3">class </span><span class="s1">LayeredUpdates(AbstractGroup):</span>
    <span class="s2">&quot;&quot;&quot;LayeredUpdates Group handles layers, which are drawn like OrderedUpdates 
 
    pygame.sprite.LayeredUpdates(*sprites, **kwargs): return LayeredUpdates 
 
    This group is fully compatible with pygame.sprite.Sprite. 
    New in pygame 1.8.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_init_rect = Rect(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*sprites</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;initialize an instance of LayeredUpdates with the given attributes 
 
        You can set the default layer through kwargs using 'default_layer' 
        and an integer for the layer. The default layer is 0. 
 
        If the sprite you add has an attribute _layer, then that layer will be 
        used. If **kwarg contains 'layer', then the passed sprites will be 
        added to that layer (overriding the sprite._layer attribute). If 
        neither the sprite nor **kwarg has a 'layer', then the default layer is 
        used to add the sprites. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._spritelayers = {}</span>
        <span class="s1">self._spritelist = []</span>
        <span class="s1">AbstractGroup.__init__(self)</span>
        <span class="s1">self._default_layer = kwargs.get(</span><span class="s4">&quot;default_layer&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">self.add(*sprites</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">add_internal(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">layer=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Do not use this method directly. 
 
        It is used by the group to add a sprite internally. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.spritedict[sprite] = self._init_rect</span>

        <span class="s3">if </span><span class="s1">layer </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">layer = sprite.layer</span>
            <span class="s3">except </span><span class="s1">AttributeError:</span>
                <span class="s1">layer = self._default_layer</span>
                <span class="s1">setattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s3">, </span><span class="s1">layer)</span>
        <span class="s3">elif </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s1">):</span>
            <span class="s1">setattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s3">, </span><span class="s1">layer)</span>

        <span class="s1">sprites = self._spritelist  </span><span class="s0"># speedup</span>
        <span class="s1">sprites_layers = self._spritelayers</span>
        <span class="s1">sprites_layers[sprite] = layer</span>

        <span class="s0"># add the sprite at the right position</span>
        <span class="s0"># bisect algorithmus</span>
        <span class="s1">leng = len(sprites)</span>
        <span class="s1">low = mid = </span><span class="s5">0</span>
        <span class="s1">high = leng - </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">low &lt;= high:</span>
            <span class="s1">mid = low + (high - low) // </span><span class="s5">2</span>
            <span class="s3">if </span><span class="s1">sprites_layers[sprites[mid]] &lt;= layer:</span>
                <span class="s1">low = mid + </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">high = mid - </span><span class="s5">1</span>
        <span class="s0"># linear search to find final position</span>
        <span class="s3">while </span><span class="s1">mid &lt; leng </span><span class="s3">and </span><span class="s1">sprites_layers[sprites[mid]] &lt;= layer:</span>
            <span class="s1">mid += </span><span class="s5">1</span>
        <span class="s1">sprites.insert(mid</span><span class="s3">, </span><span class="s1">sprite)</span>

    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">*sprites</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;add a sprite or sequence of sprites to a group 
 
        LayeredUpdates.add(*sprites, **kwargs): return None 
 
        If the sprite you add has an attribute _layer, then that layer will be 
        used. If **kwarg contains 'layer', then the passed sprites will be 
        added to that layer (overriding the sprite._layer attribute). If 
        neither the sprite nor **kwarg has a 'layer', then the default layer is 
        used to add the sprites. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">sprites:</span>
            <span class="s3">return</span>
        <span class="s1">layer = kwargs[</span><span class="s4">&quot;layer&quot;</span><span class="s1">] </span><span class="s3">if </span><span class="s4">&quot;layer&quot; </span><span class="s3">in </span><span class="s1">kwargs </span><span class="s3">else None</span>
        <span class="s3">for </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">sprites:</span>
            <span class="s0"># It's possible that some sprite is also an iterator.</span>
            <span class="s0"># If this is the case, we should add the sprite itself,</span>
            <span class="s0"># and not the iterator object.</span>
            <span class="s3">if </span><span class="s1">isinstance(sprite</span><span class="s3">, </span><span class="s1">Sprite):</span>
                <span class="s3">if not </span><span class="s1">self.has_internal(sprite):</span>
                    <span class="s1">self.add_internal(sprite</span><span class="s3">, </span><span class="s1">layer)</span>
                    <span class="s1">sprite.add_internal(self)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s0"># See if sprite is an iterator, like a list or sprite</span>
                    <span class="s0"># group.</span>
                    <span class="s1">self.add(*sprite</span><span class="s3">, </span><span class="s1">**kwargs)</span>
                <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">AttributeError):</span>
                    <span class="s0"># Not iterable. This is probably a sprite that is not an</span>
                    <span class="s0"># instance of the Sprite class or is not an instance of a</span>
                    <span class="s0"># subclass of the Sprite class. Alternately, it could be an</span>
                    <span class="s0"># old-style sprite group.</span>
                    <span class="s3">if </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_spritegroup&quot;</span><span class="s1">):</span>
                        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">sprite.sprites():</span>
                            <span class="s3">if not </span><span class="s1">self.has_internal(spr):</span>
                                <span class="s1">self.add_internal(spr</span><span class="s3">, </span><span class="s1">layer)</span>
                                <span class="s1">spr.add_internal(self)</span>
                    <span class="s3">elif not </span><span class="s1">self.has_internal(sprite):</span>
                        <span class="s1">self.add_internal(sprite</span><span class="s3">, </span><span class="s1">layer)</span>
                        <span class="s1">sprite.add_internal(self)</span>

    <span class="s3">def </span><span class="s1">remove_internal(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s2">&quot;&quot;&quot;Do not use this method directly. 
 
        The group uses it to add a sprite. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._spritelist.remove(sprite)</span>
        <span class="s0"># these dirty rects are suboptimal for one frame</span>
        <span class="s1">old_rect = self.spritedict[sprite]</span>
        <span class="s3">if </span><span class="s1">old_rect </span><span class="s3">is not </span><span class="s1">self._init_rect:</span>
            <span class="s1">self.lostsprites.append(old_rect)  </span><span class="s0"># dirty rect</span>
        <span class="s3">if </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;rect&quot;</span><span class="s1">):</span>
            <span class="s1">self.lostsprites.append(sprite.rect)  </span><span class="s0"># dirty rect</span>

        <span class="s3">del </span><span class="s1">self.spritedict[sprite]</span>
        <span class="s3">del </span><span class="s1">self._spritelayers[sprite]</span>

    <span class="s3">def </span><span class="s1">sprites(self):</span>
        <span class="s2">&quot;&quot;&quot;return a ordered list of sprites (first back, last top). 
 
        LayeredUpdates.sprites(): return sprites 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">list(self._spritelist)</span>

    <span class="s3">def </span><span class="s1">draw(self</span><span class="s3">, </span><span class="s1">surface):</span>
        <span class="s2">&quot;&quot;&quot;draw all sprites in the right order onto the passed surface 
 
        LayeredUpdates.draw(surface): return Rect_list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">spritedict = self.spritedict</span>
        <span class="s1">surface_blit = surface.blit</span>
        <span class="s1">dirty = self.lostsprites</span>
        <span class="s1">self.lostsprites = []</span>
        <span class="s1">dirty_append = dirty.append</span>
        <span class="s1">init_rect = self._init_rect</span>
        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">self.sprites():</span>
            <span class="s1">rec = spritedict[spr]</span>
            <span class="s1">newrect = surface_blit(spr.image</span><span class="s3">, </span><span class="s1">spr.rect)</span>
            <span class="s3">if </span><span class="s1">rec </span><span class="s3">is </span><span class="s1">init_rect:</span>
                <span class="s1">dirty_append(newrect)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">newrect.colliderect(rec):</span>
                    <span class="s1">dirty_append(newrect.union(rec))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">dirty_append(newrect)</span>
                    <span class="s1">dirty_append(rec)</span>
            <span class="s1">spritedict[spr] = newrect</span>
        <span class="s3">return </span><span class="s1">dirty</span>

    <span class="s3">def </span><span class="s1">get_sprites_at(self</span><span class="s3">, </span><span class="s1">pos):</span>
        <span class="s2">&quot;&quot;&quot;return a list with all sprites at that position 
 
        LayeredUpdates.get_sprites_at(pos): return colliding_sprites 
 
        Bottom sprites are listed first; the top ones are listed last. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_sprites = self._spritelist</span>
        <span class="s1">rect = Rect(pos</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">colliding_idx = rect.collidelistall(_sprites)</span>
        <span class="s3">return </span><span class="s1">[_sprites[i] </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">colliding_idx]</span>

    <span class="s3">def </span><span class="s1">get_sprite(self</span><span class="s3">, </span><span class="s1">idx):</span>
        <span class="s2">&quot;&quot;&quot;return the sprite at the index idx from the groups sprites 
 
        LayeredUpdates.get_sprite(idx): return sprite 
 
        Raises IndexOutOfBounds if the idx is not within range. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._spritelist[idx]</span>

    <span class="s3">def </span><span class="s1">remove_sprites_of_layer(self</span><span class="s3">, </span><span class="s1">layer_nr):</span>
        <span class="s2">&quot;&quot;&quot;remove all sprites from a layer and return them as a list 
 
        LayeredUpdates.remove_sprites_of_layer(layer_nr): return sprites 
 
        &quot;&quot;&quot;</span>
        <span class="s1">sprites = self.get_sprites_from_layer(layer_nr)</span>
        <span class="s1">self.remove(*sprites)</span>
        <span class="s3">return </span><span class="s1">sprites</span>

    <span class="s0"># layer methods</span>
    <span class="s3">def </span><span class="s1">layers(self):</span>
        <span class="s2">&quot;&quot;&quot;return a list of unique defined layers defined. 
 
        LayeredUpdates.layers(): return layers 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">sorted(set(self._spritelayers.values()))</span>

    <span class="s3">def </span><span class="s1">change_layer(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">new_layer):</span>
        <span class="s2">&quot;&quot;&quot;change the layer of the sprite 
 
        LayeredUpdates.change_layer(sprite, new_layer): return None 
 
        The sprite must have been added to the renderer already. This is not 
        checked. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">sprites = self._spritelist  </span><span class="s0"># speedup</span>
        <span class="s1">sprites_layers = self._spritelayers  </span><span class="s0"># speedup</span>

        <span class="s1">sprites.remove(sprite)</span>
        <span class="s1">sprites_layers.pop(sprite)</span>

        <span class="s0"># add the sprite at the right position</span>
        <span class="s0"># bisect algorithmus</span>
        <span class="s1">leng = len(sprites)</span>
        <span class="s1">low = mid = </span><span class="s5">0</span>
        <span class="s1">high = leng - </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">low &lt;= high:</span>
            <span class="s1">mid = low + (high - low) // </span><span class="s5">2</span>
            <span class="s3">if </span><span class="s1">sprites_layers[sprites[mid]] &lt;= new_layer:</span>
                <span class="s1">low = mid + </span><span class="s5">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">high = mid - </span><span class="s5">1</span>
        <span class="s0"># linear search to find final position</span>
        <span class="s3">while </span><span class="s1">mid &lt; leng </span><span class="s3">and </span><span class="s1">sprites_layers[sprites[mid]] &lt;= new_layer:</span>
            <span class="s1">mid += </span><span class="s5">1</span>
        <span class="s1">sprites.insert(mid</span><span class="s3">, </span><span class="s1">sprite)</span>
        <span class="s3">if </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s1">):</span>
            <span class="s1">setattr(sprite</span><span class="s3">, </span><span class="s4">&quot;_layer&quot;</span><span class="s3">, </span><span class="s1">new_layer)</span>

        <span class="s0"># add layer info</span>
        <span class="s1">sprites_layers[sprite] = new_layer</span>

    <span class="s3">def </span><span class="s1">get_layer_of_sprite(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s2">&quot;&quot;&quot;return the layer that sprite is currently in 
 
        If the sprite is not found, then it will return the default layer. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._spritelayers.get(sprite</span><span class="s3">, </span><span class="s1">self._default_layer)</span>

    <span class="s3">def </span><span class="s1">get_top_layer(self):</span>
        <span class="s2">&quot;&quot;&quot;return the top layer 
 
        LayeredUpdates.get_top_layer(): return layer 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._spritelayers[self._spritelist[-</span><span class="s5">1</span><span class="s1">]]</span>

    <span class="s3">def </span><span class="s1">get_bottom_layer(self):</span>
        <span class="s2">&quot;&quot;&quot;return the bottom layer 
 
        LayeredUpdates.get_bottom_layer(): return layer 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._spritelayers[self._spritelist[</span><span class="s5">0</span><span class="s1">]]</span>

    <span class="s3">def </span><span class="s1">move_to_front(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s2">&quot;&quot;&quot;bring the sprite to front layer 
 
        LayeredUpdates.move_to_front(sprite): return None 
 
        Brings the sprite to front by changing the sprite layer to the top-most 
        layer. The sprite is added at the end of the list of sprites in that 
        top-most layer. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.change_layer(sprite</span><span class="s3">, </span><span class="s1">self.get_top_layer())</span>

    <span class="s3">def </span><span class="s1">move_to_back(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s2">&quot;&quot;&quot;move the sprite to the bottom layer 
 
        LayeredUpdates.move_to_back(sprite): return None 
 
        Moves the sprite to the bottom layer by moving it to a new layer below 
        the current bottom layer. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.change_layer(sprite</span><span class="s3">, </span><span class="s1">self.get_bottom_layer() - </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_top_sprite(self):</span>
        <span class="s2">&quot;&quot;&quot;return the topmost sprite 
 
        LayeredUpdates.get_top_sprite(): return Sprite 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._spritelist[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">get_sprites_from_layer(self</span><span class="s3">, </span><span class="s1">layer):</span>
        <span class="s2">&quot;&quot;&quot;return all sprites from a layer ordered as they where added 
 
        LayeredUpdates.get_sprites_from_layer(layer): return sprites 
 
        Returns all sprites from a layer. The sprites are ordered in the 
        sequence that they where added. (The sprites are not removed from the 
        layer. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">sprites = []</span>
        <span class="s1">sprites_append = sprites.append</span>
        <span class="s1">sprite_layers = self._spritelayers</span>
        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">self._spritelist:</span>
            <span class="s3">if </span><span class="s1">sprite_layers[spr] == layer:</span>
                <span class="s1">sprites_append(spr)</span>
            <span class="s3">elif </span><span class="s1">sprite_layers[spr] &gt; layer:</span>
                <span class="s0"># break after because no other will</span>
                <span class="s0"># follow with same layer</span>
                <span class="s3">break</span>
        <span class="s3">return </span><span class="s1">sprites</span>

    <span class="s3">def </span><span class="s1">switch_layer(self</span><span class="s3">, </span><span class="s1">layer1_nr</span><span class="s3">, </span><span class="s1">layer2_nr):</span>
        <span class="s2">&quot;&quot;&quot;switch the sprites from layer1_nr to layer2_nr 
 
        LayeredUpdates.switch_layer(layer1_nr, layer2_nr): return None 
 
        The layers number must exist. This method does not check for the 
        existence of the given layers. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">sprites1 = self.remove_sprites_of_layer(layer1_nr)</span>
        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">self.get_sprites_from_layer(layer2_nr):</span>
            <span class="s1">self.change_layer(spr</span><span class="s3">, </span><span class="s1">layer1_nr)</span>
        <span class="s1">self.add(layer=layer2_nr</span><span class="s3">, </span><span class="s1">*sprites1)</span>


<span class="s3">class </span><span class="s1">LayeredDirty(LayeredUpdates):</span>
    <span class="s2">&quot;&quot;&quot;LayeredDirty Group is for DirtySprites; subclasses LayeredUpdates 
 
    pygame.sprite.LayeredDirty(*sprites, **kwargs): return LayeredDirty 
 
    This group requires pygame.sprite.DirtySprite or any sprite that 
    has the following attributes: 
        image, rect, dirty, visible, blendmode (see doc of DirtySprite). 
 
    It uses the dirty flag technique and is therefore faster than 
    pygame.sprite.RenderUpdates if you have many static sprites.  It 
    also switches automatically between dirty rect updating and full 
    screen drawing, so you do no have to worry which would be faster. 
 
    As with the pygame.sprite.Group, you can specify some additional attributes 
    through kwargs: 
        _use_update: True/False   (default is False) 
        _default_layer: default layer where the sprites without a layer are 
            added 
        _time_threshold: threshold time for switching between dirty rect mode 
            and fullscreen mode; defaults to updating at 80 frames per second, 
            which is equal to 1000.0 / 80.0 
 
    New in pygame 1.8.0 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*sprites</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;initialize group. 
 
        pygame.sprite.LayeredDirty(*sprites, **kwargs): return LayeredDirty 
 
        You can specify some additional attributes through kwargs: 
            _use_update: True/False   (default is False) 
            _default_layer: default layer where the sprites without a layer are 
                added 
            _time_threshold: threshold time for switching between dirty rect 
                mode and fullscreen mode; defaults to updating at 80 frames per 
                second, which is equal to 1000.0 / 80.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">LayeredUpdates.__init__(self</span><span class="s3">, </span><span class="s1">*sprites</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._clip = </span><span class="s3">None</span>

        <span class="s1">self._use_update = </span><span class="s3">False</span>

        <span class="s1">self._time_threshold = </span><span class="s5">1000.0 </span><span class="s1">/ </span><span class="s5">80.0  </span><span class="s0"># 1000.0 / fps</span>

        <span class="s1">self._bgd = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">kwargs.items():</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;_use_update&quot;</span><span class="s3">, </span><span class="s4">&quot;_time_threshold&quot;</span><span class="s3">, </span><span class="s4">&quot;_default_layer&quot;</span><span class="s1">] </span><span class="s3">and </span><span class="s1">hasattr(</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">key</span>
            <span class="s1">):</span>
                <span class="s1">setattr(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val)</span>

    <span class="s3">def </span><span class="s1">add_internal(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">layer=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Do not use this method directly. 
 
        It is used by the group to add a sprite internally. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># check if all needed attributes are set</span>
        <span class="s3">if not </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;dirty&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError()</span>
        <span class="s3">if not </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;visible&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError()</span>
        <span class="s3">if not </span><span class="s1">hasattr(sprite</span><span class="s3">, </span><span class="s4">&quot;blendmode&quot;</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError()</span>

        <span class="s3">if not </span><span class="s1">isinstance(sprite</span><span class="s3">, </span><span class="s1">DirtySprite):</span>
            <span class="s3">raise </span><span class="s1">TypeError()</span>

        <span class="s3">if </span><span class="s1">sprite.dirty == </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># set it dirty if it is not</span>
            <span class="s1">sprite.dirty = </span><span class="s5">1</span>

        <span class="s1">LayeredUpdates.add_internal(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">layer)</span>

    <span class="s3">def </span><span class="s1">draw(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">surface</span><span class="s3">, </span><span class="s1">bgd=</span><span class="s3">None</span>
    <span class="s1">):  </span><span class="s0"># noqa pylint: disable=arguments-differ; unable to change public interface</span>
        <span class="s2">&quot;&quot;&quot;draw all sprites in the right order onto the given surface 
 
        LayeredDirty.draw(surface, bgd=None): return Rect_list 
 
        You can pass the background too. If a self.bgd is already set to some 
        value that is not None, then the bgd argument has no effect. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># functions and classes assigned locally to speed up loops</span>
        <span class="s1">orig_clip = surface.get_clip()</span>
        <span class="s1">latest_clip = self._clip</span>
        <span class="s3">if </span><span class="s1">latest_clip </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">latest_clip = orig_clip</span>

        <span class="s1">local_sprites = self._spritelist</span>
        <span class="s1">local_old_rect = self.spritedict</span>
        <span class="s1">local_update = self.lostsprites</span>
        <span class="s1">rect_type = Rect</span>

        <span class="s1">surf_blit_func = surface.blit</span>
        <span class="s3">if </span><span class="s1">bgd </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._bgd = bgd</span>
        <span class="s1">local_bgd = self._bgd</span>

        <span class="s1">surface.set_clip(latest_clip)</span>
        <span class="s0"># -------</span>
        <span class="s0"># 0. decide whether to render with update or flip</span>
        <span class="s1">start_time = get_ticks()</span>
        <span class="s3">if </span><span class="s1">self._use_update:  </span><span class="s0"># dirty rects mode</span>
            <span class="s0"># 1. find dirty area on screen and put the rects into</span>
            <span class="s0"># self.lostsprites still not happy with that part</span>
            <span class="s1">self._find_dirty_area(</span>
                <span class="s1">latest_clip</span><span class="s3">,</span>
                <span class="s1">local_old_rect</span><span class="s3">,</span>
                <span class="s1">rect_type</span><span class="s3">,</span>
                <span class="s1">local_sprites</span><span class="s3">,</span>
                <span class="s1">local_update</span><span class="s3">,</span>
                <span class="s1">local_update.append</span><span class="s3">,</span>
                <span class="s1">self._init_rect</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s0"># can it be done better? because that is an O(n**2) algorithm in</span>
            <span class="s0"># worst case</span>

            <span class="s0"># clear using background</span>
            <span class="s3">if </span><span class="s1">local_bgd </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">for </span><span class="s1">rec </span><span class="s3">in </span><span class="s1">local_update:</span>
                    <span class="s1">surf_blit_func(local_bgd</span><span class="s3">, </span><span class="s1">rec</span><span class="s3">, </span><span class="s1">rec)</span>

            <span class="s0"># 2. draw</span>
            <span class="s1">self._draw_dirty_internal(</span>
                <span class="s1">local_old_rect</span><span class="s3">, </span><span class="s1">rect_type</span><span class="s3">, </span><span class="s1">local_sprites</span><span class="s3">, </span><span class="s1">surf_blit_func</span><span class="s3">, </span><span class="s1">local_update</span>
            <span class="s1">)</span>
            <span class="s1">local_ret = list(local_update)</span>
        <span class="s3">else</span><span class="s1">:  </span><span class="s0"># flip, full screen mode</span>
            <span class="s3">if </span><span class="s1">local_bgd </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">surf_blit_func(local_bgd</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">local_sprites:</span>
                <span class="s3">if </span><span class="s1">spr.visible:</span>
                    <span class="s1">local_old_rect[spr] = surf_blit_func(</span>
                        <span class="s1">spr.image</span><span class="s3">, </span><span class="s1">spr.rect</span><span class="s3">, </span><span class="s1">spr.source_rect</span><span class="s3">, </span><span class="s1">spr.blendmode</span>
                    <span class="s1">)</span>
            <span class="s0"># return only the part of the screen changed</span>
            <span class="s1">local_ret = [rect_type(latest_clip)]</span>

        <span class="s0"># timing for switching modes</span>
        <span class="s0"># How may a good threshold be found? It depends on the hardware.</span>
        <span class="s1">end_time = get_ticks()</span>
        <span class="s3">if </span><span class="s1">end_time - start_time &gt; self._time_threshold:</span>
            <span class="s1">self._use_update = </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._use_update = </span><span class="s3">True</span>

        <span class="s0"># empty dirty rects list</span>
        <span class="s1">local_update[:] = []</span>

        <span class="s0"># -------</span>
        <span class="s0"># restore original clip</span>
        <span class="s1">surface.set_clip(orig_clip)</span>
        <span class="s3">return </span><span class="s1">local_ret</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_draw_dirty_internal(_old_rect</span><span class="s3">, </span><span class="s1">_rect</span><span class="s3">, </span><span class="s1">_sprites</span><span class="s3">, </span><span class="s1">_surf_blit</span><span class="s3">, </span><span class="s1">_update):</span>
        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">_sprites:</span>
            <span class="s3">if </span><span class="s1">spr.dirty &lt; </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">spr.visible:</span>
                <span class="s0"># sprite not dirty; blit only the intersecting part</span>
                <span class="s3">if </span><span class="s1">spr.source_rect </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s0"># For possible future speed up, source_rect's data</span>
                    <span class="s0"># can be pre-fetched outside of this loop.</span>
                    <span class="s1">_spr_rect = _rect(spr.rect.topleft</span><span class="s3">, </span><span class="s1">spr.source_rect.size)</span>
                    <span class="s1">rect_offset_x = spr.source_rect[</span><span class="s5">0</span><span class="s1">] - _spr_rect[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">rect_offset_y = spr.source_rect[</span><span class="s5">1</span><span class="s1">] - _spr_rect[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">_spr_rect = spr.rect</span>
                    <span class="s1">rect_offset_x = -_spr_rect[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">rect_offset_y = -_spr_rect[</span><span class="s5">1</span><span class="s1">]</span>

                <span class="s1">_spr_rect_clip = _spr_rect.clip</span>

                <span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">_spr_rect.collidelistall(_update):</span>
                    <span class="s0"># clip</span>
                    <span class="s1">clip = _spr_rect_clip(_update[idx])</span>
                    <span class="s1">_surf_blit(</span>
                        <span class="s1">spr.image</span><span class="s3">,</span>
                        <span class="s1">clip</span><span class="s3">,</span>
                        <span class="s1">(</span>
                            <span class="s1">clip[</span><span class="s5">0</span><span class="s1">] + rect_offset_x</span><span class="s3">,</span>
                            <span class="s1">clip[</span><span class="s5">1</span><span class="s1">] + rect_offset_y</span><span class="s3">,</span>
                            <span class="s1">clip[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">,</span>
                            <span class="s1">clip[</span><span class="s5">3</span><span class="s1">]</span><span class="s3">,</span>
                        <span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">spr.blendmode</span><span class="s3">,</span>
                    <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:  </span><span class="s0"># dirty sprite</span>
                <span class="s3">if </span><span class="s1">spr.visible:</span>
                    <span class="s1">_old_rect[spr] = _surf_blit(</span>
                        <span class="s1">spr.image</span><span class="s3">, </span><span class="s1">spr.rect</span><span class="s3">, </span><span class="s1">spr.source_rect</span><span class="s3">, </span><span class="s1">spr.blendmode</span>
                    <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">spr.dirty == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">spr.dirty = </span><span class="s5">0</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_find_dirty_area(</span>
        <span class="s1">_clip</span><span class="s3">, </span><span class="s1">_old_rect</span><span class="s3">, </span><span class="s1">_rect</span><span class="s3">, </span><span class="s1">_sprites</span><span class="s3">, </span><span class="s1">_update</span><span class="s3">, </span><span class="s1">_update_append</span><span class="s3">, </span><span class="s1">init_rect</span>
    <span class="s1">):</span>
        <span class="s3">for </span><span class="s1">spr </span><span class="s3">in </span><span class="s1">_sprites:</span>
            <span class="s3">if </span><span class="s1">spr.dirty &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s0"># chose the right rect</span>
                <span class="s3">if </span><span class="s1">spr.source_rect:</span>
                    <span class="s1">_union_rect = _rect(spr.rect.topleft</span><span class="s3">, </span><span class="s1">spr.source_rect.size)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">_union_rect = _rect(spr.rect)</span>

                <span class="s1">_union_rect_collidelist = _union_rect.collidelist</span>
                <span class="s1">_union_rect_union_ip = _union_rect.union_ip</span>
                <span class="s1">i = _union_rect_collidelist(_update)</span>
                <span class="s3">while </span><span class="s1">i &gt; -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">_union_rect_union_ip(_update[i])</span>
                    <span class="s3">del </span><span class="s1">_update[i]</span>
                    <span class="s1">i = _union_rect_collidelist(_update)</span>
                <span class="s1">_update_append(_union_rect.clip(_clip))</span>

                <span class="s3">if </span><span class="s1">_old_rect[spr] </span><span class="s3">is not </span><span class="s1">init_rect:</span>
                    <span class="s1">_union_rect = _rect(_old_rect[spr])</span>
                    <span class="s1">_union_rect_collidelist = _union_rect.collidelist</span>
                    <span class="s1">_union_rect_union_ip = _union_rect.union_ip</span>
                    <span class="s1">i = _union_rect_collidelist(_update)</span>
                    <span class="s3">while </span><span class="s1">i &gt; -</span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">_union_rect_union_ip(_update[i])</span>
                        <span class="s3">del </span><span class="s1">_update[i]</span>
                        <span class="s1">i = _union_rect_collidelist(_update)</span>
                    <span class="s1">_update_append(_union_rect.clip(_clip))</span>

    <span class="s3">def </span><span class="s1">clear(self</span><span class="s3">, </span><span class="s1">surface</span><span class="s3">, </span><span class="s1">bgd):</span>
        <span class="s2">&quot;&quot;&quot;use to set background 
 
        Group.clear(surface, bgd): return None 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._bgd = bgd</span>

    <span class="s3">def </span><span class="s1">repaint_rect(self</span><span class="s3">, </span><span class="s1">screen_rect):</span>
        <span class="s2">&quot;&quot;&quot;repaint the given area 
 
        LayeredDirty.repaint_rect(screen_rect): return None 
 
        screen_rect is in screen coordinates. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._clip:</span>
            <span class="s1">self.lostsprites.append(screen_rect.clip(self._clip))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.lostsprites.append(Rect(screen_rect))</span>

    <span class="s3">def </span><span class="s1">set_clip(self</span><span class="s3">, </span><span class="s1">screen_rect=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;clip the area where to draw; pass None (default) to reset the clip 
 
        LayeredDirty.set_clip(screen_rect=None): return None 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">screen_rect </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self._clip = pygame.display.get_surface().get_rect()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._clip = screen_rect</span>
        <span class="s1">self._use_update = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">get_clip(self):</span>
        <span class="s2">&quot;&quot;&quot;get the area where drawing will occur 
 
        LayeredDirty.get_clip(): return Rect 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._clip</span>

    <span class="s3">def </span><span class="s1">change_layer(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">new_layer):</span>
        <span class="s2">&quot;&quot;&quot;change the layer of the sprite 
 
        LayeredUpdates.change_layer(sprite, new_layer): return None 
 
        The sprite must have been added to the renderer already. This is not 
        checked. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">LayeredUpdates.change_layer(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">new_layer)</span>
        <span class="s3">if </span><span class="s1">sprite.dirty == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">sprite.dirty = </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">set_timing_treshold(self</span><span class="s3">, </span><span class="s1">time_ms):</span>
        <span class="s2">&quot;&quot;&quot;set the threshold in milliseconds 
 
        set_timing_treshold(time_ms): return None 
 
        Defaults to 1000.0 / 80.0. This means that the screen will be painted 
        using the flip method rather than the update method if the update 
        method is taking so long to update the screen that the frame rate falls 
        below 80 frames per second. 
 
        Raises TypeError if time_ms is not int or float. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">warn(</span>
            <span class="s4">&quot;This function will be removed, use set_timing_threshold function instead&quot;</span><span class="s3">,</span>
            <span class="s1">DeprecationWarning</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">self.set_timing_threshold(time_ms)</span>

    <span class="s3">def </span><span class="s1">set_timing_threshold(self</span><span class="s3">, </span><span class="s1">time_ms):</span>
        <span class="s2">&quot;&quot;&quot;set the threshold in milliseconds 
 
        set_timing_threshold(time_ms): return None 
 
        Defaults to 1000.0 / 80.0. This means that the screen will be painted 
        using the flip method rather than the update method if the update 
        method is taking so long to update the screen that the frame rate falls 
        below 80 frames per second. 
 
        Raises TypeError if time_ms is not int or float. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(time_ms</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">float)):</span>
            <span class="s1">self._time_threshold = time_ms</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span>
                <span class="s4">f&quot;Expected numeric value, got </span><span class="s3">{</span><span class="s1">time_ms.__class__.__name__</span><span class="s3">} </span><span class="s4">instead&quot;</span>
            <span class="s1">)</span>


<span class="s3">class </span><span class="s1">GroupSingle(AbstractGroup):</span>
    <span class="s2">&quot;&quot;&quot;A group container that holds a single most recent item. 
 
    This class works just like a regular group, but it only keeps a single 
    sprite in the group. Whatever sprite has been added to the group last will 
    be the only sprite in the group. 
 
    You can access its one sprite as the .sprite attribute.  Assigning to this 
    attribute will properly remove the old sprite and then add the new one. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">sprite=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">AbstractGroup.__init__(self)</span>
        <span class="s1">self.__sprite = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">sprite </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.add(sprite)</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s3">return </span><span class="s1">GroupSingle(self.__sprite)</span>

    <span class="s3">def </span><span class="s1">sprites(self):</span>
        <span class="s3">if </span><span class="s1">self.__sprite </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[self.__sprite]</span>
        <span class="s3">return </span><span class="s1">[]</span>

    <span class="s3">def </span><span class="s1">add_internal(self</span><span class="s3">, </span><span class="s1">sprite</span><span class="s3">, </span><span class="s1">layer=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.__sprite </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.__sprite.remove_internal(self)</span>
            <span class="s1">self.remove_internal(self.__sprite)</span>
        <span class="s1">self.__sprite = sprite</span>

    <span class="s3">def </span><span class="s1">__bool__(self):</span>
        <span class="s3">return </span><span class="s1">self.__sprite </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">_get_sprite(self):</span>
        <span class="s3">return </span><span class="s1">self.__sprite</span>

    <span class="s3">def </span><span class="s1">_set_sprite(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s1">self.add_internal(sprite)</span>
        <span class="s1">sprite.add_internal(self)</span>
        <span class="s3">return </span><span class="s1">sprite</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">sprite(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Property for the single sprite contained in this group 
 
        :return: The sprite. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._get_sprite()</span>

    <span class="s1">@sprite.setter</span>
    <span class="s3">def </span><span class="s1">sprite(self</span><span class="s3">, </span><span class="s1">sprite_to_set):</span>
        <span class="s1">self._set_sprite(sprite_to_set)</span>

    <span class="s3">def </span><span class="s1">remove_internal(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s3">if </span><span class="s1">sprite </span><span class="s3">is </span><span class="s1">self.__sprite:</span>
            <span class="s1">self.__sprite = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">sprite </span><span class="s3">in </span><span class="s1">self.spritedict:</span>
            <span class="s1">AbstractGroup.remove_internal(self</span><span class="s3">, </span><span class="s1">sprite)</span>

    <span class="s3">def </span><span class="s1">has_internal(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s3">return </span><span class="s1">self.__sprite </span><span class="s3">is </span><span class="s1">sprite</span>

    <span class="s0"># Optimizations...</span>
    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">sprite):</span>
        <span class="s3">return </span><span class="s1">self.__sprite </span><span class="s3">is </span><span class="s1">sprite</span>


<span class="s0"># Some different collision detection functions that could be used.</span>
<span class="s3">def </span><span class="s1">collide_rect(left</span><span class="s3">, </span><span class="s1">right):</span>
    <span class="s2">&quot;&quot;&quot;collision detection between two sprites, using rects. 
 
    pygame.sprite.collide_rect(left, right): return bool 
 
    Tests for collision between two sprites. Uses the pygame.Rect colliderect 
    function to calculate the collision. It is intended to be passed as a 
    collided callback function to the *collide functions. Sprites must have 
    &quot;rect&quot; attributes. 
 
    New in pygame 1.8.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">left.rect.colliderect(right.rect)</span>


<span class="s3">class </span><span class="s1">collide_rect_ratio:  </span><span class="s0"># noqa pylint: disable=invalid-name; this is a function-like class</span>
    <span class="s2">&quot;&quot;&quot;A callable class that checks for collisions using scaled rects 
 
    The class checks for collisions between two sprites using a scaled version 
    of the sprites' rects. Is created with a ratio; the instance is then 
    intended to be passed as a collided callback function to the *collide 
    functions. 
 
    New in pygame 1.8.1 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">ratio):</span>
        <span class="s2">&quot;&quot;&quot;create a new collide_rect_ratio callable 
 
        Ratio is expected to be a floating point value used to scale 
        the underlying sprite rect before checking for collisions. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ratio = ratio</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Turn the class into a string. 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=consider-using-f-string</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;{klass} @{id:x} {attrs}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">klass=self.__class__.__name__</span><span class="s3">,</span>
            <span class="s1">id=id(self) &amp; </span><span class="s5">0xFFFFFF</span><span class="s3">,</span>
            <span class="s1">attrs=</span><span class="s4">&quot; &quot;</span><span class="s1">.join(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">k</span><span class="s3">}</span><span class="s4">=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">!r}</span><span class="s4">&quot; </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.__dict__.items())</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right):</span>
        <span class="s2">&quot;&quot;&quot;detect collision between two sprites using scaled rects 
 
        pygame.sprite.collide_rect_ratio(ratio)(left, right): return bool 
 
        Tests for collision between two sprites. Uses the pygame.Rect 
        colliderect function to calculate the collision after scaling the rects 
        by the stored ratio. Sprites must have &quot;rect&quot; attributes. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">ratio = self.ratio</span>

        <span class="s1">leftrect = left.rect</span>
        <span class="s1">width = leftrect.width</span>
        <span class="s1">height = leftrect.height</span>
        <span class="s1">leftrect = leftrect.inflate(width * ratio - width</span><span class="s3">, </span><span class="s1">height * ratio - height)</span>

        <span class="s1">rightrect = right.rect</span>
        <span class="s1">width = rightrect.width</span>
        <span class="s1">height = rightrect.height</span>
        <span class="s1">rightrect = rightrect.inflate(width * ratio - width</span><span class="s3">, </span><span class="s1">height * ratio - height)</span>

        <span class="s3">return </span><span class="s1">leftrect.colliderect(rightrect)</span>


<span class="s3">def </span><span class="s1">collide_circle(left</span><span class="s3">, </span><span class="s1">right):</span>
    <span class="s2">&quot;&quot;&quot;detect collision between two sprites using circles 
 
    pygame.sprite.collide_circle(left, right): return bool 
 
    Tests for collision between two sprites by testing whether two circles 
    centered on the sprites overlap. If the sprites have a &quot;radius&quot; attribute, 
    then that radius is used to create the circle; otherwise, a circle is 
    created that is big enough to completely enclose the sprite's rect as 
    given by the &quot;rect&quot; attribute. This function is intended to be passed as 
    a collided callback function to the *collide functions. Sprites must have a 
    &quot;rect&quot; and an optional &quot;radius&quot; attribute. 
 
    New in pygame 1.8.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">xdistance = left.rect.centerx - right.rect.centerx</span>
    <span class="s1">ydistance = left.rect.centery - right.rect.centery</span>
    <span class="s1">distancesquared = xdistance**</span><span class="s5">2 </span><span class="s1">+ ydistance**</span><span class="s5">2</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">leftradius = left.radius</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
        <span class="s1">leftrect = left.rect</span>
        <span class="s0"># approximating the radius of a square by using half of the diagonal,</span>
        <span class="s0"># might give false positives (especially if its a long small rect)</span>
        <span class="s1">leftradius = </span><span class="s5">0.5 </span><span class="s1">* ((leftrect.width**</span><span class="s5">2 </span><span class="s1">+ leftrect.height**</span><span class="s5">2</span><span class="s1">) ** </span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s0"># store the radius on the sprite for next time</span>
        <span class="s1">left.radius = leftradius</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">rightradius = right.radius</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
        <span class="s1">rightrect = right.rect</span>
        <span class="s0"># approximating the radius of a square by using half of the diagonal</span>
        <span class="s0"># might give false positives (especially if its a long small rect)</span>
        <span class="s1">rightradius = </span><span class="s5">0.5 </span><span class="s1">* ((rightrect.width**</span><span class="s5">2 </span><span class="s1">+ rightrect.height**</span><span class="s5">2</span><span class="s1">) ** </span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s0"># store the radius on the sprite for next time</span>
        <span class="s1">right.radius = rightradius</span>
    <span class="s3">return </span><span class="s1">distancesquared &lt;= (leftradius + rightradius) ** </span><span class="s5">2</span>


<span class="s3">class </span><span class="s1">collide_circle_ratio:  </span><span class="s0"># noqa pylint: disable=invalid-name; this is a function-like class</span>
    <span class="s2">&quot;&quot;&quot;detect collision between two sprites using scaled circles 
 
    This callable class checks for collisions between two sprites using a 
    scaled version of a sprite's radius. It is created with a ratio as the 
    argument to the constructor. The instance is then intended to be passed as 
    a collided callback function to the *collide functions. 
 
    New in pygame 1.8.1 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">ratio):</span>
        <span class="s2">&quot;&quot;&quot;creates a new collide_circle_ratio callable instance 
 
        The given ratio is expected to be a floating point value used to scale 
        the underlying sprite radius before checking for collisions. 
 
        When the ratio is ratio=1.0, then it behaves exactly like the 
        collide_circle method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ratio = ratio</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Turn the class into a string. 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=consider-using-f-string</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;{klass} @{id:x} {attrs}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">klass=self.__class__.__name__</span><span class="s3">,</span>
            <span class="s1">id=id(self) &amp; </span><span class="s5">0xFFFFFF</span><span class="s3">,</span>
            <span class="s1">attrs=</span><span class="s4">&quot; &quot;</span><span class="s1">.join(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">k</span><span class="s3">}</span><span class="s4">=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">!r}</span><span class="s4">&quot; </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.__dict__.items())</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right):</span>
        <span class="s2">&quot;&quot;&quot;detect collision between two sprites using scaled circles 
 
        pygame.sprite.collide_circle_radio(ratio)(left, right): return bool 
 
        Tests for collision between two sprites by testing whether two circles 
        centered on the sprites overlap after scaling the circle's radius by 
        the stored ratio. If the sprites have a &quot;radius&quot; attribute, that is 
        used to create the circle; otherwise, a circle is created that is big 
        enough to completely enclose the sprite's rect as given by the &quot;rect&quot; 
        attribute. Intended to be passed as a collided callback function to the 
        *collide functions. Sprites must have a &quot;rect&quot; and an optional &quot;radius&quot; 
        attribute. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">ratio = self.ratio</span>
        <span class="s1">xdistance = left.rect.centerx - right.rect.centerx</span>
        <span class="s1">ydistance = left.rect.centery - right.rect.centery</span>
        <span class="s1">distancesquared = xdistance**</span><span class="s5">2 </span><span class="s1">+ ydistance**</span><span class="s5">2</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">leftradius = left.radius</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s1">leftrect = left.rect</span>
            <span class="s1">leftradius = </span><span class="s5">0.5 </span><span class="s1">* ((leftrect.width**</span><span class="s5">2 </span><span class="s1">+ leftrect.height**</span><span class="s5">2</span><span class="s1">) ** </span><span class="s5">0.5</span><span class="s1">)</span>
            <span class="s0"># store the radius on the sprite for next time</span>
            <span class="s1">left.radius = leftradius</span>
        <span class="s1">leftradius *= ratio</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">rightradius = right.radius</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s1">rightrect = right.rect</span>
            <span class="s1">rightradius = </span><span class="s5">0.5 </span><span class="s1">* ((rightrect.width**</span><span class="s5">2 </span><span class="s1">+ rightrect.height**</span><span class="s5">2</span><span class="s1">) ** </span><span class="s5">0.5</span><span class="s1">)</span>
            <span class="s0"># store the radius on the sprite for next time</span>
            <span class="s1">right.radius = rightradius</span>
        <span class="s1">rightradius *= ratio</span>

        <span class="s3">return </span><span class="s1">distancesquared &lt;= (leftradius + rightradius) ** </span><span class="s5">2</span>


<span class="s3">def </span><span class="s1">collide_mask(left</span><span class="s3">, </span><span class="s1">right):</span>
    <span class="s2">&quot;&quot;&quot;collision detection between two sprites, using masks. 
 
    pygame.sprite.collide_mask(SpriteLeft, SpriteRight): bool 
 
    Tests for collision between two sprites by testing if their bitmasks 
    overlap. If the sprites have a &quot;mask&quot; attribute, that is used as the mask; 
    otherwise, a mask is created from the sprite image. Intended to be passed 
    as a collided callback function to the *collide functions. Sprites must 
    have a &quot;rect&quot; and an optional &quot;mask&quot; attribute. 
 
    New in pygame 1.8.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xoffset = right.rect[</span><span class="s5">0</span><span class="s1">] - left.rect[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">yoffset = right.rect[</span><span class="s5">1</span><span class="s1">] - left.rect[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">leftmask = left.mask</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
        <span class="s1">leftmask = from_surface(left.image)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">rightmask = right.mask</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
        <span class="s1">rightmask = from_surface(right.image)</span>
    <span class="s3">return </span><span class="s1">leftmask.overlap(rightmask</span><span class="s3">, </span><span class="s1">(xoffset</span><span class="s3">, </span><span class="s1">yoffset))</span>


<span class="s3">def </span><span class="s1">spritecollide(sprite</span><span class="s3">, </span><span class="s1">group</span><span class="s3">, </span><span class="s1">dokill</span><span class="s3">, </span><span class="s1">collided=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;find Sprites in a Group that intersect another Sprite 
 
    pygame.sprite.spritecollide(sprite, group, dokill, collided=None): 
        return Sprite_list 
 
    Return a list containing all Sprites in a Group that intersect with another 
    Sprite. Intersection is determined by comparing the Sprite.rect attribute 
    of each Sprite. 
 
    The dokill argument is a bool. If set to True, all Sprites that collide 
    will be removed from the Group. 
 
    The collided argument is a callback function used to calculate if two 
    sprites are colliding. it should take two sprites as values, and return a 
    bool value indicating if they are colliding. If collided is not passed, all 
    sprites must have a &quot;rect&quot; value, which is a rectangle of the sprite area, 
    which will be used to calculate the collision. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># pull the default collision function in as a local variable outside</span>
    <span class="s0"># the loop as this makes the loop run faster</span>
    <span class="s1">default_sprite_collide_func = sprite.rect.colliderect</span>

    <span class="s3">if </span><span class="s1">dokill:</span>

        <span class="s1">crashed = []</span>
        <span class="s1">append = crashed.append</span>

        <span class="s3">for </span><span class="s1">group_sprite </span><span class="s3">in </span><span class="s1">group.sprites():</span>
            <span class="s3">if </span><span class="s1">collided </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">collided(sprite</span><span class="s3">, </span><span class="s1">group_sprite):</span>
                    <span class="s1">group_sprite.kill()</span>
                    <span class="s1">append(group_sprite)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">default_sprite_collide_func(group_sprite.rect):</span>
                    <span class="s1">group_sprite.kill()</span>
                    <span class="s1">append(group_sprite)</span>

        <span class="s3">return </span><span class="s1">crashed</span>

    <span class="s3">if </span><span class="s1">collided </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">group_sprite </span><span class="s3">for </span><span class="s1">group_sprite </span><span class="s3">in </span><span class="s1">group </span><span class="s3">if </span><span class="s1">collided(sprite</span><span class="s3">, </span><span class="s1">group_sprite)</span>
        <span class="s1">]</span>

    <span class="s3">return </span><span class="s1">[</span>
        <span class="s1">group_sprite</span>
        <span class="s3">for </span><span class="s1">group_sprite </span><span class="s3">in </span><span class="s1">group</span>
        <span class="s3">if </span><span class="s1">default_sprite_collide_func(group_sprite.rect)</span>
    <span class="s1">]</span>


<span class="s3">def </span><span class="s1">groupcollide(groupa</span><span class="s3">, </span><span class="s1">groupb</span><span class="s3">, </span><span class="s1">dokilla</span><span class="s3">, </span><span class="s1">dokillb</span><span class="s3">, </span><span class="s1">collided=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;detect collision between a group and another group 
 
    pygame.sprite.groupcollide(groupa, groupb, dokilla, dokillb): 
        return dict 
 
    Given two groups, this will find the intersections between all sprites in 
    each group. It returns a dictionary of all sprites in the first group that 
    collide. The value for each item in the dictionary is a list of the sprites 
    in the second group it collides with. The two dokill arguments control if 
    the sprites from either group will be automatically removed from all 
    groups. Collided is a callback function used to calculate if two sprites 
    are colliding. it should take two sprites as values, and return a bool 
    value indicating if they are colliding. If collided is not passed, all 
    sprites must have a &quot;rect&quot; value, which is a rectangle of the sprite area 
    that will be used to calculate the collision. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">crashed = {}</span>
    <span class="s0"># pull the collision function in as a local variable outside</span>
    <span class="s0"># the loop as this makes the loop run faster</span>
    <span class="s1">sprite_collide_func = spritecollide</span>
    <span class="s3">if </span><span class="s1">dokilla:</span>
        <span class="s3">for </span><span class="s1">group_a_sprite </span><span class="s3">in </span><span class="s1">groupa.sprites():</span>
            <span class="s1">collision = sprite_collide_func(group_a_sprite</span><span class="s3">, </span><span class="s1">groupb</span><span class="s3">, </span><span class="s1">dokillb</span><span class="s3">, </span><span class="s1">collided)</span>
            <span class="s3">if </span><span class="s1">collision:</span>
                <span class="s1">crashed[group_a_sprite] = collision</span>
                <span class="s1">group_a_sprite.kill()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">group_a_sprite </span><span class="s3">in </span><span class="s1">groupa:</span>
            <span class="s1">collision = sprite_collide_func(group_a_sprite</span><span class="s3">, </span><span class="s1">groupb</span><span class="s3">, </span><span class="s1">dokillb</span><span class="s3">, </span><span class="s1">collided)</span>
            <span class="s3">if </span><span class="s1">collision:</span>
                <span class="s1">crashed[group_a_sprite] = collision</span>
    <span class="s3">return </span><span class="s1">crashed</span>


<span class="s3">def </span><span class="s1">spritecollideany(sprite</span><span class="s3">, </span><span class="s1">group</span><span class="s3">, </span><span class="s1">collided=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;finds any sprites in a group that collide with the given sprite 
 
    pygame.sprite.spritecollideany(sprite, group): return sprite 
 
    Given a sprite and a group of sprites, this will return return any single 
    sprite that collides with with the given sprite. If there are no 
    collisions, then this returns None. 
 
    If you don't need all the features of the spritecollide function, this 
    function will be a bit quicker. 
 
    Collided is a callback function used to calculate if two sprites are 
    colliding. It should take two sprites as values and return a bool value 
    indicating if they are colliding. If collided is not passed, then all 
    sprites must have a &quot;rect&quot; value, which is a rectangle of the sprite area, 
    which will be used to calculate the collision. 
 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># pull the default collision function in as a local variable outside</span>
    <span class="s0"># the loop as this makes the loop run faster</span>
    <span class="s1">default_sprite_collide_func = sprite.rect.colliderect</span>

    <span class="s3">if </span><span class="s1">collided </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">group_sprite </span><span class="s3">in </span><span class="s1">group:</span>
            <span class="s3">if </span><span class="s1">collided(sprite</span><span class="s3">, </span><span class="s1">group_sprite):</span>
                <span class="s3">return </span><span class="s1">group_sprite</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Special case old behaviour for speed.</span>
        <span class="s3">for </span><span class="s1">group_sprite </span><span class="s3">in </span><span class="s1">group:</span>
            <span class="s3">if </span><span class="s1">default_sprite_collide_func(group_sprite.rect):</span>
                <span class="s3">return </span><span class="s1">group_sprite</span>
    <span class="s3">return None</span>
</pre>
</body>
</html>