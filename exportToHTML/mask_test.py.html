<html>
<head>
<title>mask_test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mask_test.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">OrderedDict</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">random</span>
<span class="s0">import </span><span class="s1">unittest</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">import </span><span class="s1">pygame</span>
<span class="s0">from </span><span class="s1">pygame.locals </span><span class="s0">import </span><span class="s1">*</span>
<span class="s0">from </span><span class="s1">pygame.math </span><span class="s0">import </span><span class="s1">Vector2</span>
<span class="s0">from </span><span class="s1">pygame.tests.test_utils </span><span class="s0">import </span><span class="s1">AssertRaisesRegexMixin</span>


<span class="s1">IS_PYPY = </span><span class="s2">&quot;PyPy&quot; </span><span class="s1">== platform.python_implementation()</span>


<span class="s0">def </span><span class="s1">random_mask(size=(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)):</span>
    <span class="s4">&quot;&quot;&quot;random_mask(size=(100,100)): return Mask 
    Create a mask of the given size, with roughly half the bits set at random.&quot;&quot;&quot;</span>
    <span class="s1">m = pygame.Mask(size)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(size[</span><span class="s3">0</span><span class="s1">] * size[</span><span class="s3">1</span><span class="s1">] // </span><span class="s3">2</span><span class="s1">):</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">size[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">size[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">m.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
    <span class="s0">return </span><span class="s1">m</span>


<span class="s0">def </span><span class="s1">maskFromSurface(surface</span><span class="s0">, </span><span class="s1">threshold=</span><span class="s3">127</span><span class="s1">):</span>
    <span class="s1">mask = pygame.Mask(surface.get_size())</span>
    <span class="s1">key = surface.get_colorkey()</span>
    <span class="s0">if </span><span class="s1">key:</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surface.get_height()):</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surface.get_width()):</span>
                <span class="s0">if </span><span class="s1">surface.get_at((x + </span><span class="s3">0.1</span><span class="s0">, </span><span class="s1">y + </span><span class="s3">0.1</span><span class="s1">)) != key:</span>
                    <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surface.get_height()):</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surface.get_width()):</span>
                <span class="s0">if </span><span class="s1">surface.get_at((x</span><span class="s0">, </span><span class="s1">y))[</span><span class="s3">3</span><span class="s1">] &gt; threshold:</span>
                    <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">mask</span>


<span class="s0">def </span><span class="s1">create_bounding_rect(points):</span>
    <span class="s4">&quot;&quot;&quot;Creates a bounding rect from the given points.&quot;&quot;&quot;</span>
    <span class="s1">xmin = xmax = points[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">ymin = ymax = points[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">points[</span><span class="s3">1</span><span class="s1">:]:</span>
        <span class="s1">xmin = min(x</span><span class="s0">, </span><span class="s1">xmin)</span>
        <span class="s1">xmax = max(x</span><span class="s0">, </span><span class="s1">xmax)</span>
        <span class="s1">ymin = min(y</span><span class="s0">, </span><span class="s1">ymin)</span>
        <span class="s1">ymax = max(y</span><span class="s0">, </span><span class="s1">ymax)</span>

    <span class="s0">return </span><span class="s1">pygame.Rect((xmin</span><span class="s0">, </span><span class="s1">ymin)</span><span class="s0">, </span><span class="s1">(xmax - xmin + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">ymax - ymin + </span><span class="s3">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">zero_size_pairs(width</span><span class="s0">, </span><span class="s1">height):</span>
    <span class="s4">&quot;&quot;&quot;Creates a generator which yields pairs of sizes. 
 
    For each pair of sizes at least one of the sizes will have a 0 in it. 
    &quot;&quot;&quot;</span>
    <span class="s1">sizes = ((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">return </span><span class="s1">((a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">sizes </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">sizes </span><span class="s0">if </span><span class="s3">0 </span><span class="s0">in </span><span class="s1">a </span><span class="s0">or </span><span class="s3">0 </span><span class="s0">in </span><span class="s1">b)</span>


<span class="s0">def </span><span class="s1">corners(mask):</span>
    <span class="s4">&quot;&quot;&quot;Returns a tuple with the corner positions of the given mask. 
 
    Clockwise from the top left corner. 
    &quot;&quot;&quot;</span>
    <span class="s1">width</span><span class="s0">, </span><span class="s1">height = mask.get_size()</span>
    <span class="s0">return </span><span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">height - </span><span class="s3">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">off_corners(rect):</span>
    <span class="s4">&quot;&quot;&quot;Returns a tuple with the positions off of the corners of the given rect. 
 
    Clockwise from the top left corner. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">(</span>
        <span class="s1">(rect.left - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">rect.top)</span><span class="s0">,</span>
        <span class="s1">(rect.left - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">rect.top - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(rect.left</span><span class="s0">, </span><span class="s1">rect.top - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(rect.right - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">rect.top - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(rect.right</span><span class="s0">, </span><span class="s1">rect.top - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(rect.right</span><span class="s0">, </span><span class="s1">rect.top)</span><span class="s0">,</span>
        <span class="s1">(rect.right</span><span class="s0">, </span><span class="s1">rect.bottom - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(rect.right</span><span class="s0">, </span><span class="s1">rect.bottom)</span><span class="s0">,</span>
        <span class="s1">(rect.right - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">rect.bottom)</span><span class="s0">,</span>
        <span class="s1">(rect.left</span><span class="s0">, </span><span class="s1">rect.bottom)</span><span class="s0">,</span>
        <span class="s1">(rect.left - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">rect.bottom)</span><span class="s0">,</span>
        <span class="s1">(rect.left - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">rect.bottom - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">assertSurfaceFilled(testcase</span><span class="s0">, </span><span class="s1">surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">area_rect=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Checks to see if the given surface is filled with the given color. 
 
    If an area_rect is provided, only check that area of the surface. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">area_rect </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">x_range = range(surface.get_width())</span>
        <span class="s1">y_range = range(surface.get_height())</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">area_rect.normalize()</span>
        <span class="s1">area_rect = area_rect.clip(surface.get_rect())</span>
        <span class="s1">x_range = range(area_rect.left</span><span class="s0">, </span><span class="s1">area_rect.right)</span>
        <span class="s1">y_range = range(area_rect.top</span><span class="s0">, </span><span class="s1">area_rect.bottom)</span>

    <span class="s1">surface.lock()  </span><span class="s5"># Lock for possible speed up.</span>
    <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">y_range </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">x_range):</span>
        <span class="s1">testcase.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s1">surface.unlock()</span>


<span class="s0">def </span><span class="s1">assertSurfaceFilledIgnoreArea(testcase</span><span class="s0">, </span><span class="s1">surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">ignore_rect):</span>
    <span class="s4">&quot;&quot;&quot;Checks if the surface is filled with the given color. The 
    ignore_rect area is not checked. 
    &quot;&quot;&quot;</span>
    <span class="s1">x_range = range(surface.get_width())</span>
    <span class="s1">y_range = range(surface.get_height())</span>
    <span class="s1">ignore_rect.normalize()</span>

    <span class="s1">surface.lock()  </span><span class="s5"># Lock for possible speed up.</span>
    <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">y_range </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">x_range):</span>
        <span class="s0">if not </span><span class="s1">ignore_rect.collidepoint(pos):</span>
            <span class="s1">testcase.assertEqual(surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s1">surface.unlock()</span>


<span class="s0">def </span><span class="s1">assertMaskEqual(testcase</span><span class="s0">, </span><span class="s1">m1</span><span class="s0">, </span><span class="s1">m2</span><span class="s0">, </span><span class="s1">msg=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Checks to see if the 2 given masks are equal.&quot;&quot;&quot;</span>
    <span class="s1">m1_count = m1.count()</span>

    <span class="s1">testcase.assertEqual(m1.get_size()</span><span class="s0">, </span><span class="s1">m2.get_size()</span><span class="s0">, </span><span class="s1">msg=msg)</span>
    <span class="s1">testcase.assertEqual(m1_count</span><span class="s0">, </span><span class="s1">m2.count()</span><span class="s0">, </span><span class="s1">msg=msg)</span>
    <span class="s1">testcase.assertEqual(m1_count</span><span class="s0">, </span><span class="s1">m1.overlap_area(m2</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">msg=msg)</span>

    <span class="s5"># This can be used to help debug exact locations.</span>
    <span class="s5">##for i in range(m1.get_size()[0]):</span>
    <span class="s5">##    for j in range(m1.get_size()[1]):</span>
    <span class="s5">##        testcase.assertEqual(m1.get_at((i, j)), m2.get_at((i, j)))</span>


<span class="s5"># @unittest.skipIf(IS_PYPY, &quot;pypy has lots of mask failures&quot;)  # TODO</span>
<span class="s0">class </span><span class="s1">MaskTypeTest(AssertRaisesRegexMixin</span><span class="s0">, </span><span class="s1">unittest.TestCase):</span>
    <span class="s1">ORIGIN_OFFSETS = (</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure masks are created correctly without fill parameter.&quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">expected_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">23</span><span class="s1">)</span>

        <span class="s1">mask1 = pygame.mask.Mask(expected_size)</span>
        <span class="s1">mask2 = pygame.mask.Mask(size=expected_size)</span>

        <span class="s1">self.assertIsInstance(mask1</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

        <span class="s1">self.assertIsInstance(mask2</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_mask__negative_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure the mask constructor handles negative sizes correctly.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                <span class="s1">mask = pygame.Mask(size)</span>

    <span class="s0">def </span><span class="s1">test_mask__fill_kwarg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure masks are created correctly using the fill keyword.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">37</span><span class="s0">, </span><span class="s3">47</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">fill_counts = {</span><span class="s0">True</span><span class="s1">: width * height</span><span class="s0">, False</span><span class="s1">: </span><span class="s3">0</span><span class="s1">}</span>

        <span class="s0">for </span><span class="s1">fill</span><span class="s0">, </span><span class="s1">expected_count </span><span class="s0">in </span><span class="s1">fill_counts.items():</span>
            <span class="s1">msg = </span><span class="s2">f&quot;fill=</span><span class="s0">{</span><span class="s1">fill</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_mask__fill_kwarg_bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures masks are created correctly using the fill keyword 
        over a range of sizes. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">expected_count = width * height</span>
                <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
                <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">expected_size</span><span class="s0">}</span><span class="s2">&quot;</span>

                <span class="s1">mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_mask__fill_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure masks are created correctly using a fill arg.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">59</span><span class="s0">, </span><span class="s3">71</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">fill_counts = {</span><span class="s0">True</span><span class="s1">: width * height</span><span class="s0">, False</span><span class="s1">: </span><span class="s3">0</span><span class="s1">}</span>

        <span class="s0">for </span><span class="s1">fill</span><span class="s0">, </span><span class="s1">expected_count </span><span class="s0">in </span><span class="s1">fill_counts.items():</span>
            <span class="s1">msg = </span><span class="s2">f&quot;fill=</span><span class="s0">{</span><span class="s1">fill</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill)</span>

            <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_mask__size_kwarg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure masks are created correctly using the size keyword.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">73</span><span class="s0">, </span><span class="s3">83</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">fill_counts = {</span><span class="s0">True</span><span class="s1">: width * height</span><span class="s0">, False</span><span class="s1">: </span><span class="s3">0</span><span class="s1">}</span>

        <span class="s0">for </span><span class="s1">fill</span><span class="s0">, </span><span class="s1">expected_count </span><span class="s0">in </span><span class="s1">fill_counts.items():</span>
            <span class="s1">msg = </span><span class="s2">f&quot;fill=</span><span class="s0">{</span><span class="s1">fill</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">mask1 = pygame.mask.Mask(fill=fill</span><span class="s0">, </span><span class="s1">size=expected_size)</span>
            <span class="s1">mask2 = pygame.mask.Mask(size=expected_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">self.assertIsInstance(mask1</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertIsInstance(mask2</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_copy(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy works correctly with some bits set and unset.&quot;&quot;&quot;</span>
        <span class="s5"># Test different widths and heights.</span>
        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">33</span><span class="s0">, </span><span class="s3">63</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">65</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">33</span><span class="s0">, </span><span class="s3">63</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">65</span><span class="s1">):</span>
                <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

                <span class="s5"># Create a checkerboard pattern of set/unset bits.</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
                    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(x &amp; </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
                        <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>

                <span class="s5"># Test both the copy() and __copy__() methods.</span>
                <span class="s0">for </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">(mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask)):</span>
                    <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
                    <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
                    <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">test_copy__full(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy works correctly on a filled masked.&quot;&quot;&quot;</span>
        <span class="s5"># Test different widths and heights.</span>
        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">33</span><span class="s0">, </span><span class="s3">63</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">65</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">33</span><span class="s0">, </span><span class="s3">63</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">65</span><span class="s1">):</span>
                <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s5"># Test both the copy() and __copy__() methods.</span>
                <span class="s0">for </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">(mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask)):</span>
                    <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
                    <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
                    <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">test_copy__empty(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy works correctly on an empty mask.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">33</span><span class="s0">, </span><span class="s3">63</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">65</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">33</span><span class="s0">, </span><span class="s3">63</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">65</span><span class="s1">):</span>
                <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

                <span class="s5"># Test both the copy() and __copy__() methods.</span>
                <span class="s0">for </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">(mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask)):</span>
                    <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
                    <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
                    <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">test_copy__independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy makes an independent copy of the mask.&quot;&quot;&quot;</span>
        <span class="s1">mask_set_pos = (</span><span class="s3">64</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">mask_copy_set_pos = (</span><span class="s3">64</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

        <span class="s5"># Test both the copy() and __copy__() methods.</span>
        <span class="s1">mask_copies = (mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask))</span>
        <span class="s1">mask.set_at(mask_set_pos)</span>

        <span class="s0">for </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">mask_copies:</span>
            <span class="s1">mask_copy.set_at(mask_copy_set_pos)</span>

            <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s1">self.assertNotEqual(</span>
                <span class="s1">mask_copy.get_at(mask_set_pos)</span><span class="s0">, </span><span class="s1">mask.get_at(mask_set_pos)</span>
            <span class="s1">)</span>
            <span class="s1">self.assertNotEqual(</span>
                <span class="s1">mask_copy.get_at(mask_copy_set_pos)</span><span class="s0">, </span><span class="s1">mask.get_at(mask_copy_set_pos)</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_get_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's size is correctly retrieved.&quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">93</span><span class="s0">, </span><span class="s3">101</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_get_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect works correctly.&quot;&quot;&quot;</span>
        <span class="s1">expected_rect = pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">11</span><span class="s0">, </span><span class="s3">13</span><span class="s1">))</span>

        <span class="s5"># Test on full and empty masks.</span>
        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(expected_rect.size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">rect = mask.get_rect()</span>

            <span class="s1">self.assertEqual(rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_get_rect__one_kwarg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect supports a single rect attribute kwarg. 
 
        Tests all the rect attributes. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Rect attributes that take a single value.</span>
        <span class="s1">RECT_SINGLE_VALUE_ATTRIBUTES = (</span>
            <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;y&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;top&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;left&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;bottom&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;right&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;centerx&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;centery&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;height&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;w&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;h&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5"># Rect attributes that take 2 values.</span>
        <span class="s1">RECT_DOUBLE_VALUE_ATTRIBUTES = (</span>
            <span class="s2">&quot;topleft&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;bottomleft&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;topright&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;bottomright&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;midtop&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;midleft&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;midbottom&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;midright&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;center&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;size&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5"># Testing ints/floats and tuples/lists/Vector2s.</span>
        <span class="s5"># {attribute_names : attribute_values}</span>
        <span class="s1">rect_attributes = {</span>
            <span class="s1">RECT_SINGLE_VALUE_ATTRIBUTES: (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5.1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">RECT_DOUBLE_VALUE_ATTRIBUTES: ((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Vector2(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>

        <span class="s0">for </span><span class="s1">attributes</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">rect_attributes.items():</span>
            <span class="s0">for </span><span class="s1">attribute </span><span class="s0">in </span><span class="s1">attributes:</span>
                <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">values:</span>
                    <span class="s1">expected_rect = pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">size)</span>
                    <span class="s1">setattr(expected_rect</span><span class="s0">, </span><span class="s1">attribute</span><span class="s0">, </span><span class="s1">value)</span>

                    <span class="s1">rect = mask.get_rect(**{attribute: value})</span>

                    <span class="s1">self.assertEqual(rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_get_rect__multiple_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect supports multiple rect attribute kwargs.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">expected_rect = pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">7.1</span><span class="s0">, </span><span class="s2">&quot;top&quot;</span><span class="s1">: -</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s1">: Vector2(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3.2</span><span class="s1">)}</span>

        <span class="s0">for </span><span class="s1">attrib</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">kwargs.items():</span>
            <span class="s1">setattr(expected_rect</span><span class="s0">, </span><span class="s1">attrib</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s1">rect = mask.get_rect(**kwargs)</span>

        <span class="s1">self.assertEqual(rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_get_rect__no_arg_support(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect only supports kwargs.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_get_rect__invalid_kwarg_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect detects invalid kwargs.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError):</span>
            <span class="s1">rect = mask.get_rect(righte=</span><span class="s3">11</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError):</span>
            <span class="s1">rect = mask.get_rect(toplef=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(AttributeError):</span>
            <span class="s1">rect = mask.get_rect(move=(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_get_rect__invalid_kwarg_format(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect detects invalid kwarg formats.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">11</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(right=</span><span class="s2">&quot;1&quot;</span><span class="s1">)  </span><span class="s5"># Wrong type.</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(bottom=(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))  </span><span class="s5"># Wrong type.</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(centerx=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))  </span><span class="s5"># Wrong type.</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(midleft=(</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s1">))  </span><span class="s5"># Wrong type.</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(topright=(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))  </span><span class="s5"># Too few.</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(bottomleft=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))  </span><span class="s5"># Too many.</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">rect = mask.get_rect(midbottom=</span><span class="s3">1</span><span class="s1">)  </span><span class="s5"># Wrong type.</span>

    <span class="s0">def </span><span class="s1">test_get_at(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure individual mask bits are correctly retrieved.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span>
        <span class="s1">mask0 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>
        <span class="s1">mask1 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask0_expected_bit = </span><span class="s3">0</span>
        <span class="s1">mask1_expected_bit = </span><span class="s3">1</span>
        <span class="s1">pos = (width - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s5"># Check twice to make sure bits aren't toggled.</span>
        <span class="s1">self.assertEqual(mask0.get_at(pos)</span><span class="s0">, </span><span class="s1">mask0_expected_bit)</span>
        <span class="s1">self.assertEqual(mask0.get_at(pos=pos)</span><span class="s0">, </span><span class="s1">mask0_expected_bit)</span>
        <span class="s1">self.assertEqual(mask1.get_at(Vector2(pos))</span><span class="s0">, </span><span class="s1">mask1_expected_bit)</span>
        <span class="s1">self.assertEqual(mask1.get_at(pos=Vector2(pos))</span><span class="s0">, </span><span class="s1">mask1_expected_bit)</span>

    <span class="s0">def </span><span class="s1">test_get_at__out_of_bounds(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure get_at() checks bounds.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">11</span><span class="s0">, </span><span class="s3">3</span>
        <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.get_at((width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.get_at((-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_set_at(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure individual mask bits are set to 1.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span>
        <span class="s1">mask0 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>
        <span class="s1">mask1 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask0_expected_count = </span><span class="s3">1</span>
        <span class="s1">mask1_expected_count = mask1.count()</span>
        <span class="s1">expected_bit = </span><span class="s3">1</span>
        <span class="s1">pos = (width - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">mask0.set_at(pos</span><span class="s0">, </span><span class="s1">expected_bit)  </span><span class="s5"># set 0 to 1</span>
        <span class="s1">mask1.set_at(pos=Vector2(pos)</span><span class="s0">, </span><span class="s1">value=expected_bit)  </span><span class="s5"># set 1 to 1</span>

        <span class="s1">self.assertEqual(mask0.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_bit)</span>
        <span class="s1">self.assertEqual(mask0.count()</span><span class="s0">, </span><span class="s1">mask0_expected_count)</span>
        <span class="s1">self.assertEqual(mask1.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_bit)</span>
        <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_expected_count)</span>

    <span class="s0">def </span><span class="s1">test_set_at__to_0(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure individual mask bits are set to 0.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">11</span><span class="s0">, </span><span class="s3">7</span>
        <span class="s1">mask0 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>
        <span class="s1">mask1 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask0_expected_count = </span><span class="s3">0</span>
        <span class="s1">mask1_expected_count = mask1.count() - </span><span class="s3">1</span>
        <span class="s1">expected_bit = </span><span class="s3">0</span>
        <span class="s1">pos = (width - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">mask0.set_at(pos</span><span class="s0">, </span><span class="s1">expected_bit)  </span><span class="s5"># set 0 to 0</span>
        <span class="s1">mask1.set_at(pos</span><span class="s0">, </span><span class="s1">expected_bit)  </span><span class="s5"># set 1 to 0</span>

        <span class="s1">self.assertEqual(mask0.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_bit)</span>
        <span class="s1">self.assertEqual(mask0.count()</span><span class="s0">, </span><span class="s1">mask0_expected_count)</span>
        <span class="s1">self.assertEqual(mask1.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_bit)</span>
        <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_expected_count)</span>

    <span class="s0">def </span><span class="s1">test_set_at__default_value(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure individual mask bits are set using the default value.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">3</span><span class="s0">, </span><span class="s3">21</span>
        <span class="s1">mask0 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>
        <span class="s1">mask1 = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask0_expected_count = </span><span class="s3">1</span>
        <span class="s1">mask1_expected_count = mask1.count()</span>
        <span class="s1">expected_bit = </span><span class="s3">1</span>
        <span class="s1">pos = (width - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height - </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">mask0.set_at(pos)  </span><span class="s5"># set 0 to 1</span>
        <span class="s1">mask1.set_at(pos)  </span><span class="s5"># set 1 to 1</span>

        <span class="s1">self.assertEqual(mask0.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_bit)</span>
        <span class="s1">self.assertEqual(mask0.count()</span><span class="s0">, </span><span class="s1">mask0_expected_count)</span>
        <span class="s1">self.assertEqual(mask1.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_bit)</span>
        <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_expected_count)</span>

    <span class="s0">def </span><span class="s1">test_set_at__out_of_bounds(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure set_at() checks bounds.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">11</span><span class="s0">, </span><span class="s3">3</span>
        <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.set_at((width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.set_at((-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
            <span class="s1">mask.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_overlap(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure the overlap intersection is correctly calculated. 
 
        Testing the different combinations of full/empty masks: 
            (mask1-filled) 1 overlap 1 (mask2-filled) 
            (mask1-empty)  0 overlap 1 (mask2-filled) 
            (mask1-filled) 1 overlap 0 (mask2-empty) 
            (mask1-empty)  0 overlap 0 (mask2-empty) 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_default = </span><span class="s0">None</span>
        <span class="s1">expected_overlaps = {(</span><span class="s0">True, True</span><span class="s1">): offset}</span>

        <span class="s0">for </span><span class="s1">fill2 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask2 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill2)</span>
            <span class="s1">mask2_count = mask2.count()</span>

            <span class="s0">for </span><span class="s1">fill1 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">key = (fill1</span><span class="s0">, </span><span class="s1">fill2)</span>
                <span class="s1">msg = </span><span class="s2">f&quot;key=</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">mask1 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill1)</span>
                <span class="s1">mask1_count = mask1.count()</span>
                <span class="s1">expected_pos = expected_overlaps.get(key</span><span class="s0">, </span><span class="s1">expected_default)</span>

                <span class="s1">overlap_pos = mask1.overlap(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                <span class="s1">self.assertEqual(overlap_pos</span><span class="s0">, </span><span class="s1">expected_pos</span><span class="s0">, </span><span class="s1">msg)</span>

                <span class="s5"># Ensure mask1/mask2 unchanged.</span>
                <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap__offset(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset overlap intersection is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">66</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">expected_pos = (max(offset[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">max(offset[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

            <span class="s1">overlap_pos = mask1.overlap(other=mask2</span><span class="s0">, </span><span class="s1">offset=offset)</span>

            <span class="s1">self.assertEqual(overlap_pos</span><span class="s0">, </span><span class="s1">expected_pos</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap__offset_with_unset_bits(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset overlap intersection is correctly calculated 
        when (0, 0) bits not set.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">66</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">unset_pos = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask1.set_at(unset_pos</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask2.set_at(unset_pos</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = offset</span>
            <span class="s1">expected_y = max(y</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s3">0 </span><span class="s1">== y:</span>
                <span class="s1">expected_x = max(x + </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s3">0 </span><span class="s1">&lt; y:</span>
                <span class="s1">expected_x = max(x + </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_x = max(x</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

            <span class="s1">overlap_pos = mask1.overlap(mask2</span><span class="s0">, </span><span class="s1">Vector2(offset))</span>

            <span class="s1">self.assertEqual(overlap_pos</span><span class="s0">, </span><span class="s1">(expected_x</span><span class="s0">, </span><span class="s1">expected_y)</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_at(unset_pos)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_at(unset_pos)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap__no_overlap(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset overlap intersection is correctly calculated 
        when there is no overlap.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>

        <span class="s1">mask2_w</span><span class="s0">, </span><span class="s1">mask2_h = </span><span class="s3">67</span><span class="s0">, </span><span class="s3">5</span>
        <span class="s1">mask2_size = (mask2_w</span><span class="s0">, </span><span class="s1">mask2_h)</span>
        <span class="s1">mask2 = pygame.mask.Mask(mask2_size)</span>
        <span class="s1">set_pos = (mask2_w - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">mask2_h - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">mask2.set_at(set_pos)</span>
        <span class="s1">mask2_count = </span><span class="s3">1</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">overlap_pos = mask1.overlap(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertIsNone(overlap_pos</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_at(set_pos)</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap__offset_boundary(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap handles offsets and boundaries correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">13</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>

        <span class="s5"># Check the 4 boundaries.</span>
        <span class="s1">offsets = (</span>
            <span class="s1">(mask1_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off right</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">mask1_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,  </span><span class="s5"># off bottom</span>
            <span class="s1">(-mask2_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off left</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-mask2_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s5"># off top</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">overlap_pos = mask1.overlap(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertIsNone(overlap_pos</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap handles masks of different sizes correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">mask_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
                <span class="s1">mask_count = width * height</span>
                <span class="s1">mask1 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">mask2 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s5"># Testing masks offset from each other.</span>
                <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">mask_size</span><span class="s0">}</span><span class="s2">, offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s1">expected_pos = (max(offset[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">max(offset[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

                    <span class="s1">overlap_pos = mask1.overlap(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                    <span class="s1">self.assertEqual(overlap_pos</span><span class="s0">, </span><span class="s1">expected_pos</span><span class="s0">, </span><span class="s1">msg)</span>

                    <span class="s5"># Ensure mask1/mask2 unchanged.</span>
                    <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap__invalid_mask_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap handles invalid mask arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">invalid_mask = pygame.Surface(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">overlap_pos = mask.overlap(invalid_mask</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_overlap__invalid_offset_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap handles invalid offset arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">offset = </span><span class="s2">&quot;(0, 0)&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask(size)</span>
        <span class="s1">mask2 = pygame.mask.Mask(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">overlap_pos = mask1.overlap(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap_area(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure the overlap_area is correctly calculated. 
 
        Testing the different combinations of full/empty masks: 
            (mask1-filled) 1 overlap_area 1 (mask2-filled) 
            (mask1-empty)  0 overlap_area 1 (mask2-filled) 
            (mask1-filled) 1 overlap_area 0 (mask2-empty) 
            (mask1-empty)  0 overlap_area 0 (mask2-empty) 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = width</span><span class="s0">, </span><span class="s1">height = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_default = </span><span class="s3">0</span>
        <span class="s1">expected_counts = {(</span><span class="s0">True, True</span><span class="s1">): width * height}</span>

        <span class="s0">for </span><span class="s1">fill2 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask2 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill2)</span>
            <span class="s1">mask2_count = mask2.count()</span>

            <span class="s0">for </span><span class="s1">fill1 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">key = (fill1</span><span class="s0">, </span><span class="s1">fill2)</span>
                <span class="s1">msg = </span><span class="s2">f&quot;key=</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">mask1 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill1)</span>
                <span class="s1">mask1_count = mask1.count()</span>
                <span class="s1">expected_count = expected_counts.get(key</span><span class="s0">, </span><span class="s1">expected_default)</span>

                <span class="s1">overlap_count = mask1.overlap_area(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                <span class="s1">self.assertEqual(overlap_count</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

                <span class="s5"># Ensure mask1/mask2 unchanged.</span>
                <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap_area__offset(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset overlap_area is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">66</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>

        <span class="s5"># Using rects to help determine the overlapping area.</span>
        <span class="s1">rect1 = mask1.get_rect()</span>
        <span class="s1">rect2 = mask2.get_rect()</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">rect2.topleft = offset</span>
            <span class="s1">overlap_rect = rect1.clip(rect2)</span>
            <span class="s1">expected_count = overlap_rect.w * overlap_rect.h</span>

            <span class="s1">overlap_count = mask1.overlap_area(other=mask2</span><span class="s0">, </span><span class="s1">offset=offset)</span>

            <span class="s1">self.assertEqual(overlap_count</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap_area__offset_boundary(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_area handles offsets and boundaries correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">11</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s5"># Check the 4 boundaries.</span>
        <span class="s1">offsets = (</span>
            <span class="s1">(mask1_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off right</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">mask1_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,  </span><span class="s5"># off bottom</span>
            <span class="s1">(-mask2_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off left</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-mask2_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s5"># off top</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">overlap_count = mask1.overlap_area(mask2</span><span class="s0">, </span><span class="s1">Vector2(offset))</span>

            <span class="s1">self.assertEqual(overlap_count</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap_area__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_area handles masks of different sizes correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">mask_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
                <span class="s1">mask_count = width * height</span>
                <span class="s1">mask1 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">mask2 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s5"># Using rects to help determine the overlapping area.</span>
                <span class="s1">rect1 = mask1.get_rect()</span>
                <span class="s1">rect2 = mask2.get_rect()</span>

                <span class="s5"># Testing masks offset from each other.</span>
                <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">mask_size</span><span class="s0">}</span><span class="s2">, offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s1">rect2.topleft = offset</span>
                    <span class="s1">overlap_rect = rect1.clip(rect2)</span>
                    <span class="s1">expected_overlap_count = overlap_rect.w * overlap_rect.h</span>

                    <span class="s1">overlap_count = mask1.overlap_area(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                    <span class="s1">self.assertEqual(overlap_count</span><span class="s0">, </span><span class="s1">expected_overlap_count</span><span class="s0">, </span><span class="s1">msg)</span>

                    <span class="s5"># Ensure mask1/mask2 unchanged.</span>
                    <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap_area__invalid_mask_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap_area handles invalid mask arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">invalid_mask = pygame.Surface(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">overlap_count = mask.overlap_area(invalid_mask</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_overlap_area__invalid_offset_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap_area handles invalid offset arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">offset = </span><span class="s2">&quot;(0, 0)&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask(size)</span>
        <span class="s1">mask2 = pygame.mask.Mask(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">overlap_count = mask1.overlap_area(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_overlap_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap_mask's mask has correct bits set. 
 
        Testing the different combinations of full/empty masks: 
            (mask1-filled) 1 overlap_mask 1 (mask2-filled) 
            (mask1-empty)  0 overlap_mask 1 (mask2-filled) 
            (mask1-filled) 1 overlap_mask 0 (mask2-empty) 
            (mask1-empty)  0 overlap_mask 0 (mask2-empty) 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_default = pygame.mask.Mask(expected_size)</span>
        <span class="s1">expected_masks = {(</span><span class="s0">True, True</span><span class="s1">): pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)}</span>

        <span class="s0">for </span><span class="s1">fill2 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask2 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill2)</span>
            <span class="s1">mask2_count = mask2.count()</span>

            <span class="s0">for </span><span class="s1">fill1 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">key = (fill1</span><span class="s0">, </span><span class="s1">fill2)</span>
                <span class="s1">msg = </span><span class="s2">f&quot;key=</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">mask1 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill1)</span>
                <span class="s1">mask1_count = mask1.count()</span>
                <span class="s1">expected_mask = expected_masks.get(key</span><span class="s0">, </span><span class="s1">expected_default)</span>

                <span class="s1">overlap_mask = mask1.overlap_mask(other=mask2</span><span class="s0">, </span><span class="s1">offset=offset)</span>

                <span class="s1">self.assertIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">overlap_mask</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

                <span class="s5"># Ensure mask1/mask2 unchanged.</span>
                <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap_mask__bits_set(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap_mask's mask has correct bits set.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">50</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">300</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>

        <span class="s1">mask3 = mask1.overlap_mask(mask2</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">50</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(mask3.get_at((i</span><span class="s0">, </span><span class="s1">j))</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">f&quot;(</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">j</span><span class="s0">}</span><span class="s2">)&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">50</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">11</span><span class="s0">, </span><span class="s3">50</span><span class="s1">):</span>
                <span class="s1">self.assertEqual(mask3.get_at((i</span><span class="s0">, </span><span class="s1">j))</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s2">f&quot;(</span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">j</span><span class="s0">}</span><span class="s2">)&quot;</span><span class="s1">)</span>

        <span class="s5"># Ensure mask1/mask2 unchanged.</span>
        <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count)</span>
        <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count)</span>
        <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size)</span>
        <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size)</span>

    <span class="s0">def </span><span class="s1">test_overlap_mask__offset(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset overlap_mask's mask is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">66</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>
        <span class="s1">expected_mask = pygame.Mask(mask1_size)</span>

        <span class="s5"># Using rects to help determine the overlapping area.</span>
        <span class="s1">rect1 = mask1.get_rect()</span>
        <span class="s1">rect2 = mask2.get_rect()</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">rect2.topleft = offset</span>
            <span class="s1">overlap_rect = rect1.clip(rect2)</span>
            <span class="s1">expected_mask.clear()</span>
            <span class="s1">expected_mask.draw(</span>
                <span class="s1">pygame.Mask(overlap_rect.size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">overlap_rect.topleft</span>
            <span class="s1">)</span>

            <span class="s1">overlap_mask = mask1.overlap_mask(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">overlap_mask</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap_mask__specific_offsets(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset overlap_mask's mask is correctly calculated. 
 
        Testing the specific case of: 
            -both masks are wider than 32 bits 
            -a positive offset is used 
            -the mask calling overlap_mask() is wider than the mask passed in 
        &quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">33</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_mask = pygame.Mask(mask1.get_size())</span>

        <span class="s5"># Using rects to help determine the overlapping area.</span>
        <span class="s1">rect1 = mask1.get_rect()</span>
        <span class="s1">rect2 = mask2.get_rect()</span>

        <span class="s5"># This rect's corners are used to move rect2 around the inside of</span>
        <span class="s5"># rect1.</span>
        <span class="s1">corner_rect = rect1.inflate(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">corner </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;topleft&quot;</span><span class="s0">, </span><span class="s2">&quot;topright&quot;</span><span class="s0">, </span><span class="s2">&quot;bottomright&quot;</span><span class="s0">, </span><span class="s2">&quot;bottomleft&quot;</span><span class="s1">):</span>
            <span class="s1">setattr(rect2</span><span class="s0">, </span><span class="s1">corner</span><span class="s0">, </span><span class="s1">getattr(corner_rect</span><span class="s0">, </span><span class="s1">corner))</span>
            <span class="s1">offset = rect2.topleft</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">overlap_rect = rect1.clip(rect2)</span>
            <span class="s1">expected_mask.clear()</span>
            <span class="s1">expected_mask.draw(</span>
                <span class="s1">pygame.Mask(overlap_rect.size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">overlap_rect.topleft</span>
            <span class="s1">)</span>

            <span class="s1">overlap_mask = mask1.overlap_mask(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">overlap_mask</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap_mask__offset_boundary(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_mask handles offsets and boundaries correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">9</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">11</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">expected_size = mask1_size</span>

        <span class="s5"># Check the 4 boundaries.</span>
        <span class="s1">offsets = (</span>
            <span class="s1">(mask1_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off right</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">mask1_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,  </span><span class="s5"># off bottom</span>
            <span class="s1">(-mask2_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off left</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-mask2_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s5"># off top</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">overlap_mask = mask1.overlap_mask(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(overlap_mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(overlap_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_overlap_mask__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_mask handles masks of different sizes correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">mask_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
                <span class="s1">mask_count = width * height</span>
                <span class="s1">mask1 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">mask2 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">expected_mask = pygame.Mask(mask_size)</span>

                <span class="s5"># Using rects to help determine the overlapping area.</span>
                <span class="s1">rect1 = mask1.get_rect()</span>
                <span class="s1">rect2 = mask2.get_rect()</span>

                <span class="s5"># Testing masks offset from each other.</span>
                <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">mask_size</span><span class="s0">}</span><span class="s2">, offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s1">rect2.topleft = offset</span>
                    <span class="s1">overlap_rect = rect1.clip(rect2)</span>
                    <span class="s1">expected_mask.clear()</span>
                    <span class="s1">expected_mask.draw(</span>
                        <span class="s1">pygame.Mask(overlap_rect.size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">overlap_rect.topleft</span>
                    <span class="s1">)</span>

                    <span class="s1">overlap_mask = mask1.overlap_mask(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                    <span class="s1">self.assertIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">overlap_mask</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

                    <span class="s5"># Ensure mask1/mask2 unchanged.</span>
                    <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_overlap_mask__invalid_mask_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap_mask handles invalid mask arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">invalid_mask = pygame.Surface(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">overlap_mask = mask.overlap_mask(invalid_mask</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_overlap_mask__invalid_offset_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure overlap_mask handles invalid offset arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">offset = </span><span class="s2">&quot;(0, 0)&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask(size)</span>
        <span class="s1">mask2 = pygame.mask.Mask(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">overlap_mask = mask1.overlap_mask(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_mask_access(self):</span>
        <span class="s4">&quot;&quot;&quot;do the set_at, and get_at parts work correctly?&quot;&quot;&quot;</span>
        <span class="s1">m = pygame.Mask((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">m.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(m.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">m.set_at((</span><span class="s3">9</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(m.get_at((</span><span class="s3">9</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s5"># s = pygame.Surface((10,10))</span>
        <span class="s5"># s.set_at((1,0), (0, 0, 1, 255))</span>
        <span class="s5"># self.assertEqual(s.get_at((1,0)), (0, 0, 1, 255))</span>
        <span class="s5"># s.set_at((-1,0), (0, 0, 1, 255))</span>

        <span class="s5"># out of bounds, should get IndexError</span>
        <span class="s1">self.assertRaises(IndexError</span><span class="s0">, lambda</span><span class="s1">: m.get_at((-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)))</span>
        <span class="s1">self.assertRaises(IndexError</span><span class="s0">, lambda</span><span class="s1">: m.set_at((-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">self.assertRaises(IndexError</span><span class="s0">, lambda</span><span class="s1">: m.set_at((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">self.assertRaises(IndexError</span><span class="s0">, lambda</span><span class="s1">: m.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_fill(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask can be filled.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">11</span><span class="s0">, </span><span class="s3">23</span>
        <span class="s1">expected_count = width * height</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

        <span class="s1">mask.fill()</span>

        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_fill__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures masks of different sizes are filled correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>
                <span class="s1">expected_count = width * height</span>

                <span class="s1">mask.fill()</span>

                <span class="s1">self.assertEqual(</span>
                    <span class="s1">mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s2">f&quot;size=(</span><span class="s0">{</span><span class="s1">width</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">height</span><span class="s0">}</span><span class="s2">)&quot;</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_clear(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask can be cleared.&quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">expected_size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">27</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">mask.clear()</span>

        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_clear__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures masks of different sizes are cleared correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s1">mask.clear()</span>

                <span class="s1">self.assertEqual(</span>
                    <span class="s1">mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s2">f&quot;size=(</span><span class="s0">{</span><span class="s1">width</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">height</span><span class="s0">}</span><span class="s2">)&quot;</span>
                <span class="s1">)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_invert(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask can be inverted.&quot;&quot;&quot;</span>
        <span class="s1">side = </span><span class="s3">73</span>
        <span class="s1">expected_size = (side</span><span class="s0">, </span><span class="s1">side)</span>
        <span class="s1">mask1 = pygame.mask.Mask(expected_size)</span>
        <span class="s1">mask2 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_count1 = side * side</span>
        <span class="s1">expected_count2 = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(side):</span>
            <span class="s1">expected_count1 -= </span><span class="s3">1</span>
            <span class="s1">expected_count2 += </span><span class="s3">1</span>
            <span class="s1">pos = (i</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">mask1.set_at(pos)</span>
            <span class="s1">mask2.set_at(pos</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">mask1.invert()</span>
        <span class="s1">mask2.invert()</span>

        <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">expected_count1)</span>
        <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">expected_count2)</span>
        <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(side):</span>
            <span class="s1">pos = (i</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">msg = </span><span class="s2">f&quot;pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">self.assertEqual(mask1.get_at(pos)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_at(pos)</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_invert__full(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a full mask can be inverted.&quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">expected_size = (</span><span class="s3">43</span><span class="s0">, </span><span class="s3">97</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">mask.invert()</span>

        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_invert__empty(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an empty mask can be inverted.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">43</span><span class="s0">, </span><span class="s3">97</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">expected_count = width * height</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

        <span class="s1">mask.invert()</span>

        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_invert__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures masks of different sizes are inverted correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                    <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=fill)</span>
                    <span class="s1">expected_count = </span><span class="s3">0 </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">width * height</span>

                    <span class="s1">mask.invert()</span>

                    <span class="s1">self.assertEqual(</span>
                        <span class="s1">mask.count()</span><span class="s0">,</span>
                        <span class="s1">expected_count</span><span class="s0">,</span>
                        <span class="s2">f&quot;fill=</span><span class="s0">{</span><span class="s1">fill</span><span class="s0">}</span><span class="s2">, size=(</span><span class="s0">{</span><span class="s1">width</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">height</span><span class="s0">}</span><span class="s2">)&quot;</span><span class="s0">,</span>
                    <span class="s1">)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_scale(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask can be scaled.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">43</span><span class="s0">, </span><span class="s3">61</span>
        <span class="s1">original_size = (width</span><span class="s0">, </span><span class="s1">height)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">original_mask = pygame.mask.Mask(original_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">original_count = width * height </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s3">0</span>

            <span class="s5"># Test a range of sizes. Also tests scaling to 'same'</span>
            <span class="s5"># size when new_w, new_h = width, height</span>
            <span class="s0">for </span><span class="s1">new_w </span><span class="s0">in </span><span class="s1">range(width - </span><span class="s3">10</span><span class="s0">, </span><span class="s1">width + </span><span class="s3">10</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">new_h </span><span class="s0">in </span><span class="s1">range(height - </span><span class="s3">10</span><span class="s0">, </span><span class="s1">height + </span><span class="s3">10</span><span class="s1">):</span>
                    <span class="s1">expected_size = (new_w</span><span class="s0">, </span><span class="s1">new_h)</span>
                    <span class="s1">expected_count = new_w * new_h </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s3">0</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">expected_size</span><span class="s0">}</span><span class="s2">&quot;</span>

                    <span class="s1">mask = original_mask.scale(scale=expected_size)</span>

                    <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

                    <span class="s5"># Ensure the original mask is unchanged.</span>
                    <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">original_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">original_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_scale__negative_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure scale handles negative sizes correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.Mask((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s1">mask.scale((-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s1">mask.scale(Vector2(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
            <span class="s1">mask.scale((</span><span class="s3">10</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_draw(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask can be drawn onto another mask. 
 
        Testing the different combinations of full/empty masks: 
            (mask1-filled) 1 draw 1 (mask2-filled) 
            (mask1-empty)  0 draw 1 (mask2-filled) 
            (mask1-filled) 1 draw 0 (mask2-empty) 
            (mask1-empty)  0 draw 0 (mask2-empty) 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_default = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_masks = {(</span><span class="s0">False, False</span><span class="s1">): pygame.mask.Mask(expected_size)}</span>

        <span class="s0">for </span><span class="s1">fill2 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask2 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill2)</span>
            <span class="s1">mask2_count = mask2.count()</span>

            <span class="s0">for </span><span class="s1">fill1 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">key = (fill1</span><span class="s0">, </span><span class="s1">fill2)</span>
                <span class="s1">msg = </span><span class="s2">f&quot;key=</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">mask1 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill1)</span>
                <span class="s1">expected_mask = expected_masks.get(key</span><span class="s0">, </span><span class="s1">expected_default)</span>

                <span class="s1">mask1.draw(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

                <span class="s5"># Ensure mask2 unchanged.</span>
                <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_draw__offset(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset mask can be drawn onto another mask.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">66</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>
        <span class="s1">expected_mask = pygame.Mask(mask1.get_size())</span>

        <span class="s5"># Using rects to help determine the overlapping area.</span>
        <span class="s1">rect1 = mask1.get_rect()</span>
        <span class="s1">rect2 = mask2.get_rect()</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">rect2.topleft = offset</span>
            <span class="s1">overlap_rect = rect1.clip(rect2)</span>
            <span class="s1">expected_mask.clear()</span>

            <span class="s5"># Normally draw() could be used to set these bits, but the draw()</span>
            <span class="s5"># method is being tested here, so a loop is used instead.</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(overlap_rect.left</span><span class="s0">, </span><span class="s1">overlap_rect.right):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(overlap_rect.top</span><span class="s0">, </span><span class="s1">overlap_rect.bottom):</span>
                    <span class="s1">expected_mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
            <span class="s1">mask1.clear()  </span><span class="s5"># Ensure it's empty for testing each offset.</span>

            <span class="s1">mask1.draw(other=mask2</span><span class="s0">, </span><span class="s1">offset=offset)</span>

            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_draw__specific_offsets(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset mask can be drawn onto another mask. 
 
        Testing the specific case of: 
            -both masks are wider than 32 bits 
            -a positive offset is used 
            -the mask calling draw() is wider than the mask passed in 
        &quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">33</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_mask = pygame.Mask(mask1.get_size())</span>

        <span class="s5"># Using rects to help determine the overlapping area.</span>
        <span class="s1">rect1 = mask1.get_rect()</span>
        <span class="s1">rect2 = mask2.get_rect()</span>

        <span class="s5"># This rect's corners are used to move rect2 around the inside of</span>
        <span class="s5"># rect1.</span>
        <span class="s1">corner_rect = rect1.inflate(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">corner </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;topleft&quot;</span><span class="s0">, </span><span class="s2">&quot;topright&quot;</span><span class="s0">, </span><span class="s2">&quot;bottomright&quot;</span><span class="s0">, </span><span class="s2">&quot;bottomleft&quot;</span><span class="s1">):</span>
            <span class="s1">setattr(rect2</span><span class="s0">, </span><span class="s1">corner</span><span class="s0">, </span><span class="s1">getattr(corner_rect</span><span class="s0">, </span><span class="s1">corner))</span>
            <span class="s1">offset = rect2.topleft</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">overlap_rect = rect1.clip(rect2)</span>
            <span class="s1">expected_mask.clear()</span>

            <span class="s5"># Normally draw() could be used to set these bits, but the draw()</span>
            <span class="s5"># method is being tested here, so a loop is used instead.</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(overlap_rect.left</span><span class="s0">, </span><span class="s1">overlap_rect.right):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(overlap_rect.top</span><span class="s0">, </span><span class="s1">overlap_rect.bottom):</span>
                    <span class="s1">expected_mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
            <span class="s1">mask1.clear()  </span><span class="s5"># Ensure it's empty for testing each offset.</span>

            <span class="s1">mask1.draw(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_draw__offset_boundary(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw handles offsets and boundaries correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">13</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>

        <span class="s5"># Check the 4 boundaries.</span>
        <span class="s1">offsets = (</span>
            <span class="s1">(mask1_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off right</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">mask1_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,  </span><span class="s5"># off bottom</span>
            <span class="s1">(-mask2_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off left</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-mask2_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s5"># off top</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">mask1.draw(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_draw__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw handles masks of different sizes correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">mask_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
                <span class="s1">mask_count = width * height</span>
                <span class="s1">mask1 = pygame.mask.Mask(mask_size)</span>
                <span class="s1">mask2 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">expected_mask = pygame.Mask(mask_size)</span>

                <span class="s5"># Using rects to help determine the overlapping area.</span>
                <span class="s1">rect1 = mask1.get_rect()</span>
                <span class="s1">rect2 = mask2.get_rect()</span>

                <span class="s5"># Testing masks offset from each other.</span>
                <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">mask_size</span><span class="s0">}</span><span class="s2">, offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s1">rect2.topleft = offset</span>
                    <span class="s1">overlap_rect = rect1.clip(rect2)</span>
                    <span class="s1">expected_mask.clear()</span>

                    <span class="s5"># Normally draw() could be used to set these bits, but the</span>
                    <span class="s5"># draw() method is being tested here, so a loop is used</span>
                    <span class="s5"># instead.</span>
                    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(overlap_rect.left</span><span class="s0">, </span><span class="s1">overlap_rect.right):</span>
                        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(overlap_rect.top</span><span class="s0">, </span><span class="s1">overlap_rect.bottom):</span>
                            <span class="s1">expected_mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
                    <span class="s1">mask1.clear()  </span><span class="s5"># Ensure it's empty for each test.</span>

                    <span class="s1">mask1.draw(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                    <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

                    <span class="s5"># Ensure mask2 unchanged.</span>
                    <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_draw__invalid_mask_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure draw handles invalid mask arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">invalid_mask = pygame.Surface(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">mask.draw(invalid_mask</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_draw__invalid_offset_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure draw handles invalid offset arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">offset = </span><span class="s2">&quot;(0, 0)&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask(size)</span>
        <span class="s1">mask2 = pygame.mask.Mask(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">mask1.draw(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_erase(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask can erase another mask. 
 
        Testing the different combinations of full/empty masks: 
            (mask1-filled) 1 erase 1 (mask2-filled) 
            (mask1-empty)  0 erase 1 (mask2-filled) 
            (mask1-filled) 1 erase 0 (mask2-empty) 
            (mask1-empty)  0 erase 0 (mask2-empty) 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_default = pygame.mask.Mask(expected_size)</span>
        <span class="s1">expected_masks = {(</span><span class="s0">True, False</span><span class="s1">): pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)}</span>

        <span class="s0">for </span><span class="s1">fill2 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask2 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill2)</span>
            <span class="s1">mask2_count = mask2.count()</span>

            <span class="s0">for </span><span class="s1">fill1 </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">key = (fill1</span><span class="s0">, </span><span class="s1">fill2)</span>
                <span class="s1">msg = </span><span class="s2">f&quot;key=</span><span class="s0">{</span><span class="s1">key</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">mask1 = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=fill1)</span>
                <span class="s1">expected_mask = expected_masks.get(key</span><span class="s0">, </span><span class="s1">expected_default)</span>

                <span class="s1">mask1.erase(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

                <span class="s5"># Ensure mask2 unchanged.</span>
                <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_erase__offset(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset mask can erase another mask.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">66</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>
        <span class="s1">expected_mask = pygame.Mask(mask1.get_size())</span>

        <span class="s5"># Using rects to help determine the overlapping area.</span>
        <span class="s1">rect1 = mask1.get_rect()</span>
        <span class="s1">rect2 = mask2.get_rect()</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">rect2.topleft = offset</span>
            <span class="s1">overlap_rect = rect1.clip(rect2)</span>
            <span class="s1">expected_mask.fill()</span>

            <span class="s5"># Normally erase() could be used to clear these bits, but the</span>
            <span class="s5"># erase() method is being tested here, so a loop is used instead.</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(overlap_rect.left</span><span class="s0">, </span><span class="s1">overlap_rect.right):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(overlap_rect.top</span><span class="s0">, </span><span class="s1">overlap_rect.bottom):</span>
                    <span class="s1">expected_mask.set_at((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">mask1.fill()  </span><span class="s5"># Ensure it's filled for testing each offset.</span>

            <span class="s1">mask1.erase(other=mask2</span><span class="s0">, </span><span class="s1">offset=offset)</span>

            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s5"># Ensure mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_erase__specific_offsets(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an offset mask can erase another mask. 
 
        Testing the specific case of: 
            -both masks are wider than 32 bits 
            -a positive offset is used 
            -the mask calling erase() is wider than the mask passed in 
        &quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">33</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_mask = pygame.Mask(mask1.get_size())</span>

        <span class="s5"># Using rects to help determine the overlapping area.</span>
        <span class="s1">rect1 = mask1.get_rect()</span>
        <span class="s1">rect2 = mask2.get_rect()</span>

        <span class="s5"># This rect's corners are used to move rect2 around the inside of</span>
        <span class="s5"># rect1.</span>
        <span class="s1">corner_rect = rect1.inflate(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">corner </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;topleft&quot;</span><span class="s0">, </span><span class="s2">&quot;topright&quot;</span><span class="s0">, </span><span class="s2">&quot;bottomright&quot;</span><span class="s0">, </span><span class="s2">&quot;bottomleft&quot;</span><span class="s1">):</span>
            <span class="s1">setattr(rect2</span><span class="s0">, </span><span class="s1">corner</span><span class="s0">, </span><span class="s1">getattr(corner_rect</span><span class="s0">, </span><span class="s1">corner))</span>
            <span class="s1">offset = rect2.topleft</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">overlap_rect = rect1.clip(rect2)</span>
            <span class="s1">expected_mask.fill()</span>

            <span class="s5"># Normally erase() could be used to clear these bits, but the</span>
            <span class="s5"># erase() method is being tested here, so a loop is used instead.</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(overlap_rect.left</span><span class="s0">, </span><span class="s1">overlap_rect.right):</span>
                <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(overlap_rect.top</span><span class="s0">, </span><span class="s1">overlap_rect.bottom):</span>
                    <span class="s1">expected_mask.set_at((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">mask1.fill()  </span><span class="s5"># Ensure it's filled for testing each offset.</span>

            <span class="s1">mask1.erase(mask2</span><span class="s0">, </span><span class="s1">Vector2(offset))</span>

            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_erase__offset_boundary(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures erase handles offsets and boundaries correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask2 = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">13</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask1_count = mask1.count()</span>
        <span class="s1">mask2_count = mask2.count()</span>
        <span class="s1">mask1_size = mask1.get_size()</span>
        <span class="s1">mask2_size = mask2.get_size()</span>

        <span class="s5"># Check the 4 boundaries.</span>
        <span class="s1">offsets = (</span>
            <span class="s1">(mask1_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off right</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">mask1_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,  </span><span class="s5"># off bottom</span>
            <span class="s1">(-mask2_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># off left</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-mask2_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s5"># off top</span>

        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets:</span>
            <span class="s1">msg = </span><span class="s2">f&quot;offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>

            <span class="s1">mask1.erase(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s5"># Ensure mask1/mask2 unchanged.</span>
            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">mask1_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask2_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">mask1_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask2_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_erase__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures erase handles masks of different sizes correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                <span class="s1">mask_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
                <span class="s1">mask_count = width * height</span>
                <span class="s1">mask1 = pygame.mask.Mask(mask_size)</span>
                <span class="s1">mask2 = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">expected_mask = pygame.Mask(mask_size)</span>

                <span class="s5"># Using rects to help determine the overlapping area.</span>
                <span class="s1">rect1 = mask1.get_rect()</span>
                <span class="s1">rect2 = mask2.get_rect()</span>

                <span class="s5"># Testing masks offset from each other.</span>
                <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">mask_size</span><span class="s0">}</span><span class="s2">, offset=</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s1">rect2.topleft = offset</span>
                    <span class="s1">overlap_rect = rect1.clip(rect2)</span>
                    <span class="s1">expected_mask.fill()</span>

                    <span class="s5"># Normally erase() could be used to clear these bits, but</span>
                    <span class="s5"># the erase() method is being tested here, so a loop is</span>
                    <span class="s5"># used instead.</span>
                    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(overlap_rect.left</span><span class="s0">, </span><span class="s1">overlap_rect.right):</span>
                        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(overlap_rect.top</span><span class="s0">, </span><span class="s1">overlap_rect.bottom):</span>
                            <span class="s1">expected_mask.set_at((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
                    <span class="s1">mask1.fill()  </span><span class="s5"># Ensure it's filled for each test.</span>

                    <span class="s1">mask1.erase(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

                    <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask1</span><span class="s0">, </span><span class="s1">expected_mask</span><span class="s0">, </span><span class="s1">msg)</span>

                    <span class="s5"># Ensure mask2 unchanged.</span>
                    <span class="s1">self.assertEqual(mask2.count()</span><span class="s0">, </span><span class="s1">mask_count</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">mask_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_erase__invalid_mask_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure erase handles invalid mask arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">invalid_mask = pygame.Surface(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">mask.erase(invalid_mask</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_erase__invalid_offset_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure erase handles invalid offset arguments correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">offset = </span><span class="s2">&quot;(0, 0)&quot;</span>
        <span class="s1">mask1 = pygame.mask.Mask(size)</span>
        <span class="s1">mask2 = pygame.mask.Mask(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">mask1.erase(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

    <span class="s0">def </span><span class="s1">test_count(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's set bits are correctly counted.&quot;&quot;&quot;</span>
        <span class="s1">side = </span><span class="s3">67</span>
        <span class="s1">expected_size = (side</span><span class="s0">, </span><span class="s1">side)</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(side):</span>
            <span class="s1">expected_count += </span><span class="s3">1</span>
            <span class="s1">mask.set_at((i</span><span class="s0">, </span><span class="s1">i))</span>

        <span class="s1">count = mask.count()</span>

        <span class="s1">self.assertEqual(count</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_count__bit_boundaries(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the set bits of different sized masks are counted correctly. 
 
        Tests masks of different sizes, including: 
           -masks 31 to 33 bits wide (32 bit boundaries) 
           -masks 63 to 65 bits wide (64 bit boundaries) 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">height </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">):</span>
                <span class="s0">for </span><span class="s1">width </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">66</span><span class="s1">):</span>
                    <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height)</span><span class="s0">, </span><span class="s1">fill=fill)</span>
                    <span class="s1">expected_count = width * height </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s3">0</span>

                    <span class="s5"># Test toggling each bit.</span>
                    <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)):</span>
                        <span class="s0">if </span><span class="s1">fill:</span>
                            <span class="s1">mask.set_at(pos</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
                            <span class="s1">expected_count -= </span><span class="s3">1</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">mask.set_at(pos</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
                            <span class="s1">expected_count += </span><span class="s3">1</span>

                        <span class="s1">count = mask.count()</span>

                        <span class="s1">self.assertEqual(</span>
                            <span class="s1">count</span><span class="s0">,</span>
                            <span class="s1">expected_count</span><span class="s0">,</span>
                            <span class="s2">f&quot;fill=</span><span class="s0">{</span><span class="s1">fill</span><span class="s0">}</span><span class="s2">, size=(</span><span class="s0">{</span><span class="s1">width</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">height</span><span class="s0">}</span><span class="s2">), pos=</span><span class="s0">{</span><span class="s1">pos</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
                        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_count__full_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a full mask's set bits are correctly counted.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">17</span><span class="s0">, </span><span class="s3">97</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">expected_count = width * height</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">count = mask.count()</span>

        <span class="s1">self.assertEqual(count</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_count__empty_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an empty mask's set bits are correctly counted.&quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">expected_size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">27</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

        <span class="s1">count = mask.count()</span>

        <span class="s1">self.assertEqual(count</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_centroid(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a filled mask's centroid is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_centroid = mask.get_rect().center</span>

        <span class="s1">centroid = mask.centroid()</span>

        <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">test_centroid__empty_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an empty mask's centroid is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">expected_centroid = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_size = (</span><span class="s3">101</span><span class="s0">, </span><span class="s3">103</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

        <span class="s1">centroid = mask.centroid()</span>

        <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_centroid__single_row(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's centroid is correctly calculated 
        when setting points along a single row.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height):</span>
            <span class="s1">mask.clear()  </span><span class="s5"># Clear for each row.</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
                <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">expected_centroid = (x // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">y)</span>

                <span class="s1">centroid = mask.centroid()</span>

                <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">test_centroid__two_rows(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's centroid is correctly calculated 
        when setting points along two rows.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s5"># The first row is tested with each of the other rows.</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">height):</span>
            <span class="s1">mask.clear()  </span><span class="s5"># Clear for each set of rows.</span>

            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
                <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">expected_centroid = (x // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">y // </span><span class="s3">2</span><span class="s1">)</span>

                <span class="s1">centroid = mask.centroid()</span>

                <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">test_centroid__single_column(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's centroid is correctly calculated 
        when setting points along a single column.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width):</span>
            <span class="s1">mask.clear()  </span><span class="s5"># Clear for each column.</span>

            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height):</span>
                <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">expected_centroid = (x</span><span class="s0">, </span><span class="s1">y // </span><span class="s3">2</span><span class="s1">)</span>

                <span class="s1">centroid = mask.centroid()</span>

                <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">test_centroid__two_columns(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's centroid is correctly calculated 
        when setting points along two columns.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((width</span><span class="s0">, </span><span class="s1">height))</span>

        <span class="s5"># The first column is tested with each of the other columns.</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">width):</span>
            <span class="s1">mask.clear()  </span><span class="s5"># Clear for each set of columns.</span>

            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height):</span>
                <span class="s1">mask.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">mask.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s1">expected_centroid = (x // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">y // </span><span class="s3">2</span><span class="s1">)</span>

                <span class="s1">centroid = mask.centroid()</span>

                <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">test_centroid__all_corners(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's centroid is correctly calculated 
        when its corners are set.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>
        <span class="s1">expected_centroid = mask.get_rect().center</span>

        <span class="s0">for </span><span class="s1">corner </span><span class="s0">in </span><span class="s1">corners(mask):</span>
            <span class="s1">mask.set_at(corner)</span>

        <span class="s1">centroid = mask.centroid()</span>

        <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">test_centroid__two_corners(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's centroid is correctly calculated 
        when only two corners are set.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>
        <span class="s1">mask_rect = mask.get_rect()</span>
        <span class="s1">mask_corners = corners(mask)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">corner1 </span><span class="s0">in </span><span class="s1">enumerate(mask_corners):</span>
            <span class="s0">for </span><span class="s1">corner2 </span><span class="s0">in </span><span class="s1">mask_corners[i + </span><span class="s3">1 </span><span class="s1">:]:</span>
                <span class="s1">mask.clear()  </span><span class="s5"># Clear for each pair of corners.</span>
                <span class="s1">mask.set_at(corner1)</span>
                <span class="s1">mask.set_at(corner2)</span>

                <span class="s0">if </span><span class="s1">corner1[</span><span class="s3">0</span><span class="s1">] == corner2[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s1">expected_centroid = (corner1[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">abs(corner1[</span><span class="s3">1</span><span class="s1">] - corner2[</span><span class="s3">1</span><span class="s1">]) // </span><span class="s3">2</span><span class="s1">)</span>
                <span class="s0">elif </span><span class="s1">corner1[</span><span class="s3">1</span><span class="s1">] == corner2[</span><span class="s3">1</span><span class="s1">]:</span>
                    <span class="s1">expected_centroid = (abs(corner1[</span><span class="s3">0</span><span class="s1">] - corner2[</span><span class="s3">0</span><span class="s1">]) // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">corner1[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">expected_centroid = mask_rect.center</span>

                <span class="s1">centroid = mask.centroid()</span>

                <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">todo_test_angle(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's orientation angle is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">self.fail()</span>

    <span class="s0">def </span><span class="s1">test_angle__empty_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure an empty mask's angle is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">expected_angle = </span><span class="s3">0.0</span>
        <span class="s1">expected_size = (</span><span class="s3">107</span><span class="s0">, </span><span class="s3">43</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

        <span class="s1">angle = mask.angle()</span>

        <span class="s1">self.assertIsInstance(angle</span><span class="s0">, </span><span class="s1">float)</span>
        <span class="s1">self.assertAlmostEqual(angle</span><span class="s0">, </span><span class="s1">expected_angle)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_drawing(self):</span>
        <span class="s4">&quot;&quot;&quot;Test fill, clear, invert, draw, erase&quot;&quot;&quot;</span>
        <span class="s1">m = pygame.Mask((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(m.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">m.fill()</span>
        <span class="s1">self.assertEqual(m.count()</span><span class="s0">, </span><span class="s3">10000</span><span class="s1">)</span>

        <span class="s1">m2 = pygame.Mask((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">m.erase(m2</span><span class="s0">, </span><span class="s1">(</span><span class="s3">50</span><span class="s0">, </span><span class="s3">50</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(m.count()</span><span class="s0">, </span><span class="s3">9900</span><span class="s1">)</span>

        <span class="s1">m.invert()</span>
        <span class="s1">self.assertEqual(m.count()</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>

        <span class="s1">m.draw(m2</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(m.count()</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span>

        <span class="s1">m.clear()</span>
        <span class="s1">self.assertEqual(m.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_outline(self):</span>
        <span class="s4">&quot;&quot;&quot; &quot;&quot;&quot;</span>

        <span class="s1">m = pygame.Mask((</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))</span>
        <span class="s1">self.assertEqual(m.outline()</span><span class="s0">, </span><span class="s1">[])</span>

        <span class="s1">m.set_at((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(m.outline()</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)])</span>

        <span class="s1">m.set_at((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(m.outline(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)])</span>

        <span class="s1">m.set_at((</span><span class="s3">11</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">m.outline()</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">11</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">11</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">self.assertEqual(m.outline(every=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)])</span>

        <span class="s5"># TODO: Test more corner case outlines.</span>

    <span class="s0">def </span><span class="s1">test_convolve__size(self):</span>
        <span class="s1">sizes = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">31</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">32</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">s1 </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">m1 = pygame.Mask(s1)</span>
            <span class="s0">for </span><span class="s1">s2 </span><span class="s0">in </span><span class="s1">sizes:</span>
                <span class="s1">m2 = pygame.Mask(s2)</span>
                <span class="s1">o = m1.convolve(m2)</span>

                <span class="s1">self.assertIsInstance(o</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>

                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
                    <span class="s1">self.assertEqual(</span>
                        <span class="s1">o.get_size()[i]</span><span class="s0">, </span><span class="s1">m1.get_size()[i] + m2.get_size()[i] - </span><span class="s3">1</span>
                    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_convolve__point_identities(self):</span>
        <span class="s4">&quot;&quot;&quot;Convolving with a single point is the identity, while convolving a point with something flips it.&quot;&quot;&quot;</span>
        <span class="s1">m = random_mask((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span>
        <span class="s1">k = pygame.Mask((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">k.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s1">convolve_mask = m.convolve(k)</span>

        <span class="s1">self.assertIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">convolve_mask)</span>

        <span class="s1">convolve_mask = k.convolve(k.convolve(m))</span>

        <span class="s1">self.assertIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">convolve_mask)</span>

    <span class="s0">def </span><span class="s1">test_convolve__with_output(self):</span>
        <span class="s4">&quot;&quot;&quot;checks that convolution modifies only the correct portion of the output&quot;&quot;&quot;</span>

        <span class="s1">m = random_mask((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">k = pygame.Mask((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">k.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s1">o = pygame.Mask((</span><span class="s3">50</span><span class="s0">, </span><span class="s3">50</span><span class="s1">))</span>
        <span class="s1">test = pygame.Mask((</span><span class="s3">50</span><span class="s0">, </span><span class="s3">50</span><span class="s1">))</span>

        <span class="s1">m.convolve(k</span><span class="s0">, </span><span class="s1">o)</span>
        <span class="s1">test.draw(m</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

        <span class="s1">self.assertIsInstance(o</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">o</span><span class="s0">, </span><span class="s1">test)</span>

        <span class="s1">o.clear()</span>
        <span class="s1">test.clear()</span>

        <span class="s1">m.convolve(other=k</span><span class="s0">, </span><span class="s1">output=o</span><span class="s0">, </span><span class="s1">offset=Vector2(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">test.draw(m</span><span class="s0">, </span><span class="s1">(</span><span class="s3">11</span><span class="s0">, </span><span class="s3">11</span><span class="s1">))</span>

        <span class="s1">self.assertIsInstance(o</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">o</span><span class="s0">, </span><span class="s1">test)</span>

    <span class="s0">def </span><span class="s1">test_convolve__out_of_range(self):</span>
        <span class="s1">full = pygame.Mask((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s5"># Tuple of points (out of range) and the expected count for each.</span>
        <span class="s1">pts_data = (((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((-</span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">pt</span><span class="s0">, </span><span class="s1">expected_count </span><span class="s0">in </span><span class="s1">pts_data:</span>
            <span class="s1">convolve_mask = full.convolve(full</span><span class="s0">, None, </span><span class="s1">pt)</span>

            <span class="s1">self.assertIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertEqual(convolve_mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_convolve(self):</span>
        <span class="s4">&quot;&quot;&quot;Tests the definition of convolution&quot;&quot;&quot;</span>
        <span class="s1">m1 = random_mask((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span>
        <span class="s1">m2 = random_mask((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span>
        <span class="s1">conv = m1.convolve(m2)</span>

        <span class="s1">self.assertIsInstance(conv</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(conv.get_size()[</span><span class="s3">0</span><span class="s1">]):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(conv.get_size()[</span><span class="s3">1</span><span class="s1">]):</span>
                <span class="s1">self.assertEqual(</span>
                    <span class="s1">conv.get_at((i</span><span class="s0">, </span><span class="s1">j)) == </span><span class="s3">0</span><span class="s0">, </span><span class="s1">m1.overlap(m2</span><span class="s0">, </span><span class="s1">(i - </span><span class="s3">99</span><span class="s0">, </span><span class="s1">j - </span><span class="s3">99</span><span class="s1">)) </span><span class="s0">is None</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_draw_component_pattern_box(self</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">inverse=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s5"># Helper method to create/draw a 'box' pattern for testing.</span>
        <span class="s5">#</span>
        <span class="s5"># 111</span>
        <span class="s5"># 101  3x3 example pattern</span>
        <span class="s5"># 111</span>
        <span class="s1">pattern = pygame.mask.Mask((size</span><span class="s0">, </span><span class="s1">size)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">pattern.set_at((size // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">size // </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">inverse:</span>
            <span class="s1">mask.erase(pattern</span><span class="s0">, </span><span class="s1">pos)</span>
            <span class="s1">pattern.invert()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mask.draw(pattern</span><span class="s0">, </span><span class="s1">pos)</span>

        <span class="s0">return </span><span class="s1">pattern</span>

    <span class="s0">def </span><span class="s1">_draw_component_pattern_x(self</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">inverse=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s5"># Helper method to create/draw an 'X' pattern for testing.</span>
        <span class="s5">#</span>
        <span class="s5"># 101</span>
        <span class="s5"># 010  3x3 example pattern</span>
        <span class="s5"># 101</span>
        <span class="s1">pattern = pygame.mask.Mask((size</span><span class="s0">, </span><span class="s1">size))</span>

        <span class="s1">ymax = size - </span><span class="s3">1</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(size):</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(size):</span>
                <span class="s0">if </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[y</span><span class="s0">, </span><span class="s1">ymax - y]:</span>
                    <span class="s1">pattern.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>

        <span class="s0">if </span><span class="s1">inverse:</span>
            <span class="s1">mask.erase(pattern</span><span class="s0">, </span><span class="s1">pos)</span>
            <span class="s1">pattern.invert()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mask.draw(pattern</span><span class="s0">, </span><span class="s1">pos)</span>

        <span class="s0">return </span><span class="s1">pattern</span>

    <span class="s0">def </span><span class="s1">_draw_component_pattern_plus(self</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">inverse=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s5"># Helper method to create/draw a '+' pattern for testing.</span>
        <span class="s5">#</span>
        <span class="s5"># 010</span>
        <span class="s5"># 111  3x3 example pattern</span>
        <span class="s5"># 010</span>
        <span class="s1">pattern = pygame.mask.Mask((size</span><span class="s0">, </span><span class="s1">size))</span>

        <span class="s1">xmid = ymid = size // </span><span class="s3">2</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(size):</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(size):</span>
                <span class="s0">if </span><span class="s1">x == xmid </span><span class="s0">or </span><span class="s1">y == ymid:</span>
                    <span class="s1">pattern.set_at((x</span><span class="s0">, </span><span class="s1">y))</span>

        <span class="s0">if </span><span class="s1">inverse:</span>
            <span class="s1">mask.erase(pattern</span><span class="s0">, </span><span class="s1">pos)</span>
            <span class="s1">pattern.invert()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mask.draw(pattern</span><span class="s0">, </span><span class="s1">pos)</span>

        <span class="s0">return </span><span class="s1">pattern</span>

    <span class="s0">def </span><span class="s1">test_connected_component(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's connected component is correctly calculated.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">41</span><span class="s0">, </span><span class="s3">27</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">original_mask = pygame.mask.Mask(expected_size)</span>
        <span class="s1">patterns = []  </span><span class="s5"># Patterns and offsets.</span>

        <span class="s5"># Draw some connected patterns on the original mask.</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">pattern = self._draw_component_pattern_x(original_mask</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">offset)</span>
        <span class="s1">patterns.append((pattern</span><span class="s0">, </span><span class="s1">offset))</span>

        <span class="s1">size = </span><span class="s3">4</span>
        <span class="s1">offset = (width - size</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">pattern = self._draw_component_pattern_plus(original_mask</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">offset)</span>
        <span class="s1">patterns.append((pattern</span><span class="s0">, </span><span class="s1">offset))</span>

        <span class="s5"># Make this one the largest connected component.</span>
        <span class="s1">offset = (width // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">height // </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">pattern = self._draw_component_pattern_box(original_mask</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s1">offset)</span>
        <span class="s1">patterns.append((pattern</span><span class="s0">, </span><span class="s1">offset))</span>

        <span class="s1">expected_pattern</span><span class="s0">, </span><span class="s1">expected_offset = patterns[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">expected_count = expected_pattern.count()</span>
        <span class="s1">original_count = sum(p.count() </span><span class="s0">for </span><span class="s1">p</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">patterns)</span>

        <span class="s1">mask = original_mask.connected_component()</span>

        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">mask.overlap_area(expected_pattern</span><span class="s0">, </span><span class="s1">expected_offset)</span><span class="s0">, </span><span class="s1">expected_count</span>
        <span class="s1">)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">original_count)</span>
        <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

        <span class="s0">for </span><span class="s1">pattern</span><span class="s0">, </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">patterns:</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">original_mask.overlap_area(pattern</span><span class="s0">, </span><span class="s1">offset)</span><span class="s0">, </span><span class="s1">pattern.count()</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_connected_component__full_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's connected component is correctly calculated 
        when the mask is full. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">23</span><span class="s0">, </span><span class="s3">31</span><span class="s1">)</span>
        <span class="s1">original_mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_count = original_mask.count()</span>

        <span class="s1">mask = original_mask.connected_component()</span>

        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_connected_component__empty_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's connected component is correctly calculated 
        when the mask is empty. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">37</span><span class="s0">, </span><span class="s3">43</span><span class="s1">)</span>
        <span class="s1">original_mask = pygame.mask.Mask(expected_size)</span>
        <span class="s1">original_count = original_mask.count()</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s1">mask = original_mask.connected_component()</span>

        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">original_count)</span>
        <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_connected_component__one_set_bit(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's connected component is correctly calculated 
        when the coordinate's bit is set with a connected component of 1 bit. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">71</span><span class="s0">, </span><span class="s3">67</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">original_mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">xset</span><span class="s0">, </span><span class="s1">yset = width // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">height // </span><span class="s3">2</span>
        <span class="s1">set_pos = (xset</span><span class="s0">, </span><span class="s1">yset)</span>
        <span class="s1">expected_offset = (xset - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">yset - </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s5"># This isolates the bit at set_pos from all the other bits.</span>
        <span class="s1">expected_pattern = self._draw_component_pattern_box(</span>
            <span class="s1">original_mask</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">expected_offset</span><span class="s0">, </span><span class="s1">inverse=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">expected_count = </span><span class="s3">1</span>
        <span class="s1">original_count = original_mask.count()</span>

        <span class="s1">mask = original_mask.connected_component(set_pos)</span>

        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">mask.overlap_area(expected_pattern</span><span class="s0">, </span><span class="s1">expected_offset)</span><span class="s0">, </span><span class="s1">expected_count</span>
        <span class="s1">)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">original_count)</span>
        <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">original_mask.overlap_area(expected_pattern</span><span class="s0">, </span><span class="s1">expected_offset)</span><span class="s0">,</span>
            <span class="s1">expected_count</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_connected_component__multi_set_bits(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's connected component is correctly calculated 
        when the coordinate's bit is set with a connected component of &gt; 1 bit. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">113</span><span class="s0">, </span><span class="s3">67</span><span class="s1">)</span>
        <span class="s1">original_mask = pygame.mask.Mask(expected_size)</span>
        <span class="s1">p_width</span><span class="s0">, </span><span class="s1">p_height = </span><span class="s3">11</span><span class="s0">, </span><span class="s3">13</span>
        <span class="s1">set_pos = xset</span><span class="s0">, </span><span class="s1">yset = </span><span class="s3">11</span><span class="s0">, </span><span class="s3">21</span>
        <span class="s1">expected_offset = (xset - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">yset - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected_pattern = pygame.mask.Mask((p_width</span><span class="s0">, </span><span class="s1">p_height)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s5"># Make an unsymmetrical pattern. All the set bits need to be connected</span>
        <span class="s5"># in the resulting pattern for this to work properly.</span>
        <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">p_height):</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">p_width):</span>
                <span class="s0">if </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[y</span><span class="s0">, </span><span class="s1">y - </span><span class="s3">3</span><span class="s0">, </span><span class="s1">p_width - </span><span class="s3">4</span><span class="s1">]:</span>
                    <span class="s1">expected_pattern.set_at((x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">expected_count = expected_pattern.count()</span>
        <span class="s1">original_mask.draw(expected_pattern</span><span class="s0">, </span><span class="s1">expected_offset)</span>

        <span class="s1">mask = original_mask.connected_component(set_pos)</span>

        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">mask.overlap_area(expected_pattern</span><span class="s0">, </span><span class="s1">expected_offset)</span><span class="s0">, </span><span class="s1">expected_count</span>
        <span class="s1">)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">original_mask.overlap_area(expected_pattern</span><span class="s0">, </span><span class="s1">expected_offset)</span><span class="s0">,</span>
            <span class="s1">expected_count</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_connected_component__unset_bit(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure a mask's connected component is correctly calculated 
        when the coordinate's bit is unset. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">109</span><span class="s0">, </span><span class="s3">101</span>
        <span class="s1">expected_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">original_mask = pygame.mask.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">unset_pos = (width // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">height // </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">original_mask.set_at(unset_pos</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">original_count = original_mask.count()</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s1">mask = original_mask.connected_component(unset_pos)</span>

        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">original_count)</span>
        <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>
        <span class="s1">self.assertEqual(original_mask.get_at(unset_pos)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_connected_component__out_of_bounds(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensure connected_component() checks bounds.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">19</span><span class="s0">, </span><span class="s3">11</span>
        <span class="s1">original_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">original_mask = pygame.mask.Mask(original_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">original_count = original_mask.count()</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">height + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width + </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
                <span class="s1">mask = original_mask.connected_component(pos)</span>

            <span class="s5"># Ensure the original mask is unchanged.</span>
            <span class="s1">self.assertEqual(original_mask.count()</span><span class="s0">, </span><span class="s1">original_count)</span>
            <span class="s1">self.assertEqual(original_mask.get_size()</span><span class="s0">, </span><span class="s1">original_size)</span>

    <span class="s0">def </span><span class="s1">test_connected_components(self):</span>
        <span class="s4">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="s1">m = pygame.Mask((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

        <span class="s1">self.assertListEqual(m.connected_components()</span><span class="s0">, </span><span class="s1">[])</span>

        <span class="s1">comp = m.connected_component()</span>

        <span class="s1">self.assertEqual(m.count()</span><span class="s0">, </span><span class="s1">comp.count())</span>

        <span class="s1">m.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">m.set_at((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">comp = m.connected_component()</span>
        <span class="s1">comps = m.connected_components()</span>
        <span class="s1">comps1 = m.connected_components(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">comps2 = m.connected_components(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">comps3 = m.connected_components(</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(comp.count()</span><span class="s0">, </span><span class="s1">comps[</span><span class="s3">0</span><span class="s1">].count())</span>
        <span class="s1">self.assertEqual(comps1[</span><span class="s3">0</span><span class="s1">].count()</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(comps2[</span><span class="s3">0</span><span class="s1">].count()</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.assertListEqual(comps3</span><span class="s0">, </span><span class="s1">[])</span>

        <span class="s1">m.set_at((</span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">comp = m.connected_component()</span>
        <span class="s1">comp1 = m.connected_component((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">comp2 = m.connected_component((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">comps = m.connected_components()</span>
        <span class="s1">comps1 = m.connected_components(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">comps2 = m.connected_components(minimum=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">comps3 = m.connected_components(</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(comp.count()</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(comp1.count()</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(comp2.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(comps)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(comps1)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(comps2)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">self.assertEqual(len(comps3)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">comps:</span>
            <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>

    <span class="s0">def </span><span class="s1">test_connected_components__negative_min_with_empty_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_components() properly handles negative min values 
        when the mask is empty. 
 
        Negative and zero values for the min parameter (minimum number of bits 
        per connected component) equate to setting it to one. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_comps = []</span>
        <span class="s1">mask_count = </span><span class="s3">0</span>
        <span class="s1">mask_size = (</span><span class="s3">65</span><span class="s0">, </span><span class="s3">13</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size)</span>

        <span class="s1">connected_comps = mask.connected_components(-</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">self.assertListEqual(connected_comps</span><span class="s0">, </span><span class="s1">expected_comps)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">mask_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

    <span class="s0">def </span><span class="s1">test_connected_components__negative_min_with_full_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_components() properly handles negative min values 
        when the mask is full. 
 
        Negative and zero values for the min parameter (minimum number of bits 
        per connected component) equate to setting it to one. 
        &quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">64</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask_count = mask.count()</span>
        <span class="s1">expected_len = </span><span class="s3">1</span>

        <span class="s1">connected_comps = mask.connected_components(-</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(len(connected_comps)</span><span class="s0">, </span><span class="s1">expected_len)</span>
        <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">connected_comps[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">mask_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

    <span class="s0">def </span><span class="s1">test_connected_components__negative_min_with_some_bits_set(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_components() properly handles negative min values 
        when the mask has some bits set. 
 
        Negative and zero values for the min parameter (minimum number of bits 
        per connected component) equate to setting it to one. 
        &quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">64</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size)</span>
        <span class="s1">expected_comps = {}</span>

        <span class="s5"># Set the corners and the center positions. A new expected component</span>
        <span class="s5"># mask is created for each point.</span>
        <span class="s0">for </span><span class="s1">corner </span><span class="s0">in </span><span class="s1">corners(mask):</span>
            <span class="s1">mask.set_at(corner)</span>

            <span class="s1">new_mask = pygame.mask.Mask(mask_size)</span>
            <span class="s1">new_mask.set_at(corner)</span>
            <span class="s1">expected_comps[corner] = new_mask</span>

        <span class="s1">center = (mask_size[</span><span class="s3">0</span><span class="s1">] // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">mask_size[</span><span class="s3">1</span><span class="s1">] // </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask.set_at(center)</span>

        <span class="s1">new_mask = pygame.mask.Mask(mask_size)</span>
        <span class="s1">new_mask.set_at(center)</span>
        <span class="s1">expected_comps[center] = new_mask</span>
        <span class="s1">mask_count = mask.count()</span>

        <span class="s1">connected_comps = mask.connected_components(-</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">self.assertEqual(len(connected_comps)</span><span class="s0">, </span><span class="s1">len(expected_comps))</span>

        <span class="s0">for </span><span class="s1">comp </span><span class="s0">in </span><span class="s1">connected_comps:</span>
            <span class="s5"># Since the masks in the connected component list can be in any</span>
            <span class="s5"># order, loop the expected components to find its match.</span>
            <span class="s1">found = </span><span class="s0">False</span>

            <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">tuple(expected_comps.keys()):</span>
                <span class="s0">if </span><span class="s1">comp.get_at(pt):</span>
                    <span class="s1">found = </span><span class="s0">True</span>
                    <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">comp</span><span class="s0">, </span><span class="s1">expected_comps[pt])</span>
                    <span class="s0">del </span><span class="s1">expected_comps[pt]  </span><span class="s5"># Entry removed so it isn't reused.</span>
                    <span class="s0">break</span>

            <span class="s1">self.assertTrue(found</span><span class="s0">, </span><span class="s2">f&quot;missing component for pt=</span><span class="s0">{</span><span class="s1">pt</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s5"># Ensure the original mask is unchanged.</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">mask_count)</span>
        <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_get_bounding_rects(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_bounding_rects works correctly.&quot;&quot;&quot;</span>
        <span class="s5"># Create masks with different set point groups. Each group of</span>
        <span class="s5"># connected set points will be contained in its own bounding rect.</span>
        <span class="s5"># Diagonal points are considered connected.</span>
        <span class="s1">mask_data = []  </span><span class="s5"># [((size), ((rect1_pts), ...)), ...]</span>

        <span class="s5"># Mask 1:</span>
        <span class="s5">#  |0123456789</span>
        <span class="s5"># -+----------</span>
        <span class="s5"># 0|1100000000</span>
        <span class="s5"># 1|1000000000</span>
        <span class="s5"># 2|0000000000</span>
        <span class="s5"># 3|1001000000</span>
        <span class="s5"># 4|0000000000</span>
        <span class="s5"># 5|0000000000</span>
        <span class="s5"># 6|0000000000</span>
        <span class="s5"># 7|0000000000</span>
        <span class="s5"># 8|0000000000</span>
        <span class="s5"># 9|0000000000</span>
        <span class="s1">mask_data.append(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># size</span>
                <span class="s5"># Points to set for the 3 bounding rects.</span>
                <span class="s1">(((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># rect1  # rect2</span>
            <span class="s1">)</span>
        <span class="s1">)  </span><span class="s5"># rect3</span>

        <span class="s5"># Mask 2:</span>
        <span class="s5">#  |0123</span>
        <span class="s5"># -+----</span>
        <span class="s5"># 0|1100</span>
        <span class="s5"># 1|1111</span>
        <span class="s1">mask_data.append(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># size</span>
                <span class="s5"># Points to set for the 1 bounding rect.</span>
                <span class="s1">(((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s5"># Mask 3:</span>
        <span class="s5">#  |01234</span>
        <span class="s5"># -+-----</span>
        <span class="s5"># 0|00100</span>
        <span class="s5"># 1|01110</span>
        <span class="s5"># 2|00100</span>
        <span class="s1">mask_data.append(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># size</span>
                <span class="s5"># Points to set for the 1 bounding rect.</span>
                <span class="s1">(((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s5"># Mask 4:</span>
        <span class="s5">#  |01234</span>
        <span class="s5"># -+-----</span>
        <span class="s5"># 0|00010</span>
        <span class="s5"># 1|00100</span>
        <span class="s5"># 2|01000</span>
        <span class="s1">mask_data.append(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># size</span>
                <span class="s5"># Points to set for the 1 bounding rect.</span>
                <span class="s1">(((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s5"># Mask 5:</span>
        <span class="s5">#  |01234</span>
        <span class="s5"># -+-----</span>
        <span class="s5"># 0|00011</span>
        <span class="s5"># 1|11111</span>
        <span class="s1">mask_data.append(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># size</span>
                <span class="s5"># Points to set for the 1 bounding rect.</span>
                <span class="s1">(((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s5"># Mask 6:</span>
        <span class="s5">#  |01234</span>
        <span class="s5"># -+-----</span>
        <span class="s5"># 0|10001</span>
        <span class="s5"># 1|00100</span>
        <span class="s5"># 2|10001</span>
        <span class="s1">mask_data.append(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># size</span>
                <span class="s5"># Points to set for the 5 bounding rects.</span>
                <span class="s1">(</span>
                    <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># rect1</span>
                    <span class="s1">((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># rect2</span>
                    <span class="s1">((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># rect3</span>
                    <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># rect4</span>
                    <span class="s1">((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)  </span><span class="s5"># rect5</span>

        <span class="s0">for </span><span class="s1">size</span><span class="s0">, </span><span class="s1">rect_point_tuples </span><span class="s0">in </span><span class="s1">mask_data:</span>
            <span class="s1">rects = []</span>
            <span class="s1">mask = pygame.Mask(size)</span>

            <span class="s0">for </span><span class="s1">rect_points </span><span class="s0">in </span><span class="s1">rect_point_tuples:</span>
                <span class="s1">rects.append(create_bounding_rect(rect_points))</span>
                <span class="s0">for </span><span class="s1">pt </span><span class="s0">in </span><span class="s1">rect_points:</span>
                    <span class="s1">mask.set_at(pt)</span>

            <span class="s1">expected_rects = sorted(rects</span><span class="s0">, </span><span class="s1">key=tuple)</span>

            <span class="s1">rects = mask.get_bounding_rects()</span>

            <span class="s1">self.assertListEqual(</span>
                <span class="s1">sorted(mask.get_bounding_rects()</span><span class="s0">, </span><span class="s1">key=tuple)</span><span class="s0">,</span>
                <span class="s1">expected_rects</span><span class="s0">,</span>
                <span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_to_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures empty and full masks can be drawn onto surfaces.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">3</span>
        <span class="s1">size = (</span><span class="s3">33</span><span class="s0">, </span><span class="s3">65</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">test_fills = ((pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">test_fills:</span>
            <span class="s1">surface.fill(surface_color)</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__create_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures empty and full masks can be drawn onto a created surface.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">size = (</span><span class="s3">33</span><span class="s0">, </span><span class="s3">65</span><span class="s1">)</span>
        <span class="s1">test_fills = ((pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">test_fills:</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s0">for </span><span class="s1">use_arg </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s0">if </span><span class="s1">use_arg:</span>
                    <span class="s1">to_surface = mask.to_surface(</span><span class="s0">None</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">to_surface = mask.to_surface()</span>

                <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
                <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                    <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
                <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
                <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_param(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts a surface arg/kwarg.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">4</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;surface&quot;</span><span class="s1">: surface}</span>

        <span class="s0">for </span><span class="s1">use_kwargs </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">surface.fill(surface_color)</span>

            <span class="s0">if </span><span class="s1">use_kwargs:</span>
                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">to_surface = mask.to_surface(kwargs[</span><span class="s2">&quot;surface&quot;</span><span class="s1">])</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_param(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts a setsurface arg/kwarg.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">expected_flag</span><span class="s0">, </span><span class="s1">expected_depth)</span>
        <span class="s1">setsurface.fill(expected_color)</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;setsurface&quot;</span><span class="s1">: setsurface}</span>

        <span class="s0">for </span><span class="s1">use_kwargs </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">use_kwargs:</span>
                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">to_surface = mask.to_surface(</span><span class="s0">None, </span><span class="s1">kwargs[</span><span class="s2">&quot;setsurface&quot;</span><span class="s1">])</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>

            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
            <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_param(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts a unsetsurface arg/kwarg.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">expected_flag</span><span class="s0">, </span><span class="s1">expected_depth)</span>
        <span class="s1">unsetsurface.fill(expected_color)</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: unsetsurface}</span>

        <span class="s0">for </span><span class="s1">use_kwargs </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">use_kwargs:</span>
                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">to_surface = mask.to_surface(</span><span class="s0">None, None, </span><span class="s1">kwargs[</span><span class="s2">&quot;unsetsurface&quot;</span><span class="s1">])</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
            <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setcolor_param(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts a setcolor arg/kwarg.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;setcolor&quot;</span><span class="s1">: expected_color}</span>

        <span class="s0">for </span><span class="s1">use_kwargs </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">use_kwargs:</span>
                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">to_surface = mask.to_surface(</span><span class="s0">None, None, None, </span><span class="s1">kwargs[</span><span class="s2">&quot;setcolor&quot;</span><span class="s1">])</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
            <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setcolor_default(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the default setcolor is correct.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">to_surface = mask.to_surface(</span>
            <span class="s1">surface=</span><span class="s0">None, </span><span class="s1">setsurface=</span><span class="s0">None, </span><span class="s1">unsetsurface=</span><span class="s0">None, </span><span class="s1">unsetcolor=</span><span class="s0">None</span>
        <span class="s1">)</span>

        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetcolor_param(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts a unsetcolor arg/kwarg.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s1">: expected_color}</span>

        <span class="s0">for </span><span class="s1">use_kwargs </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">use_kwargs:</span>
                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">to_surface = mask.to_surface(</span>
                    <span class="s0">None, None, None, None, </span><span class="s1">kwargs[</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
            <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetcolor_default(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the default unsetcolor is correct.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>

        <span class="s1">to_surface = mask.to_surface(</span>
            <span class="s1">surface=</span><span class="s0">None, </span><span class="s1">setsurface=</span><span class="s0">None, </span><span class="s1">unsetsurface=</span><span class="s0">None, </span><span class="s1">setcolor=</span><span class="s0">None</span>
        <span class="s1">)</span>

        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__dest_param(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts a dest arg/kwarg.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">default_surface_color = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">dest = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;dest&quot;</span><span class="s1">: dest}</span>

        <span class="s0">for </span><span class="s1">use_kwargs </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">use_kwargs:</span>
                <span class="s1">expected_color = default_unsetcolor</span>

                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = default_surface_color</span>

                <span class="s1">to_surface = mask.to_surface(</span>
                    <span class="s0">None, None, None, None, None, </span><span class="s1">kwargs[</span><span class="s2">&quot;dest&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
            <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__dest_default(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the default dest is correct.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s1">mask_size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask_rect = mask.get_rect()</span>

        <span class="s5"># Make the surface bigger than the mask.</span>
        <span class="s1">surf_size = (mask_size[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">2</span><span class="s0">, </span><span class="s1">mask_size[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(surf_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">to_surface = mask.to_surface(</span>
            <span class="s1">surface</span><span class="s0">, </span><span class="s1">setsurface=</span><span class="s0">None, </span><span class="s1">unsetsurface=</span><span class="s0">None, </span><span class="s1">unsetcolor=</span><span class="s0">None</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">surf_size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
        <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__area_param(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts an area arg/kwarg.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">default_surface_color = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;area&quot;</span><span class="s1">: mask.get_rect()}</span>

        <span class="s0">for </span><span class="s1">use_kwargs </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">use_kwargs:</span>
                <span class="s1">expected_color = default_unsetcolor</span>

                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">expected_color = default_surface_color</span>

                <span class="s1">to_surface = mask.to_surface(</span>
                    <span class="s0">None, None, None, None, None, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">kwargs[</span><span class="s2">&quot;area&quot;</span><span class="s1">]</span>
                <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
            <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
            <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__area_default(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the default area is correct.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s1">mask_size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask_rect = mask.get_rect()</span>

        <span class="s5"># Make the surface bigger than the mask. The default area is the full</span>
        <span class="s5"># area of the mask.</span>
        <span class="s1">surf_size = (mask_size[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">2</span><span class="s0">, </span><span class="s1">mask_size[</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(surf_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface.fill(surface_color)</span>

        <span class="s1">to_surface = mask.to_surface(</span>
            <span class="s1">surface</span><span class="s0">, </span><span class="s1">setsurface=</span><span class="s0">None, </span><span class="s1">unsetsurface=</span><span class="s0">None, </span><span class="s1">unsetcolor=</span><span class="s0">None</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">surf_size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
        <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts the correct kwargs.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">setsurface.fill(expected_color)</span>

        <span class="s1">test_data = (</span>
            <span class="s1">(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># None entry allows loop to test all kwargs on first pass.</span>
            <span class="s1">(</span><span class="s2">&quot;dest&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;setcolor&quot;</span><span class="s0">, </span><span class="s1">expected_color)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;unsetsurface&quot;</span><span class="s0">, </span><span class="s1">surface.copy())</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;setsurface&quot;</span><span class="s0">, </span><span class="s1">setsurface)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s1">surface)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">kwargs = dict(test_data)</span>

        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">test_data:</span>
            <span class="s1">kwargs.pop(name)</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>

            <span class="s1">to_surface = mask.to_surface(**kwargs)</span>

            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__kwargs_create_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts the correct kwargs 
        when creating a surface. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">unsetsurface = setsurface.copy()</span>
        <span class="s1">unsetsurface.fill(expected_color)</span>

        <span class="s1">test_data = (</span>
            <span class="s1">(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># None entry allows loop to test all kwargs on first pass.</span>
            <span class="s1">(</span><span class="s2">&quot;dest&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s0">, </span><span class="s1">expected_color)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;setcolor&quot;</span><span class="s0">, </span><span class="s1">pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;unsetsurface&quot;</span><span class="s0">, </span><span class="s1">unsetsurface)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;setsurface&quot;</span><span class="s0">, </span><span class="s1">setsurface)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">kwargs = dict(test_data)</span>

        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">test_data:</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s1">to_surface = mask.to_surface(**kwargs)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__kwargs_order_independent(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface kwargs are not order dependent.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size)</span>

        <span class="s1">to_surface = mask.to_surface(</span>
            <span class="s1">dest=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">setcolor=expected_color</span><span class="s0">,</span>
            <span class="s1">unsetcolor=</span><span class="s0">None,</span>
            <span class="s1">surface=surface</span><span class="s0">,</span>
            <span class="s1">unsetsurface=pygame.Surface(size)</span><span class="s0">,</span>
            <span class="s1">setsurface=</span><span class="s0">None,</span>
        <span class="s1">)</span>

        <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__args_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">invalid_surf = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">invalid_color = pygame.Surface(size)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s5"># Invalid dest.</span>
            <span class="s1">mask.to_surface(</span><span class="s0">None, None, None, None, None, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s5"># Invalid unsetcolor.</span>
            <span class="s1">mask.to_surface(</span><span class="s0">None, None, None, None, </span><span class="s1">invalid_color)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s5"># Invalid setcolor.</span>
            <span class="s1">mask.to_surface(</span><span class="s0">None, None, None, </span><span class="s1">invalid_color</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s5"># Invalid unsetsurface.</span>
            <span class="s1">mask.to_surface(</span><span class="s0">None, None, </span><span class="s1">invalid_surf</span><span class="s0">, None, None</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s5"># Invalid setsurface.</span>
            <span class="s1">mask.to_surface(</span><span class="s0">None, </span><span class="s1">invalid_surf</span><span class="s0">, None, None, None</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s5"># Invalid surface.</span>
            <span class="s1">mask.to_surface(invalid_surf</span><span class="s0">, None, None, None, None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__kwargs_invalid_types(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface detects invalid kwarg types.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>

        <span class="s1">valid_kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: pygame.Surface(size)</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: pygame.Surface(size)</span><span class="s0">,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: pygame.Surface(size)</span><span class="s0">,</span>
            <span class="s2">&quot;setcolor&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;unsetcolor&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;dest&quot;</span><span class="s1">: (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">invalid_kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: ((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;setcolor&quot;</span><span class="s1">: pygame.Mask((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;unsetcolor&quot;</span><span class="s1">: pygame.Surface((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s2">&quot;dest&quot;</span><span class="s1">: (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">kwarg_order = (</span>
            <span class="s2">&quot;surface&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;setcolor&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;unsetcolor&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;dest&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">kwarg </span><span class="s0">in </span><span class="s1">kwarg_order:</span>
            <span class="s1">kwargs = dict(valid_kwargs)</span>
            <span class="s1">kwargs[kwarg] = invalid_kwargs[kwarg]</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">mask.to_surface(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__kwargs_invalid_name(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface detects invalid kwarg names.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">kwargs = {</span><span class="s2">&quot;setcolour&quot;</span><span class="s1">: pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)}</span>

        <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
            <span class="s1">mask.to_surface(**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__args_and_kwargs(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface accepts a combination of args/kwargs&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">setcolor = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetcolor = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">unsetsurface = surface.copy()</span>

        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">expected_color = setsurface_color</span>

        <span class="s1">test_data = (</span>
            <span class="s1">(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># None entry allows loop to test all kwargs on first pass.</span>
            <span class="s1">(</span><span class="s2">&quot;surface&quot;</span><span class="s0">, </span><span class="s1">surface)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;setsurface&quot;</span><span class="s0">, </span><span class="s1">setsurface)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;unsetsurface&quot;</span><span class="s0">, </span><span class="s1">unsetsurface)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;setcolor&quot;</span><span class="s0">, </span><span class="s1">setcolor)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s0">, </span><span class="s1">unsetcolor)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;dest&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">args = []</span>
        <span class="s1">kwargs = dict(test_data)</span>

        <span class="s5"># Loop gradually moves the kwargs to args.</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">test_data:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">args.append(value)</span>
            <span class="s1">kwargs.pop(name)</span>

            <span class="s1">surface.fill(surface_color)</span>

            <span class="s1">to_surface = mask.to_surface(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__valid_setcolor_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles valid setcolor formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">test_colors = (</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(expected_color)</span><span class="s0">,</span>
            <span class="s1">expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;green&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;#00FF00FF&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;0x00FF00FF&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">setcolor </span><span class="s0">in </span><span class="s1">test_colors:</span>
            <span class="s1">to_surface = mask.to_surface(setcolor=setcolor)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__valid_unsetcolor_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles valid unsetcolor formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">test_colors = (</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">surface.map_rgb(expected_color)</span><span class="s0">,</span>
            <span class="s1">expected_color</span><span class="s0">,</span>
            <span class="s2">&quot;green&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;#00FF00FF&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;0x00FF00FF&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">unsetcolor </span><span class="s0">in </span><span class="s1">test_colors:</span>
            <span class="s1">to_surface = mask.to_surface(unsetcolor=unsetcolor)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__invalid_setcolor_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles invalid setcolor formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">setcolor </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;green color&quot;</span><span class="s0">, </span><span class="s2">&quot;#00FF00FF0&quot;</span><span class="s0">, </span><span class="s2">&quot;0x00FF00FF0&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                <span class="s1">mask.to_surface(setcolor=setcolor)</span>

        <span class="s0">for </span><span class="s1">setcolor </span><span class="s0">in </span><span class="s1">(pygame.Surface((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">pygame.Mask((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">mask.to_surface(setcolor=setcolor)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__invalid_unsetcolor_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles invalid unsetcolor formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">unsetcolor </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;green color&quot;</span><span class="s0">, </span><span class="s2">&quot;#00FF00FF0&quot;</span><span class="s0">, </span><span class="s2">&quot;0x00FF00FF0&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                <span class="s1">mask.to_surface(unsetcolor=unsetcolor)</span>

        <span class="s0">for </span><span class="s1">unsetcolor </span><span class="s0">in </span><span class="s1">(pygame.Surface((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">pygame.Mask((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">mask.to_surface(unsetcolor=unsetcolor)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__valid_dest_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles valid dest formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">dests = (</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">Vector2(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">dests:</span>
            <span class="s1">to_surface = mask.to_surface(dest=dest)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__invalid_dest_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles invalid dest formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">invalid_dests = (</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># Incorrect size.</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># Incorrect size.</span>
            <span class="s1">{</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">}</span><span class="s0">,  </span><span class="s5"># Incorrect type.</span>
            <span class="s1">{</span><span class="s3">0</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}</span><span class="s0">,  </span><span class="s5"># Incorrect type.</span>
            <span class="s1">Rect</span><span class="s0">,</span>
        <span class="s1">)  </span><span class="s5"># Incorrect type.</span>

        <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">invalid_dests:</span>
            <span class="s0">with </span><span class="s1">self.assertRaises(TypeError):</span>
                <span class="s1">mask.to_surface(dest=dest)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__negative_sized_dest_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface correctly handles negative sized dest rects.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">dests = (</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">10</span><span class="s0">, </span><span class="s1">-</span><span class="s3">10</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">dests:</span>
            <span class="s1">to_surface = mask.to_surface(dest=dest)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__zero_sized_dest_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface correctly handles zero sized dest rects.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">dests = (</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">dests:</span>
            <span class="s1">to_surface = mask.to_surface(dest=dest)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__valid_area_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles valid area formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">area_pos = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">area_size = (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">areas = (</span>
            <span class="s1">(area_pos[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">area_pos[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">area_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">area_size[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">(area_pos</span><span class="s0">, </span><span class="s1">area_size)</span><span class="s0">,</span>
            <span class="s1">(area_pos</span><span class="s0">, </span><span class="s1">list(area_size))</span><span class="s0">,</span>
            <span class="s1">(list(area_pos)</span><span class="s0">, </span><span class="s1">area_size)</span><span class="s0">,</span>
            <span class="s1">(list(area_pos)</span><span class="s0">, </span><span class="s1">list(area_size))</span><span class="s0">,</span>
            <span class="s1">[area_pos[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">area_pos[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">area_size[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">area_size[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">[area_pos</span><span class="s0">, </span><span class="s1">area_size]</span><span class="s0">,</span>
            <span class="s1">[area_pos</span><span class="s0">, </span><span class="s1">list(area_size)]</span><span class="s0">,</span>
            <span class="s1">[list(area_pos)</span><span class="s0">, </span><span class="s1">area_size]</span><span class="s0">,</span>
            <span class="s1">[list(area_pos)</span><span class="s0">, </span><span class="s1">list(area_size)]</span><span class="s0">,</span>
            <span class="s1">pygame.Rect(area_pos</span><span class="s0">, </span><span class="s1">area_size)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">area </span><span class="s0">in </span><span class="s1">areas:</span>
            <span class="s1">surface.fill(surface_color)</span>
            <span class="s1">area_rect = pygame.Rect(area)</span>

            <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">area=area)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">area_rect)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">area_rect)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__invalid_area_formats(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface handles invalid area formats correctly.&quot;&quot;&quot;</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">invalid_areas = (</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># Incorrect size.</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># Incorrect size.</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># Incorrect size.</span>
            <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># Incorrect size.</span>
            <span class="s1">((</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># Incorrect size.</span>
            <span class="s1">{</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">}</span><span class="s0">,  </span><span class="s5"># Incorrect type.</span>
            <span class="s1">{</span><span class="s3">0</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span><span class="s0">,  </span><span class="s5"># Incorrect type.</span>
            <span class="s1">Rect</span><span class="s0">,  </span><span class="s5"># Incorrect type.</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">area </span><span class="s0">in </span><span class="s1">invalid_areas:</span>
            <span class="s0">with </span><span class="s1">self.assertRaisesRegex(TypeError</span><span class="s0">, </span><span class="s2">&quot;invalid area argument&quot;</span><span class="s1">):</span>
                <span class="s1">unused_to_surface = mask.to_surface(area=area)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__negative_sized_area_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface correctly handles negative sized area rects.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">mask.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s5"># These rects should cause position (0, 0) of the mask to be drawn.</span>
        <span class="s1">areas = (</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">area </span><span class="s0">in </span><span class="s1">areas:</span>
            <span class="s1">surface.fill(surface_color)</span>

            <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">area=area)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">area)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">area)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__zero_sized_area_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface correctly handles zero sized area rects.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s5"># Zero sized rect areas should cause none of the mask to be drawn.</span>
        <span class="s1">areas = (</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">area </span><span class="s0">in </span><span class="s1">areas:</span>
            <span class="s1">surface.fill(expected_color)</span>

            <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">area=area)</span>

            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__default_surface_with_param_combinations(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface works with a default surface value 
        and combinations of other parameters. 
 
        This tests many different parameter combinations with full and empty 
        masks. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">dest = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">default_surface_color = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">setcolor = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetcolor = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">expected_flag</span><span class="s0">, </span><span class="s1">expected_depth)</span>
        <span class="s1">unsetsurface = setsurface.copy()</span>

        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;setcolor&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;unsetcolor&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;dest&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s5"># Test different combinations of parameters.</span>
            <span class="s0">for </span><span class="s1">setsurface_param </span><span class="s0">in </span><span class="s1">(setsurface</span><span class="s0">, None</span><span class="s1">):</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;setsurface&quot;</span><span class="s1">] = setsurface_param</span>

                <span class="s0">for </span><span class="s1">unsetsurface_param </span><span class="s0">in </span><span class="s1">(unsetsurface</span><span class="s0">, None</span><span class="s1">):</span>
                    <span class="s1">kwargs[</span><span class="s2">&quot;unsetsurface&quot;</span><span class="s1">] = unsetsurface_param</span>

                    <span class="s0">for </span><span class="s1">setcolor_param </span><span class="s0">in </span><span class="s1">(setcolor</span><span class="s0">, None</span><span class="s1">):</span>
                        <span class="s1">kwargs[</span><span class="s2">&quot;setcolor&quot;</span><span class="s1">] = setcolor_param</span>

                        <span class="s0">for </span><span class="s1">unsetcolor_param </span><span class="s0">in </span><span class="s1">(unsetcolor</span><span class="s0">, None</span><span class="s1">):</span>
                            <span class="s1">kwargs[</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s1">] = unsetcolor_param</span>

                            <span class="s0">for </span><span class="s1">dest_param </span><span class="s0">in </span><span class="s1">(dest</span><span class="s0">, None</span><span class="s1">):</span>
                                <span class="s0">if </span><span class="s1">dest_param </span><span class="s0">is None</span><span class="s1">:</span>
                                    <span class="s1">kwargs.pop(</span><span class="s2">&quot;dest&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                                <span class="s0">else</span><span class="s1">:</span>
                                    <span class="s1">kwargs[</span><span class="s2">&quot;dest&quot;</span><span class="s1">] = dest_param</span>

                                <span class="s0">if </span><span class="s1">fill:</span>
                                    <span class="s0">if </span><span class="s1">setsurface_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = setsurface_color</span>
                                    <span class="s0">elif </span><span class="s1">setcolor_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = setcolor</span>
                                    <span class="s0">else</span><span class="s1">:</span>
                                        <span class="s1">expected_color = default_surface_color</span>
                                <span class="s0">else</span><span class="s1">:</span>
                                    <span class="s0">if </span><span class="s1">unsetsurface_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = unsetsurface_color</span>
                                    <span class="s0">elif </span><span class="s1">unsetcolor_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = unsetcolor</span>
                                    <span class="s0">else</span><span class="s1">:</span>
                                        <span class="s1">expected_color = default_surface_color</span>

                                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>

                                <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
                                <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                                    <span class="s1">self.assertEqual(</span>
                                        <span class="s1">sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count</span>
                                    <span class="s1">)</span>
                                <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
                                <span class="s1">self.assertEqual(</span>
                                    <span class="s1">to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth</span>
                                <span class="s1">)</span>
                                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_with_param_combinations(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface works with a surface value 
        and combinations of other parameters. 
 
        This tests many different parameter combinations with full and empty 
        masks. 
        &quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">4</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">dest = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;yellow&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">setcolor = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetcolor = pygame.Color(</span><span class="s2">&quot;cyan&quot;</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">expected_flag</span><span class="s0">, </span><span class="s1">expected_depth)</span>
        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">unsetsurface = surface.copy()</span>

        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;setcolor&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;unsetcolor&quot;</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s2">&quot;dest&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s5"># Test different combinations of parameters.</span>
            <span class="s0">for </span><span class="s1">setsurface_param </span><span class="s0">in </span><span class="s1">(setsurface</span><span class="s0">, None</span><span class="s1">):</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;setsurface&quot;</span><span class="s1">] = setsurface_param</span>

                <span class="s0">for </span><span class="s1">unsetsurface_param </span><span class="s0">in </span><span class="s1">(unsetsurface</span><span class="s0">, None</span><span class="s1">):</span>
                    <span class="s1">kwargs[</span><span class="s2">&quot;unsetsurface&quot;</span><span class="s1">] = unsetsurface_param</span>

                    <span class="s0">for </span><span class="s1">setcolor_param </span><span class="s0">in </span><span class="s1">(setcolor</span><span class="s0">, None</span><span class="s1">):</span>
                        <span class="s1">kwargs[</span><span class="s2">&quot;setcolor&quot;</span><span class="s1">] = setcolor_param</span>

                        <span class="s0">for </span><span class="s1">unsetcolor_param </span><span class="s0">in </span><span class="s1">(unsetcolor</span><span class="s0">, None</span><span class="s1">):</span>
                            <span class="s1">kwargs[</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s1">] = unsetcolor_param</span>
                            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>

                            <span class="s0">for </span><span class="s1">dest_param </span><span class="s0">in </span><span class="s1">(dest</span><span class="s0">, None</span><span class="s1">):</span>
                                <span class="s0">if </span><span class="s1">dest_param </span><span class="s0">is None</span><span class="s1">:</span>
                                    <span class="s1">kwargs.pop(</span><span class="s2">&quot;dest&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                                <span class="s0">else</span><span class="s1">:</span>
                                    <span class="s1">kwargs[</span><span class="s2">&quot;dest&quot;</span><span class="s1">] = dest_param</span>

                                <span class="s0">if </span><span class="s1">fill:</span>
                                    <span class="s0">if </span><span class="s1">setsurface_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = setsurface_color</span>
                                    <span class="s0">elif </span><span class="s1">setcolor_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = setcolor</span>
                                    <span class="s0">else</span><span class="s1">:</span>
                                        <span class="s1">expected_color = surface_color</span>
                                <span class="s0">else</span><span class="s1">:</span>
                                    <span class="s0">if </span><span class="s1">unsetsurface_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = unsetsurface_color</span>
                                    <span class="s0">elif </span><span class="s1">unsetcolor_param </span><span class="s0">is not None</span><span class="s1">:</span>
                                        <span class="s1">expected_color = unsetcolor</span>
                                    <span class="s0">else</span><span class="s1">:</span>
                                        <span class="s1">expected_color = surface_color</span>

                                <span class="s1">to_surface = mask.to_surface(**kwargs)</span>

                                <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                                <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
                                    <span class="s1">self.assertEqual(</span>
                                        <span class="s1">sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count</span>
                                    <span class="s1">)</span>
                                <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
                                <span class="s1">self.assertEqual(</span>
                                    <span class="s1">to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth</span>
                                <span class="s1">)</span>
                                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__set_and_unset_bits(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that to_surface works correctly with with set/unset bits 
        when using the defaults for setcolor and unsetcolor. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">mask_rect = mask.get_rect()</span>

        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s5"># Create a checkerboard pattern of set/unset bits.</span>
        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(x &amp; </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)):</span>
            <span class="s1">mask.set_at(pos)</span>

        <span class="s5"># Test different dest values.</span>
        <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">mask_rect.topleft = dest</span>
            <span class="s1">surface.fill(surface_color)</span>

            <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">dest=dest)</span>

            <span class="s1">to_surface.lock()  </span><span class="s5"># Lock for possible speed up.</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height)):</span>
                <span class="s1">mask_pos = (pos[</span><span class="s3">0</span><span class="s1">] - dest[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos[</span><span class="s3">1</span><span class="s1">] - dest[</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s0">if not </span><span class="s1">mask_rect.collidepoint(pos):</span>
                    <span class="s1">expected_color = surface_color</span>
                <span class="s0">elif </span><span class="s1">mask.get_at(mask_pos):</span>
                    <span class="s1">expected_color = default_setcolor</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">expected_color = default_unsetcolor</span>

                <span class="s1">self.assertEqual(to_surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">(dest</span><span class="s0">, </span><span class="s1">pos))</span>
            <span class="s1">to_surface.unlock()</span>

    <span class="s0">def </span><span class="s1">test_to_surface__set_and_unset_bits_with_setsurface_unsetsurface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that to_surface works correctly with with set/unset bits 
        when using setsurface and unsetsurface. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>
        <span class="s1">mask_rect = mask.get_rect()</span>

        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s1">unsetsurface = surface.copy()</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s5"># Create a checkerboard pattern of set/unset bits.</span>
        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(x &amp; </span><span class="s3">1</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)):</span>
            <span class="s1">mask.set_at(pos)</span>

        <span class="s5"># Test different dest values.</span>
        <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
            <span class="s1">mask_rect.topleft = dest</span>

            <span class="s5"># Tests the color parameters set to None and also as their</span>
            <span class="s5"># default values. Should have no effect as they are not being</span>
            <span class="s5"># used, but this exercises different to_surface() code.</span>
            <span class="s0">for </span><span class="s1">disable_color_params </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>

                <span class="s0">if </span><span class="s1">disable_color_params:</span>
                    <span class="s1">to_surface = mask.to_surface(</span>
                        <span class="s1">surface</span><span class="s0">,</span>
                        <span class="s1">dest=dest</span><span class="s0">,</span>
                        <span class="s1">setsurface=setsurface</span><span class="s0">,</span>
                        <span class="s1">unsetsurface=unsetsurface</span><span class="s0">,</span>
                        <span class="s1">setcolor=</span><span class="s0">None,</span>
                        <span class="s1">unsetcolor=</span><span class="s0">None,</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">to_surface = mask.to_surface(</span>
                        <span class="s1">surface</span><span class="s0">,</span>
                        <span class="s1">dest=dest</span><span class="s0">,</span>
                        <span class="s1">setsurface=setsurface</span><span class="s0">,</span>
                        <span class="s1">unsetsurface=unsetsurface</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s1">to_surface.lock()  </span><span class="s5"># Lock for possible speed up.</span>

                <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height)):</span>
                    <span class="s1">mask_pos = (pos[</span><span class="s3">0</span><span class="s1">] - dest[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos[</span><span class="s3">1</span><span class="s1">] - dest[</span><span class="s3">1</span><span class="s1">])</span>

                    <span class="s0">if not </span><span class="s1">mask_rect.collidepoint(pos):</span>
                        <span class="s1">expected_color = surface_color</span>
                    <span class="s0">elif </span><span class="s1">mask.get_at(mask_pos):</span>
                        <span class="s1">expected_color = setsurface_color</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_color = unsetsurface_color</span>

                    <span class="s1">self.assertEqual(to_surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>
                <span class="s1">to_surface.unlock()</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_narrower_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces narrower than the mask work correctly. 
 
        For this test the surface's width is less than the mask's width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">narrow_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(narrow_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">narrow_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_narrower_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces narrower than the mask work correctly. 
 
        For this test the setsurface's width is less than the mask's width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">narrow_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(narrow_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">setsurface_color</span><span class="s0">, </span><span class="s1">setsurface_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor</span><span class="s0">, </span><span class="s1">setsurface_rect</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_narrower_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces narrower than the mask work correctly. 
 
        For this test the unsetsurface's width is less than the mask's width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">narrow_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(narrow_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">unsetsurface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_narrower_than_mask_and_colors_none(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces narrower than the mask work correctly 
        when setcolor and unsetcolor are set to None. 
 
        For this test the setsurface's width is less than the mask's width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_surface_color = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">narrow_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(narrow_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(</span>
                <span class="s1">setsurface=setsurface</span><span class="s0">, </span><span class="s1">setcolor=</span><span class="s0">None, </span><span class="s1">unsetcolor=</span><span class="s0">None</span>
            <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">setsurface_color</span><span class="s0">, </span><span class="s1">setsurface_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color</span><span class="s0">, </span><span class="s1">setsurface_rect</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_narrower_than_mask_and_colors_none(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces narrower than the mask work correctly 
        when setcolor and unsetcolor are set to None. 
 
        For this test the unsetsurface's width is less than the mask's width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_surface_color = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">narrow_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(narrow_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(</span>
                <span class="s1">unsetsurface=unsetsurface</span><span class="s0">, </span><span class="s1">setcolor=</span><span class="s0">None, </span><span class="s1">unsetcolor=</span><span class="s0">None</span>
            <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">unsetsurface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_wider_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces wider than the mask work correctly. 
 
        For this test the surface's width is greater than the mask's width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>
        <span class="s1">wide_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(wide_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">wide_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_wider_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces wider than the mask work correctly. 
 
        For this test the setsurface's width is greater than the mask's width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>
        <span class="s1">wide_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(wide_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_wider_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces wider than the mask work correctly. 
 
        For this test the unsetsurface's width is greater than the mask's 
        width. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>
        <span class="s1">wide_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(wide_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces shorter than the mask work correctly. 
 
        For this test the surface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">short_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(short_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">short_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces shorter than the mask work correctly. 
 
        For this test the setsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">short_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">setsurface_color</span><span class="s0">, </span><span class="s1">setsurface_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor</span><span class="s0">, </span><span class="s1">setsurface_rect</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces shorter than the mask work correctly. 
 
        For this test the unsetsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">short_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">unsetsurface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_shorter_than_mask_and_colors_none(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces shorter than the mask work correctly 
        when setcolor and unsetcolor are set to None. 
 
        For this test the setsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_surface_color = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">short_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(</span>
                <span class="s1">setsurface=setsurface</span><span class="s0">, </span><span class="s1">setcolor=</span><span class="s0">None, </span><span class="s1">unsetcolor=</span><span class="s0">None</span>
            <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">setsurface_color</span><span class="s0">, </span><span class="s1">setsurface_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color</span><span class="s0">, </span><span class="s1">setsurface_rect</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_shorter_than_mask_and_colors_none(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces shorter than the mask work correctly 
        when setcolor and unsetcolor are set to None. 
 
        For this test the unsetsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_surface_color = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">short_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(</span>
                <span class="s1">unsetsurface=unsetsurface</span><span class="s0">, </span><span class="s1">setcolor=</span><span class="s0">None, </span><span class="s1">unsetcolor=</span><span class="s0">None</span>
            <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">unsetsurface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_surface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces taller than the mask work correctly. 
 
        For this test the surface's height is greater than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">tall_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(tall_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">tall_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces taller than the mask work correctly. 
 
        For this test the setsurface's height is greater than the mask's 
        height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">tall_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(tall_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces taller than the mask work correctly. 
 
        For this test the unsetsurface's height is greater than the mask's 
        height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">tall_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(tall_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_wider_and_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces wider and taller than the mask work correctly. 
 
        For this test the surface's width is greater than the mask's width and 
        the surface's height is greater than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">wide_tall_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(wide_tall_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">wide_tall_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_wider_and_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces wider and taller than the mask work 
        correctly. 
 
        For this test the setsurface's width is greater than the mask's width 
        and the setsurface's height is greater than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">wide_tall_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(wide_tall_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_wider_and_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces wider and taller than the mask work 
        correctly. 
 
        For this test the unsetsurface's width is greater than the mask's width 
        and the unsetsurface's height is greater than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">wide_tall_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(wide_tall_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_wider_and_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces wider and shorter than the mask work 
        correctly. 
 
        For this test the surface's width is greater than the mask's width and 
        the surface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">wide_short_size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(wide_short_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">wide_short_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_wider_and_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces wider and shorter than the mask work 
        correctly. 
 
        For this test the setsurface's width is greater than the mask's width 
        and the setsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">wide_short_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(wide_short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">setsurface_color</span><span class="s0">, </span><span class="s1">setsurface_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor</span><span class="s0">, </span><span class="s1">setsurface_rect</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_wider_and_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces wider and shorter than the mask work 
        correctly. 
 
        For this test the unsetsurface's width is greater than the mask's width 
        and the unsetsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">wide_short_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(wide_short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">unsetsurface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_narrower_and_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces narrower and taller than the mask work 
        correctly. 
 
        For this test the surface's width is less than the mask's width and 
        the surface's height is greater than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">narrow_tall_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(narrow_tall_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">narrow_tall_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_narrower_and_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces narrower and taller than the mask work 
        correctly. 
 
        For this test the setsurface's width is less than the mask's width 
        and the setsurface's height is greater than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">narrow_tall_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(narrow_tall_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">setsurface_color</span><span class="s0">, </span><span class="s1">setsurface_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor</span><span class="s0">, </span><span class="s1">setsurface_rect</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_narrower_and_taller_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces narrower and taller than the mask work 
        correctly. 
 
        For this test the unsetsurface's width is less than the mask's width 
        and the unsetsurface's height is greater than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">narrow_tall_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(narrow_tall_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">unsetsurface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_narrower_and_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that surfaces narrower and shorter than the mask work 
        correctly. 
 
        For this test the surface's width is less than the mask's width and 
        the surface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">18</span><span class="s1">)</span>
        <span class="s1">narrow_short_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(narrow_short_size)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(surface)</span>

            <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">narrow_short_size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
            <span class="s1">assertSurfaceFilledIgnoreArea(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_narrower_and_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that setsurfaces narrower and shorter than the mask work 
        correctly. 
 
        For this test the setsurface's width is less than the mask's width 
        and the setsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">18</span><span class="s1">)</span>
        <span class="s1">narrow_short_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">setsurface = pygame.Surface(narrow_short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">setsurface_color</span><span class="s0">, </span><span class="s1">setsurface_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor</span><span class="s0">, </span><span class="s1">setsurface_rect</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_narrower_and_shorter_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that unsetsurfaces narrower and shorter than the mask work 
        correctly. 
 
        For this test the unsetsurface's width is less than the mask's width 
        and the unsetsurface's height is less than the mask's height. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">18</span><span class="s1">)</span>
        <span class="s1">narrow_short_size = (</span><span class="s3">6</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

        <span class="s1">unsetsurface = pygame.Surface(narrow_short_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

            <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

            <span class="s5"># Different checks depending on if the mask was filled or not.</span>
            <span class="s0">if </span><span class="s1">fill:</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_setcolor)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assertSurfaceFilled(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">unsetsurface_color</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">default_unsetcolor</span><span class="s0">, </span><span class="s1">unsetsurface_rect</span>
                <span class="s1">)</span>

    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_to_surface__all_surfaces_different_sizes_than_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures that all the surface parameters can be of different sizes.&quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s1">mask_size = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>
        <span class="s1">surface_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">14</span><span class="s1">)</span>
        <span class="s1">setsurface_size = (</span><span class="s3">9</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">unsetsurface_size = (</span><span class="s3">12</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span>

        <span class="s1">surface = pygame.Surface(surface_size)</span>
        <span class="s1">setsurface = pygame.Surface(setsurface_size)</span>
        <span class="s1">unsetsurface = pygame.Surface(unsetsurface_size)</span>

        <span class="s1">surface.fill(surface_color)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s1">surface_rect = surface.get_rect()</span>
        <span class="s1">setsurface_rect = setsurface.get_rect()</span>
        <span class="s1">unsetsurface_rect = unsetsurface.get_rect()</span>

        <span class="s5"># Create a mask that is filled except for a rect in the center.</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">mask_rect = mask.get_rect()</span>
        <span class="s1">unfilled_rect = pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">unfilled_rect.center = mask_rect.center</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s1">(x</span><span class="s0">, </span><span class="s1">y)</span>
            <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(unfilled_rect.x</span><span class="s0">, </span><span class="s1">unfilled_rect.w)</span>
            <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(unfilled_rect.y</span><span class="s0">, </span><span class="s1">unfilled_rect.h)</span>
        <span class="s1">):</span>
            <span class="s1">mask.set_at(pos</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">setsurface</span><span class="s0">, </span><span class="s1">unsetsurface)</span>

        <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">surface_size)</span>

        <span class="s5"># Check each surface pixel for the correct color.</span>
        <span class="s1">to_surface.lock()  </span><span class="s5"># Lock for possible speed up.</span>

        <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">(</span>
            <span class="s1">(x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(surface_rect.w) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(surface_rect.h)</span>
        <span class="s1">):</span>
            <span class="s0">if not </span><span class="s1">mask_rect.collidepoint(pos):</span>
                <span class="s1">expected_color = surface_color</span>
            <span class="s0">elif </span><span class="s1">mask.get_at(pos):</span>
                <span class="s5"># Checking set bit colors.</span>
                <span class="s0">if </span><span class="s1">setsurface_rect.collidepoint(pos):</span>
                    <span class="s1">expected_color = setsurface_color</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">expected_color = default_setcolor</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s5"># Checking unset bit colors.</span>
                <span class="s0">if </span><span class="s1">unsetsurface_rect.collidepoint(pos):</span>
                    <span class="s1">expected_color = unsetsurface_color</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">expected_color = default_unsetcolor</span>

            <span class="s1">self.assertEqual(to_surface.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_color)</span>

        <span class="s1">to_surface.unlock()</span>

    <span class="s0">def </span><span class="s1">test_to_surface__dest_locations(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures dest values can be different locations on/off the surface.&quot;&quot;&quot;</span>
        <span class="s1">SIDE = </span><span class="s3">7</span>
        <span class="s1">surface = pygame.Surface((SIDE</span><span class="s0">, </span><span class="s1">SIDE))</span>
        <span class="s1">surface_rect = surface.get_rect()</span>
        <span class="s1">dest_rect = surface_rect.copy()</span>

        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>

        <span class="s1">directions = (</span>
            <span class="s1">((s</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># left to right</span>
            <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># top to bottom</span>
            <span class="s1">((s</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># topleft to bottomright diag</span>
            <span class="s1">((-s</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># topright to bottomleft diag</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask((SIDE</span><span class="s0">, </span><span class="s1">SIDE)</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s0">for </span><span class="s1">direction </span><span class="s0">in </span><span class="s1">directions:</span>
                <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">direction:</span>
                    <span class="s1">dest_rect.topleft = pos</span>
                    <span class="s1">overlap_rect = dest_rect.clip(surface_rect)</span>
                    <span class="s1">surface.fill(surface_color)</span>

                    <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">dest=dest_rect)</span>

                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">overlap_rect)</span>
                    <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                        <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">overlap_rect</span>
                    <span class="s1">)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_to_surface__area_locations(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures area rects can be different locations on/off the mask.&quot;&quot;&quot;</span>
        <span class="s1">SIDE = </span><span class="s3">7</span>
        <span class="s1">surface = pygame.Surface((SIDE</span><span class="s0">, </span><span class="s1">SIDE))</span>

        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>

        <span class="s1">directions = (</span>
            <span class="s1">((s</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># left to right</span>
            <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># top to bottom</span>
            <span class="s1">((s</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># topleft to bottomright diag</span>
            <span class="s1">((-s</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># topright to bottomleft diag</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask((SIDE</span><span class="s0">, </span><span class="s1">SIDE)</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">area_rect = mask_rect.copy()</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s0">for </span><span class="s1">direction </span><span class="s0">in </span><span class="s1">directions:</span>
                <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">direction:</span>
                    <span class="s1">area_rect.topleft = pos</span>
                    <span class="s1">overlap_rect = area_rect.clip(mask_rect)</span>
                    <span class="s1">overlap_rect.topleft = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
                    <span class="s1">surface.fill(surface_color)</span>

                    <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">area=area_rect)</span>

                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">overlap_rect)</span>
                    <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                        <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">overlap_rect</span>
                    <span class="s1">)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__dest_and_area_locations(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures dest/area values can be different locations on/off the 
        surface/mask. 
        &quot;&quot;&quot;</span>
        <span class="s1">SIDE = </span><span class="s3">5</span>
        <span class="s1">surface = pygame.Surface((SIDE</span><span class="s0">, </span><span class="s1">SIDE))</span>
        <span class="s1">surface_rect = surface.get_rect()</span>
        <span class="s1">dest_rect = surface_rect.copy()</span>

        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>

        <span class="s1">dest_directions = (</span>
            <span class="s1">((s</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># left to right</span>
            <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># top to bottom</span>
            <span class="s1">((s</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># topleft to bottomright diag</span>
            <span class="s1">((-s</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">range(-SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,  </span><span class="s5"># topright to bottomleft diag</span>
        <span class="s1">)</span>

        <span class="s5"># Using only the topleft to bottomright diagonal to test the area (to</span>
        <span class="s5"># reduce the number of loop iterations).</span>
        <span class="s1">area_positions = list(dest_directions[</span><span class="s3">2</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask((SIDE</span><span class="s0">, </span><span class="s1">SIDE)</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">area_rect = mask_rect.copy()</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s0">for </span><span class="s1">dest_direction </span><span class="s0">in </span><span class="s1">dest_directions:</span>
                <span class="s0">for </span><span class="s1">dest_pos </span><span class="s0">in </span><span class="s1">dest_direction:</span>
                    <span class="s1">dest_rect.topleft = dest_pos</span>

                    <span class="s0">for </span><span class="s1">area_pos </span><span class="s0">in </span><span class="s1">area_positions:</span>
                        <span class="s1">area_rect.topleft = area_pos</span>
                        <span class="s1">area_overlap_rect = area_rect.clip(mask_rect)</span>
                        <span class="s1">area_overlap_rect.topleft = dest_rect.topleft</span>
                        <span class="s1">dest_overlap_rect = dest_rect.clip(area_overlap_rect)</span>

                        <span class="s1">surface.fill(surface_color)</span>

                        <span class="s1">to_surface = mask.to_surface(</span>
                            <span class="s1">surface</span><span class="s0">, </span><span class="s1">dest=dest_rect</span><span class="s0">, </span><span class="s1">area=area_rect</span>
                        <span class="s1">)</span>

                        <span class="s1">assertSurfaceFilled(</span>
                            <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">dest_overlap_rect</span>
                        <span class="s1">)</span>
                        <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                            <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">dest_overlap_rect</span>
                        <span class="s1">)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__area_sizes(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures area rects can be different sizes.&quot;&quot;&quot;</span>
        <span class="s1">SIDE = </span><span class="s3">7</span>
        <span class="s1">SIZES = (</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(SIDE - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">SIDE - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(SIDE - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">SIDE)</span><span class="s0">,</span>
            <span class="s1">(SIDE</span><span class="s0">, </span><span class="s1">SIDE - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(SIDE</span><span class="s0">, </span><span class="s1">SIDE)</span><span class="s0">,</span>
            <span class="s1">(SIDE + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">SIDE)</span><span class="s0">,</span>
            <span class="s1">(SIDE</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(SIDE + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">SIDE + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">surface = pygame.Surface((SIDE</span><span class="s0">, </span><span class="s1">SIDE))</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask((SIDE</span><span class="s0">, </span><span class="s1">SIDE)</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">SIZES:</span>
                <span class="s1">area_rect = pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">size)</span>

                <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">self.ORIGIN_OFFSETS:</span>
                    <span class="s1">area_rect.topleft = pos</span>
                    <span class="s1">overlap_rect = area_rect.clip(mask_rect)</span>
                    <span class="s1">overlap_rect.topleft = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
                    <span class="s1">surface.fill(surface_color)</span>

                    <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">area=area_rect)</span>

                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">overlap_rect)</span>
                    <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                        <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">overlap_rect</span>
                    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_color_alphas(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the setsurface/unsetsurface color alpha values are respected.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color.a = </span><span class="s3">53</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color.a = </span><span class="s3">109</span>

        <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=SRCALPHA</span><span class="s0">, </span><span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>

        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s1">to_surface = mask.to_surface(</span>
                <span class="s1">setsurface=setsurface</span><span class="s0">, </span><span class="s1">unsetsurface=unsetsurface</span>
            <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__color_alphas(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the setcolor/unsetcolor alpha values are respected.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">setcolor = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">setcolor.a = </span><span class="s3">35</span>
        <span class="s1">unsetcolor = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">unsetcolor.a = </span><span class="s3">213</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetcolor</span>

            <span class="s1">to_surface = mask.to_surface(setcolor=setcolor</span><span class="s0">, </span><span class="s1">unsetcolor=unsetcolor)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__depths(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface works correctly with supported surface depths.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">24</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=depth)</span>
            <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=depth)</span>
            <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=depth)</span>

            <span class="s1">surface.fill(surface_color)</span>
            <span class="s1">setsurface.fill(setsurface_color)</span>
            <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

            <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

                <span class="s5"># For non-32 bit depths, the actual color can be different from</span>
                <span class="s5"># what was filled.</span>
                <span class="s1">expected_color = (</span>
                    <span class="s1">setsurface.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)) </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">)</span>

                <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">setsurface</span><span class="s0">, </span><span class="s1">unsetsurface)</span>

                <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__different_depths(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an exception is raised when surfaces have different depths.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>

        <span class="s5"># Test different combinations of depths.</span>
        <span class="s1">test_depths = (</span>
            <span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># surface/setsurface/unsetsurface</span>
            <span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">24</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">32</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">32</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">32</span><span class="s0">, </span><span class="s3">24</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">depths </span><span class="s0">in </span><span class="s1">test_depths:</span>
            <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=depths[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=depths[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=depths[</span><span class="s3">2</span><span class="s1">])</span>

            <span class="s1">surface.fill(surface_color)</span>
            <span class="s1">setsurface.fill(setsurface_color)</span>
            <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                <span class="s1">mask.to_surface(surface</span><span class="s0">, </span><span class="s1">setsurface</span><span class="s0">, </span><span class="s1">unsetsurface)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__different_depths_with_created_surfaces(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an exception is raised when surfaces have different depths 
        than the created surface. 
        &quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>

        <span class="s5"># Test different combinations of depths. The created surface always has</span>
        <span class="s5"># a depth of 32.</span>
        <span class="s1">test_depths = (</span>
            <span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># setsurface/unsetsurface</span>
            <span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">24</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">24</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">32</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">32</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">32</span><span class="s0">, </span><span class="s3">24</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">set_depth</span><span class="s0">, </span><span class="s1">unset_depth </span><span class="s0">in </span><span class="s1">test_depths:</span>
            <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=set_depth)</span>
            <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">depth=unset_depth)</span>

            <span class="s1">setsurface.fill(setsurface_color)</span>
            <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                <span class="s1">mask.to_surface(setsurface=setsurface</span><span class="s0">, </span><span class="s1">unsetsurface=unsetsurface)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__same_srcalphas(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface works correctly when the SRCALPHA flag is set or not.&quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">flags </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">SRCALPHA):</span>
                <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">depth=depth)</span>
                <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">depth=depth)</span>
                <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags</span><span class="s0">, </span><span class="s1">depth=depth)</span>

                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">setsurface.fill(setsurface_color)</span>
                <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

                <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                    <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
                    <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

                    <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">setsurface</span><span class="s0">, </span><span class="s1">unsetsurface)</span>

                    <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
                    <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>
                    <span class="s0">if </span><span class="s1">flags:</span>
                        <span class="s1">self.assertTrue(to_surface.get_flags() &amp; flags)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__same_srcalphas_with_created_surfaces(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface works correctly when it creates a surface 
        and the SRCALPHA flag is set on both setsurface and unsetsurface. 
        &quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s5"># The created surface always has a depth of 32 and the SRCALPHA flag set.</span>
        <span class="s1">expected_flags = SRCALPHA</span>

        <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=expected_flags</span><span class="s0">, </span><span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=expected_flags</span><span class="s0">, </span><span class="s1">depth=</span><span class="s3">32</span><span class="s1">)</span>

        <span class="s1">setsurface.fill(setsurface_color)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s1">to_surface = mask.to_surface(</span>
                <span class="s1">setsurface=setsurface</span><span class="s0">, </span><span class="s1">unsetsurface=unsetsurface</span>
            <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>
            <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flags)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__different_srcalphas(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an exception is raised when surfaces have different SRCALPHA 
        flag settings. 
        &quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>

        <span class="s5"># Test different combinations of SRCALPHA flags.</span>
        <span class="s1">test_flags = (</span>
            <span class="s1">(SRCALPHA</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># surface/setsurface/unsetsurface</span>
            <span class="s1">(SRCALPHA</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s1">SRCALPHA)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">SRCALPHA)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">flags </span><span class="s0">in </span><span class="s1">test_flags:</span>
                <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">depth=depth)</span>
                <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">depth=depth)</span>
                <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">depth=depth)</span>

                <span class="s1">surface.fill(surface_color)</span>
                <span class="s1">setsurface.fill(setsurface_color)</span>
                <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

                <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                    <span class="s1">mask.to_surface(surface</span><span class="s0">, </span><span class="s1">setsurface</span><span class="s0">, </span><span class="s1">unsetsurface)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__different_srcalphas_with_created_surfaces(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures an exception is raised when surfaces have different SRCALPHA 
        flag settings than the created surface. 
        &quot;&quot;&quot;</span>
        <span class="s1">size = (</span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(size)</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s5"># Test different combinations of SRCALPHA flags. The created</span>
            <span class="s5"># surface always has the SRCALPHA flag set.</span>
            <span class="s0">for </span><span class="s1">flags </span><span class="s0">in </span><span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(SRCALPHA</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">SRCALPHA)):</span>
                <span class="s1">setsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">depth=depth)</span>
                <span class="s1">unsetsurface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">flags=flags[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">depth=depth)</span>

                <span class="s1">setsurface.fill(setsurface_color)</span>
                <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

                <span class="s0">with </span><span class="s1">self.assertRaises(ValueError):</span>
                    <span class="s1">mask.to_surface(setsurface=setsurface</span><span class="s0">, </span><span class="s1">unsetsurface=unsetsurface)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__dest_on_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures dest values on the surface work correctly 
        when using the defaults for setcolor and unsetcolor. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s5"># Test the dest parameter at different locations on the surface.</span>
            <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
                <span class="s1">mask_rect.topleft = dest</span>

                <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">dest=dest)</span>

                <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__dest_on_surface_with_setsurface_unsetsurface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures dest values on the surface work correctly 
        when using setsurface and unsetsurface. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s1">unsetsurface = surface.copy()</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s5"># Using different kwargs to exercise different to_surface() code.</span>
        <span class="s5"># Should not have any impact on the resulting drawn surfaces.</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: setsurface</span><span class="s0">,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: unsetsurface</span><span class="s0">,</span>
            <span class="s2">&quot;dest&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s1">color_kwargs = dict(kwargs)</span>
        <span class="s1">color_kwargs.update(((</span><span class="s2">&quot;setcolor&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s0">, None</span><span class="s1">)))</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s5"># Test the dest parameter at different locations on the surface.</span>
            <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)):</span>
                <span class="s1">mask_rect.topleft = dest</span>

                <span class="s0">for </span><span class="s1">use_color_params </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                    <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>

                    <span class="s1">test_kwargs = color_kwargs </span><span class="s0">if </span><span class="s1">use_color_params </span><span class="s0">else </span><span class="s1">kwargs</span>
                    <span class="s1">test_kwargs[</span><span class="s2">&quot;dest&quot;</span><span class="s1">] = dest</span>
                    <span class="s1">to_surface = mask.to_surface(**test_kwargs)</span>

                    <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                    <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
                    <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                        <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect</span>
                    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__dest_off_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures dest values off the surface work correctly 
        when using the defaults for setcolor and unsetcolor. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s5"># Test different dests off the surface.</span>
        <span class="s1">dests = [(-width</span><span class="s0">, </span><span class="s1">-height)</span><span class="s0">, </span><span class="s1">(-width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-height)]</span>
        <span class="s1">dests.extend(off_corners(surface.get_rect()))</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">dests:</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
                <span class="s1">mask_rect.topleft = dest</span>

                <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">dest=dest)</span>

                <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__dest_off_surface_with_setsurface_unsetsurface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures dest values off the surface work correctly 
        when using setsurface and unsetsurface. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s1">unsetsurface = surface.copy()</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s5"># Test different dests off the surface.</span>
        <span class="s1">dests = [(-width</span><span class="s0">, </span><span class="s1">-height)</span><span class="s0">, </span><span class="s1">(-width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-height)]</span>
        <span class="s1">dests.extend(off_corners(surface.get_rect()))</span>

        <span class="s5"># Using different kwargs to exercise different to_surface() code.</span>
        <span class="s5"># Should not have any impact on the resulting drawn surfaces.</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: setsurface</span><span class="s0">,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: unsetsurface</span><span class="s0">,</span>
            <span class="s2">&quot;dest&quot;</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

        <span class="s1">color_kwargs = dict(kwargs)</span>
        <span class="s1">color_kwargs.update(((</span><span class="s2">&quot;setcolor&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s0">, None</span><span class="s1">)))</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s0">for </span><span class="s1">dest </span><span class="s0">in </span><span class="s1">dests:</span>
                <span class="s1">mask_rect.topleft = dest</span>

                <span class="s0">for </span><span class="s1">use_color_params </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                    <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
                    <span class="s1">test_kwargs = color_kwargs </span><span class="s0">if </span><span class="s1">use_color_params </span><span class="s0">else </span><span class="s1">kwargs</span>
                    <span class="s1">test_kwargs[</span><span class="s2">&quot;dest&quot;</span><span class="s1">] = dest</span>
                    <span class="s1">to_surface = mask.to_surface(**test_kwargs)</span>

                    <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                    <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">mask_rect)</span>
                    <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                        <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">mask_rect</span>
                    <span class="s1">)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_to_surface__area_on_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures area values on the mask work correctly 
        when using the defaults for setcolor and unsetcolor. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">area_rect = mask_rect.copy()</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s5"># Testing the area parameter at different locations on the mask.</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)):</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
                <span class="s1">area_rect.topleft = pos</span>
                <span class="s1">overlap_rect = mask_rect.clip(area_rect)</span>
                <span class="s1">overlap_rect.topleft = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">area=area_rect)</span>

                <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">overlap_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">overlap_rect</span>
                <span class="s1">)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s0">def </span><span class="s1">test_to_surface__area_on_mask_with_setsurface_unsetsurface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures area values on the mask work correctly 
        when using setsurface and unsetsurface. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s1">unsetsurface = surface.copy()</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s5"># Using the values in kwargs vs color_kwargs tests different to_surface</span>
        <span class="s5"># code. Should not have any impact on the resulting drawn surfaces.</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: setsurface</span><span class="s0">,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: unsetsurface</span><span class="s0">,</span>
            <span class="s2">&quot;area&quot;</span><span class="s1">: pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">size)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">color_kwargs = dict(kwargs)</span>
        <span class="s1">color_kwargs.update(((</span><span class="s2">&quot;setcolor&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s0">, None</span><span class="s1">)))</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">area_rect = mask_rect.copy()</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s5"># Testing the area parameter at different locations on the mask.</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width)):</span>
                <span class="s1">area_rect.topleft = pos</span>
                <span class="s1">overlap_rect = mask_rect.clip(area_rect)</span>
                <span class="s1">overlap_rect.topleft = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                <span class="s0">for </span><span class="s1">use_color_params </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                    <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
                    <span class="s1">test_kwargs = color_kwargs </span><span class="s0">if </span><span class="s1">use_color_params </span><span class="s0">else </span><span class="s1">kwargs</span>
                    <span class="s1">test_kwargs[</span><span class="s2">&quot;area&quot;</span><span class="s1">].topleft = pos</span>
                    <span class="s1">overlap_rect = mask_rect.clip(test_kwargs[</span><span class="s2">&quot;area&quot;</span><span class="s1">])</span>
                    <span class="s1">overlap_rect.topleft = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                    <span class="s1">to_surface = mask.to_surface(**test_kwargs)</span>

                    <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                    <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">overlap_rect)</span>
                    <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                        <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">overlap_rect</span>
                    <span class="s1">)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_to_surface__area_off_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures area values off the mask work correctly 
        when using the defaults for setcolor and unsetcolor. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_setcolor = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)</span>
        <span class="s1">default_unsetcolor = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s5"># Testing positions off the mask.</span>
        <span class="s1">positions = [(-width</span><span class="s0">, </span><span class="s1">-height)</span><span class="s0">, </span><span class="s1">(-width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-height)]</span>
        <span class="s1">positions.extend(off_corners(pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))))</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">area_rect = mask_rect.copy()</span>
            <span class="s1">expected_color = default_setcolor </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">default_unsetcolor</span>

            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">positions:</span>
                <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
                <span class="s1">area_rect.topleft = pos</span>
                <span class="s1">overlap_rect = mask_rect.clip(area_rect)</span>
                <span class="s1">overlap_rect.topleft = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">area=area_rect)</span>

                <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">overlap_rect)</span>
                <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                    <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">overlap_rect</span>
                <span class="s1">)</span>

    <span class="s1">@unittest.expectedFailure</span>
    <span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;Segfaults on pypy&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_to_surface__area_off_mask_with_setsurface_unsetsurface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures area values off the mask work correctly 
        when using setsurface and unsetsurface. 
        &quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s1">setsurface = surface.copy()</span>
        <span class="s1">setsurface_color = pygame.Color(</span><span class="s2">&quot;green&quot;</span><span class="s1">)</span>
        <span class="s1">setsurface.fill(setsurface_color)</span>

        <span class="s1">unsetsurface = surface.copy()</span>
        <span class="s1">unsetsurface_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">unsetsurface.fill(unsetsurface_color)</span>

        <span class="s5"># Testing positions off the mask.</span>
        <span class="s1">positions = [(-width</span><span class="s0">, </span><span class="s1">-height)</span><span class="s0">, </span><span class="s1">(-width</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-height)]</span>
        <span class="s1">positions.extend(off_corners(pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(width</span><span class="s0">, </span><span class="s1">height))))</span>

        <span class="s5"># Using the values in kwargs vs color_kwargs tests different to_surface</span>
        <span class="s5"># code. Should not have any impact on the resulting drawn surfaces.</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;surface&quot;</span><span class="s1">: surface</span><span class="s0">,</span>
            <span class="s2">&quot;setsurface&quot;</span><span class="s1">: setsurface</span><span class="s0">,</span>
            <span class="s2">&quot;unsetsurface&quot;</span><span class="s1">: unsetsurface</span><span class="s0">,</span>
            <span class="s2">&quot;area&quot;</span><span class="s1">: pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">size)</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">color_kwargs = dict(kwargs)</span>
        <span class="s1">color_kwargs.update(((</span><span class="s2">&quot;setcolor&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;unsetcolor&quot;</span><span class="s0">, None</span><span class="s1">)))</span>

        <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>
            <span class="s1">mask_rect = mask.get_rect()</span>
            <span class="s1">expected_color = setsurface_color </span><span class="s0">if </span><span class="s1">fill </span><span class="s0">else </span><span class="s1">unsetsurface_color</span>

            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">positions:</span>
                <span class="s0">for </span><span class="s1">use_color_params </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                    <span class="s1">surface.fill(surface_color)  </span><span class="s5"># Clear for each test.</span>
                    <span class="s1">test_kwargs = color_kwargs </span><span class="s0">if </span><span class="s1">use_color_params </span><span class="s0">else </span><span class="s1">kwargs</span>
                    <span class="s1">test_kwargs[</span><span class="s2">&quot;area&quot;</span><span class="s1">].topleft = pos</span>
                    <span class="s1">overlap_rect = mask_rect.clip(test_kwargs[</span><span class="s2">&quot;area&quot;</span><span class="s1">])</span>
                    <span class="s1">overlap_rect.topleft = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                    <span class="s1">to_surface = mask.to_surface(**test_kwargs)</span>

                    <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                    <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color</span><span class="s0">, </span><span class="s1">overlap_rect)</span>
                    <span class="s1">assertSurfaceFilledIgnoreArea(</span>
                        <span class="s1">self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">overlap_rect</span>
                    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__surface_with_zero_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures zero sized surfaces are handled correctly.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">3</span>
        <span class="s1">size = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size)</span>
        <span class="s1">mask = pygame.mask.Mask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">to_surface = mask.to_surface(surface)</span>

        <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
        <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__setsurface_with_zero_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures zero sized setsurfaces are handled correctly.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;white&quot;</span><span class="s1">)  </span><span class="s5"># Default setcolor.</span>
        <span class="s1">mask_size = (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">setsurface = pygame.Surface((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected_flag</span><span class="s0">, </span><span class="s1">expected_depth)</span>

        <span class="s1">to_surface = mask.to_surface(setsurface=setsurface)</span>

        <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
        <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
        <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_to_surface__unsetsurface_with_zero_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures zero sized unsetsurfaces are handled correctly.&quot;&quot;&quot;</span>
        <span class="s1">expected_ref_count = </span><span class="s3">2</span>
        <span class="s1">expected_flag = SRCALPHA</span>
        <span class="s1">expected_depth = </span><span class="s3">32</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;black&quot;</span><span class="s1">)  </span><span class="s5"># Default unsetcolor.</span>
        <span class="s1">mask_size = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = pygame.mask.Mask(mask_size)</span>
        <span class="s1">unsetsurface = pygame.Surface((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected_flag</span><span class="s0">, </span><span class="s1">expected_depth)</span>

        <span class="s1">to_surface = mask.to_surface(unsetsurface=unsetsurface)</span>

        <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
        <span class="s0">if not </span><span class="s1">IS_PYPY:</span>
            <span class="s1">self.assertEqual(sys.getrefcount(to_surface)</span><span class="s0">, </span><span class="s1">expected_ref_count)</span>
        <span class="s1">self.assertTrue(to_surface.get_flags() &amp; expected_flag)</span>
        <span class="s1">self.assertEqual(to_surface.get_bitsize()</span><span class="s0">, </span><span class="s1">expected_depth)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures masks can be created with zero sizes.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s0">for </span><span class="s1">fill </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
                <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">, fill=</span><span class="s0">{</span><span class="s1">fill</span><span class="s0">}</span><span class="s2">&quot;</span>

                <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=fill)</span>

                <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_copy(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">expected_size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">11</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

            <span class="s1">mask_copy = mask.copy()</span>

            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_get_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_size correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">expected_size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">41</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">40</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

            <span class="s1">size = mask.get_size()</span>

            <span class="s1">self.assertEqual(size</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_get_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">expected_size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">expected_rect = pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected_size)</span>
            <span class="s1">mask = pygame.mask.Mask(expected_size)</span>

            <span class="s1">rect = mask.get_rect()</span>

            <span class="s1">self.assertEqual(rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_get_at(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_at correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">51</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
                <span class="s1">value = mask.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_set_at(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures set_at correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">31</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
                <span class="s1">mask.set_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_overlap(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap correctly handles zero sized masks. 
 
        Tests combinations of sized and zero sized masks. 
        &quot;&quot;&quot;</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">zero_size_pairs(</span><span class="s3">51</span><span class="s0">, </span><span class="s3">42</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;size1=</span><span class="s0">{</span><span class="s1">size1</span><span class="s0">}</span><span class="s2">, size2=</span><span class="s0">{</span><span class="s1">size2</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">mask1 = pygame.mask.Mask(size1</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">mask2 = pygame.mask.Mask(size2</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">overlap_pos = mask1.overlap(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertIsNone(overlap_pos</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_overlap_area(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_area correctly handles zero sized masks. 
 
        Tests combinations of sized and zero sized masks. 
        &quot;&quot;&quot;</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">zero_size_pairs(</span><span class="s3">41</span><span class="s0">, </span><span class="s3">52</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;size1=</span><span class="s0">{</span><span class="s1">size1</span><span class="s0">}</span><span class="s2">, size2=</span><span class="s0">{</span><span class="s1">size2</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">mask1 = pygame.mask.Mask(size1</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">mask2 = pygame.mask.Mask(size2</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">overlap_count = mask1.overlap_area(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertEqual(overlap_count</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_overlap_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_mask correctly handles zero sized masks. 
 
        Tests combinations of sized and zero sized masks. 
        &quot;&quot;&quot;</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">zero_size_pairs(</span><span class="s3">43</span><span class="s0">, </span><span class="s3">53</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;size1=</span><span class="s0">{</span><span class="s1">size1</span><span class="s0">}</span><span class="s2">, size2=</span><span class="s0">{</span><span class="s1">size2</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">mask1 = pygame.mask.Mask(size1</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">mask2 = pygame.mask.Mask(size2</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">overlap_mask = mask1.overlap_mask(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(overlap_mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(overlap_mask.get_size()</span><span class="s0">, </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_fill(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures fill correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s1">mask.fill()</span>

            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_clear(self):</span>
        <span class="s1">sizes = ((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>
            <span class="s1">mask.clear()</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_flip(self):</span>
        <span class="s1">sizes = ((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>
            <span class="s1">mask.invert()</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_scale(self):</span>
        <span class="s1">sizes = ((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>
            <span class="s1">mask2 = mask.scale((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

            <span class="s1">self.assertIsInstance(mask2</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertEqual(mask2.get_size()</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_draw(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw correctly handles zero sized masks. 
 
        Tests combinations of sized and zero sized masks. 
        &quot;&quot;&quot;</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">zero_size_pairs(</span><span class="s3">31</span><span class="s0">, </span><span class="s3">37</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;size1=</span><span class="s0">{</span><span class="s1">size1</span><span class="s0">}</span><span class="s2">, size2=</span><span class="s0">{</span><span class="s1">size2</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">mask1 = pygame.mask.Mask(size1</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">mask2 = pygame.mask.Mask(size2</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">expected_count = mask1.count()</span>

            <span class="s1">mask1.draw(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_erase(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures erase correctly handles zero sized masks. 
 
        Tests combinations of sized and zero sized masks. 
        &quot;&quot;&quot;</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">zero_size_pairs(</span><span class="s3">29</span><span class="s0">, </span><span class="s3">23</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;size1=</span><span class="s0">{</span><span class="s1">size1</span><span class="s0">}</span><span class="s2">, size2=</span><span class="s0">{</span><span class="s1">size2</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">mask1 = pygame.mask.Mask(size1</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">mask2 = pygame.mask.Mask(size2</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">expected_count = mask1.count()</span>

            <span class="s1">mask1.erase(mask2</span><span class="s0">, </span><span class="s1">offset)</span>

            <span class="s1">self.assertEqual(mask1.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask1.get_size()</span><span class="s0">, </span><span class="s1">size1</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_count(self):</span>
        <span class="s1">sizes = ((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">mask = pygame.mask.Mask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_centroid(self):</span>
        <span class="s1">sizes = ((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>
            <span class="s1">self.assertEqual(mask.centroid()</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_angle(self):</span>
        <span class="s1">sizes = ((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>
            <span class="s1">self.assertEqual(mask.angle()</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_outline(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures outline correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_points = []</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">61</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s1">points = mask.outline()</span>

            <span class="s1">self.assertListEqual(points</span><span class="s0">, </span><span class="s1">expected_points</span><span class="s0">, </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_outline__with_arg(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures outline correctly handles zero sized masks 
        when using the skip pixels argument.&quot;&quot;&quot;</span>
        <span class="s1">expected_points = []</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">66</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">65</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s1">points = mask.outline(</span><span class="s3">10</span><span class="s1">)</span>

            <span class="s1">self.assertListEqual(points</span><span class="s0">, </span><span class="s1">expected_points</span><span class="s0">, </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_convolve(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures convolve correctly handles zero sized masks. 
 
        Tests the different combinations of sized and zero sized masks. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size1 </span><span class="s0">in </span><span class="s1">((</span><span class="s3">17</span><span class="s0">, </span><span class="s3">13</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">71</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">70</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask1 = pygame.mask.Mask(size1</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">((</span><span class="s3">11</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">81</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">60</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
                <span class="s1">msg = </span><span class="s2">f&quot;sizes=</span><span class="s0">{</span><span class="s1">size1</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">size2</span><span class="s0">}</span><span class="s2">&quot;</span>
                <span class="s1">mask2 = pygame.mask.Mask(size2</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">expected_size = (</span>
                    <span class="s1">max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">size1[</span><span class="s3">0</span><span class="s1">] + size2[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">size1[</span><span class="s3">1</span><span class="s1">] + size2[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s1">mask = mask1.convolve(mask2)</span>

                <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertIsNot(mask</span><span class="s0">, </span><span class="s1">mask2</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_convolve__with_output_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures convolve correctly handles zero sized masks 
        when using an output mask argument. 
 
        Tests the different combinations of sized and zero sized masks. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size1 </span><span class="s0">in </span><span class="s1">((</span><span class="s3">11</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">91</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">90</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask1 = pygame.mask.Mask(size1</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">size2 </span><span class="s0">in </span><span class="s1">((</span><span class="s3">13</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">83</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">62</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
                <span class="s1">mask2 = pygame.mask.Mask(size2</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s0">for </span><span class="s1">output_size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">71</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">70</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;sizes=</span><span class="s0">{</span><span class="s1">size1</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">size2</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">output_size</span><span class="s0">}</span><span class="s2">&quot;</span>
                    <span class="s1">output_mask = pygame.mask.Mask(output_size)</span>

                    <span class="s1">mask = mask1.convolve(mask2</span><span class="s0">, </span><span class="s1">output_mask)</span>

                    <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertIs(mask</span><span class="s0">, </span><span class="s1">output_mask</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">output_size</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_connected_component(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_component correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">81</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s1">cc_mask = mask.connected_component()</span>

            <span class="s1">self.assertIsInstance(cc_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(cc_mask.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
            <span class="s1">self.assertEqual(cc_mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_connected_component__indexed(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_component correctly handles zero sized masks 
        when using an index argument.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">91</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">90</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s0">with </span><span class="s1">self.assertRaises(IndexError):</span>
                <span class="s1">cc_mask = mask.connected_component((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_connected_components(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_components correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_cc_masks = []</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">11</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s1">cc_masks = mask.connected_components()</span>

            <span class="s1">self.assertListEqual(cc_masks</span><span class="s0">, </span><span class="s1">expected_cc_masks</span><span class="s0">, </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_get_bounding_rects(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_bounding_rects correctly handles zero sized masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_bounding_rects = []</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">21</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(size)</span>

            <span class="s1">bounding_rects = mask.get_bounding_rects()</span>

            <span class="s1">self.assertListEqual(</span>
                <span class="s1">bounding_rects</span><span class="s0">, </span><span class="s1">expected_bounding_rects</span><span class="s0">, </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_to_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface correctly handles zero sized masks and surfaces.&quot;&quot;&quot;</span>
        <span class="s1">mask_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">surf_color = pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">surf_size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">7</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">surface = pygame.Surface(surf_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
            <span class="s1">surface.fill(surf_color)</span>

            <span class="s0">for </span><span class="s1">mask_size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
                <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

                <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">setcolor=mask_color)</span>

                <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
                <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">surf_size)</span>

                <span class="s0">if </span><span class="s3">0 </span><span class="s0">not in </span><span class="s1">surf_size:</span>
                    <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">surf_color)</span>

    <span class="s0">def </span><span class="s1">test_zero_mask_to_surface__create_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface correctly handles zero sized masks and surfaces 
        when it has to create a default surface. 
        &quot;&quot;&quot;</span>
        <span class="s1">mask_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">mask_size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.Mask(mask_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

            <span class="s1">to_surface = mask.to_surface(setcolor=mask_color)</span>

            <span class="s1">self.assertIsInstance(to_surface</span><span class="s0">, </span><span class="s1">pygame.Surface)</span>
            <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>


<span class="s0">class </span><span class="s1">SubMask(pygame.mask.Mask):</span>
    <span class="s4">&quot;&quot;&quot;Subclass of the Mask class to help test subclassing.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.test_attribute = </span><span class="s0">True</span>


<span class="s0">class </span><span class="s1">SubMaskCopy(SubMask):</span>
    <span class="s4">&quot;&quot;&quot;Subclass of the Mask class to help test copying subclasses.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s1">mask_copy = super().copy()</span>
        <span class="s1">mask_copy.test_attribute = self.test_attribute</span>
        <span class="s0">return </span><span class="s1">mask_copy</span>


<span class="s0">class </span><span class="s1">SubMaskDunderCopy(SubMask):</span>
    <span class="s4">&quot;&quot;&quot;Subclass of the Mask class to help test copying subclasses.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__copy__(self):</span>
        <span class="s1">mask_copy = super().__copy__()</span>
        <span class="s1">mask_copy.test_attribute = self.test_attribute</span>
        <span class="s0">return </span><span class="s1">mask_copy</span>


<span class="s0">class </span><span class="s1">SubMaskCopyAndDunderCopy(SubMaskDunderCopy):</span>
    <span class="s4">&quot;&quot;&quot;Subclass of the Mask class to help test copying subclasses.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">copy(self):</span>
        <span class="s0">return </span><span class="s1">super().copy()</span>


<span class="s0">class </span><span class="s1">MaskSubclassTest(unittest.TestCase):</span>
    <span class="s4">&quot;&quot;&quot;Test subclassed Masks.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_subclass_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures the Mask class can be subclassed.&quot;&quot;&quot;</span>
        <span class="s1">mask = SubMask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">SubMask)</span>
        <span class="s1">self.assertTrue(mask.test_attribute)</span>

    <span class="s0">def </span><span class="s1">test_subclass_copy(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask = SubMask((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s5"># Test both the copy() and __copy__() methods.</span>
        <span class="s0">for </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">(mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask)):</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">SubMask)</span>
            <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s5"># No subclass attributes because copy()/__copy__() not overridden.</span>
            <span class="s1">self.assertFalse(hasattr(mask_copy</span><span class="s0">, </span><span class="s2">&quot;test_attribute&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_subclass_copy__override_copy(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy works for subclassed Masks overriding copy.&quot;&quot;&quot;</span>
        <span class="s1">mask = SubMaskCopy((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s5"># Test both the copy() and __copy__() methods.</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">enumerate((mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask))):</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">SubMaskCopy)</span>
            <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>

            <span class="s0">if </span><span class="s3">1 </span><span class="s1">== i:</span>
                <span class="s5"># No subclass attributes because __copy__() not overridden.</span>
                <span class="s1">self.assertFalse(hasattr(mask_copy</span><span class="s0">, </span><span class="s2">&quot;test_attribute&quot;</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.assertTrue(mask_copy.test_attribute)</span>

    <span class="s0">def </span><span class="s1">test_subclass_copy__override_dunder_copy(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy works for subclassed Masks overriding __copy__.&quot;&quot;&quot;</span>
        <span class="s1">mask = SubMaskDunderCopy((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s5"># Test both the copy() and __copy__() methods.</span>
        <span class="s0">for </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">(mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask)):</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">SubMaskDunderCopy)</span>
            <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s5"># Calls to copy() eventually call __copy__() internally so the</span>
            <span class="s5"># attributes will be copied.</span>
            <span class="s1">self.assertTrue(mask_copy.test_attribute)</span>

    <span class="s0">def </span><span class="s1">test_subclass_copy__override_both_copy_methods(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures copy works for subclassed Masks overriding copy/__copy__.&quot;&quot;&quot;</span>
        <span class="s1">mask = SubMaskCopyAndDunderCopy((</span><span class="s3">65</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s5"># Test both the copy() and __copy__() methods.</span>
        <span class="s0">for </span><span class="s1">mask_copy </span><span class="s0">in </span><span class="s1">(mask.copy()</span><span class="s0">, </span><span class="s1">copy.copy(mask)):</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertIsInstance(mask_copy</span><span class="s0">, </span><span class="s1">SubMaskCopyAndDunderCopy)</span>
            <span class="s1">self.assertIsNot(mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s1">assertMaskEqual(self</span><span class="s0">, </span><span class="s1">mask_copy</span><span class="s0">, </span><span class="s1">mask)</span>
            <span class="s1">self.assertTrue(mask_copy.test_attribute)</span>

    <span class="s0">def </span><span class="s1">test_subclass_get_size(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_size works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = SubMask(expected_size)</span>

        <span class="s1">size = mask.get_size()</span>

        <span class="s1">self.assertEqual(size</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_subclass_mask_get_rect(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_rect works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_rect = pygame.Rect((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">65</span><span class="s0">, </span><span class="s3">33</span><span class="s1">))</span>
        <span class="s1">mask = SubMask(expected_rect.size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">rect = mask.get_rect()</span>

        <span class="s1">self.assertEqual(rect</span><span class="s0">, </span><span class="s1">expected_rect)</span>

    <span class="s0">def </span><span class="s1">test_subclass_get_at(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_at works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_bit = </span><span class="s3">1</span>
        <span class="s1">mask = SubMask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">bit = mask.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s1">self.assertEqual(bit</span><span class="s0">, </span><span class="s1">expected_bit)</span>

    <span class="s0">def </span><span class="s1">test_subclass_set_at(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures set_at works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_bit = </span><span class="s3">1</span>
        <span class="s1">expected_count = </span><span class="s3">1</span>
        <span class="s1">pos = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask = SubMask(fill=</span><span class="s0">False, </span><span class="s1">size=(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s1">mask.set_at(pos)</span>

        <span class="s1">self.assertEqual(mask.get_at(pos)</span><span class="s0">, </span><span class="s1">expected_bit)</span>
        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_overlap(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_pos = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">masks = (pygame.mask.Mask(fill=</span><span class="s0">True, </span><span class="s1">size=mask_size)</span><span class="s0">, </span><span class="s1">SubMask(mask_size</span><span class="s0">, True</span><span class="s1">))</span>
        <span class="s1">arg_masks = (</span>
            <span class="s1">pygame.mask.Mask(fill=</span><span class="s0">True, </span><span class="s1">size=mask_size)</span><span class="s0">,</span>
            <span class="s1">SubMask(mask_size</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5"># Test different combinations of subclassed and non-subclassed Masks.</span>
        <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">masks:</span>
            <span class="s0">for </span><span class="s1">arg_mask </span><span class="s0">in </span><span class="s1">arg_masks:</span>
                <span class="s1">overlap_pos = mask.overlap(arg_mask</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(overlap_pos</span><span class="s0">, </span><span class="s1">expected_pos)</span>

    <span class="s0">def </span><span class="s1">test_subclass_overlap_area(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_area works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">expected_count = mask_size[</span><span class="s3">0</span><span class="s1">] * mask_size[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">masks = (pygame.mask.Mask(fill=</span><span class="s0">True, </span><span class="s1">size=mask_size)</span><span class="s0">, </span><span class="s1">SubMask(mask_size</span><span class="s0">, True</span><span class="s1">))</span>
        <span class="s1">arg_masks = (</span>
            <span class="s1">pygame.mask.Mask(fill=</span><span class="s0">True, </span><span class="s1">size=mask_size)</span><span class="s0">,</span>
            <span class="s1">SubMask(mask_size</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5"># Test different combinations of subclassed and non-subclassed Masks.</span>
        <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">masks:</span>
            <span class="s0">for </span><span class="s1">arg_mask </span><span class="s0">in </span><span class="s1">arg_masks:</span>
                <span class="s1">overlap_count = mask.overlap_area(arg_mask</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(overlap_count</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_overlap_mask(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures overlap_mask works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">expected_count = expected_size[</span><span class="s3">0</span><span class="s1">] * expected_size[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">masks = (</span>
            <span class="s1">pygame.mask.Mask(fill=</span><span class="s0">True, </span><span class="s1">size=expected_size)</span><span class="s0">,</span>
            <span class="s1">SubMask(expected_size</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">arg_masks = (</span>
            <span class="s1">pygame.mask.Mask(fill=</span><span class="s0">True, </span><span class="s1">size=expected_size)</span><span class="s0">,</span>
            <span class="s1">SubMask(expected_size</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5"># Test different combinations of subclassed and non-subclassed Masks.</span>
        <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">masks:</span>
            <span class="s0">for </span><span class="s1">arg_mask </span><span class="s0">in </span><span class="s1">arg_masks:</span>
                <span class="s1">overlap_mask = mask.overlap_mask(arg_mask</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

                <span class="s1">self.assertIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
                <span class="s1">self.assertNotIsInstance(overlap_mask</span><span class="s0">, </span><span class="s1">SubMask)</span>
                <span class="s1">self.assertEqual(overlap_mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
                <span class="s1">self.assertEqual(overlap_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_subclass_fill(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures fill works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">expected_count = mask_size[</span><span class="s3">0</span><span class="s1">] * mask_size[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">mask = SubMask(fill=</span><span class="s0">False, </span><span class="s1">size=mask_size)</span>

        <span class="s1">mask.fill()</span>

        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_clear(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures clear works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">mask = SubMask(mask_size</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">mask.clear()</span>

        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_invert(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures invert works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">expected_count = mask_size[</span><span class="s3">0</span><span class="s1">] * mask_size[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">mask = SubMask(fill=</span><span class="s0">False, </span><span class="s1">size=mask_size)</span>

        <span class="s1">mask.invert()</span>

        <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_scale(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures scale works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = SubMask((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>

        <span class="s1">scaled_mask = mask.scale(expected_size)</span>

        <span class="s1">self.assertIsInstance(scaled_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertNotIsInstance(scaled_mask</span><span class="s0">, </span><span class="s1">SubMask)</span>
        <span class="s1">self.assertEqual(scaled_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_subclass_draw(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures draw works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">expected_count = mask_size[</span><span class="s3">0</span><span class="s1">] * mask_size[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">arg_masks = (</span>
            <span class="s1">pygame.mask.Mask(fill=</span><span class="s0">True, </span><span class="s1">size=mask_size)</span><span class="s0">,</span>
            <span class="s1">SubMask(mask_size</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s5"># Test different combinations of subclassed and non-subclassed Masks.</span>
        <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">(pygame.mask.Mask(mask_size)</span><span class="s0">, </span><span class="s1">SubMask(mask_size)):</span>
            <span class="s0">for </span><span class="s1">arg_mask </span><span class="s0">in </span><span class="s1">arg_masks:</span>
                <span class="s1">mask.clear()  </span><span class="s5"># Clear for each test.</span>

                <span class="s1">mask.draw(arg_mask</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_erase(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures erase works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">masks = (pygame.mask.Mask(mask_size</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SubMask(mask_size</span><span class="s0">, True</span><span class="s1">))</span>
        <span class="s1">arg_masks = (pygame.mask.Mask(mask_size</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">SubMask(mask_size</span><span class="s0">, True</span><span class="s1">))</span>

        <span class="s5"># Test different combinations of subclassed and non-subclassed Masks.</span>
        <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">masks:</span>
            <span class="s0">for </span><span class="s1">arg_mask </span><span class="s0">in </span><span class="s1">arg_masks:</span>
                <span class="s1">mask.fill()  </span><span class="s5"># Fill for each test.</span>

                <span class="s1">mask.erase(arg_mask</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_count(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures count works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">mask_size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">expected_count = mask_size[</span><span class="s3">0</span><span class="s1">] * mask_size[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span>
        <span class="s1">mask = SubMask(fill=</span><span class="s0">True, </span><span class="s1">size=mask_size)</span>
        <span class="s1">mask.set_at((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">count = mask.count()</span>

        <span class="s1">self.assertEqual(count</span><span class="s0">, </span><span class="s1">expected_count)</span>

    <span class="s0">def </span><span class="s1">test_subclass_centroid(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures centroid works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_centroid = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">mask_size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">mask = SubMask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s1">centroid = mask.centroid()</span>

        <span class="s1">self.assertEqual(centroid</span><span class="s0">, </span><span class="s1">expected_centroid)</span>

    <span class="s0">def </span><span class="s1">test_subclass_angle(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures angle works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_angle = </span><span class="s3">0.0</span>
        <span class="s1">mask = SubMask(size=(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>

        <span class="s1">angle = mask.angle()</span>

        <span class="s1">self.assertAlmostEqual(angle</span><span class="s0">, </span><span class="s1">expected_angle)</span>

    <span class="s0">def </span><span class="s1">test_subclass_outline(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures outline works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_outline = []</span>
        <span class="s1">mask = SubMask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>

        <span class="s1">outline = mask.outline()</span>

        <span class="s1">self.assertListEqual(outline</span><span class="s0">, </span><span class="s1">expected_outline)</span>

    <span class="s0">def </span><span class="s1">test_subclass_convolve(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures convolve works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = </span><span class="s3">7</span><span class="s0">, </span><span class="s3">5</span>
        <span class="s1">mask_size = (width</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">expected_size = (max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">width * </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">height * </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">))</span>

        <span class="s1">arg_masks = (pygame.mask.Mask(mask_size)</span><span class="s0">, </span><span class="s1">SubMask(mask_size))</span>
        <span class="s1">output_masks = (pygame.mask.Mask(mask_size)</span><span class="s0">, </span><span class="s1">SubMask(mask_size))</span>

        <span class="s5"># Test different combinations of subclassed and non-subclassed Masks.</span>
        <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">(pygame.mask.Mask(mask_size)</span><span class="s0">, </span><span class="s1">SubMask(mask_size)):</span>
            <span class="s0">for </span><span class="s1">arg_mask </span><span class="s0">in </span><span class="s1">arg_masks:</span>
                <span class="s1">convolve_mask = mask.convolve(arg_mask)</span>

                <span class="s1">self.assertIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
                <span class="s1">self.assertNotIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">SubMask)</span>
                <span class="s1">self.assertEqual(convolve_mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
                <span class="s1">self.assertEqual(convolve_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

                <span class="s5"># Test subclassed masks for the output_mask as well.</span>
                <span class="s0">for </span><span class="s1">output_mask </span><span class="s0">in </span><span class="s1">output_masks:</span>
                    <span class="s1">convolve_mask = mask.convolve(arg_mask</span><span class="s0">, </span><span class="s1">output_mask)</span>

                    <span class="s1">self.assertIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
                    <span class="s1">self.assertEqual(convolve_mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
                    <span class="s1">self.assertEqual(convolve_mask.get_size()</span><span class="s0">, </span><span class="s1">mask_size)</span>

                    <span class="s0">if </span><span class="s1">isinstance(output_mask</span><span class="s0">, </span><span class="s1">SubMask):</span>
                        <span class="s1">self.assertIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">SubMask)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">self.assertNotIsInstance(convolve_mask</span><span class="s0">, </span><span class="s1">SubMask)</span>

    <span class="s0">def </span><span class="s1">test_subclass_connected_component(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_component works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>
        <span class="s1">expected_size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">mask = SubMask(expected_size)</span>

        <span class="s1">cc_mask = mask.connected_component()</span>

        <span class="s1">self.assertIsInstance(cc_mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
        <span class="s1">self.assertNotIsInstance(cc_mask</span><span class="s0">, </span><span class="s1">SubMask)</span>
        <span class="s1">self.assertEqual(cc_mask.count()</span><span class="s0">, </span><span class="s1">expected_count)</span>
        <span class="s1">self.assertEqual(cc_mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size)</span>

    <span class="s0">def </span><span class="s1">test_subclass_connected_components(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures connected_components works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_ccs = []</span>
        <span class="s1">mask = SubMask((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>

        <span class="s1">ccs = mask.connected_components()</span>

        <span class="s1">self.assertListEqual(ccs</span><span class="s0">, </span><span class="s1">expected_ccs)</span>

    <span class="s0">def </span><span class="s1">test_subclass_get_bounding_rects(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures get_bounding_rects works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_bounding_rects = []</span>
        <span class="s1">mask = SubMask((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s1">bounding_rects = mask.get_bounding_rects()</span>

        <span class="s1">self.assertListEqual(bounding_rects</span><span class="s0">, </span><span class="s1">expected_bounding_rects)</span>

    <span class="s0">def </span><span class="s1">test_subclass_to_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures to_surface works for subclassed Masks.&quot;&quot;&quot;</span>
        <span class="s1">expected_color = pygame.Color(</span><span class="s2">&quot;blue&quot;</span><span class="s1">)</span>
        <span class="s1">size = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">mask = SubMask(size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>
        <span class="s1">surface.fill(pygame.Color(</span><span class="s2">&quot;red&quot;</span><span class="s1">))</span>

        <span class="s1">to_surface = mask.to_surface(surface</span><span class="s0">, </span><span class="s1">setcolor=expected_color)</span>

        <span class="s1">self.assertIs(to_surface</span><span class="s0">, </span><span class="s1">surface)</span>
        <span class="s1">self.assertEqual(to_surface.get_size()</span><span class="s0">, </span><span class="s1">size)</span>
        <span class="s1">assertSurfaceFilled(self</span><span class="s0">, </span><span class="s1">to_surface</span><span class="s0">, </span><span class="s1">expected_color)</span>


<span class="s1">@unittest.skipIf(IS_PYPY</span><span class="s0">, </span><span class="s2">&quot;pypy has lots of mask failures&quot;</span><span class="s1">)  </span><span class="s5"># TODO</span>
<span class="s0">class </span><span class="s1">MaskModuleTest(unittest.TestCase):</span>
    <span class="s0">def </span><span class="s1">test_from_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures from_surface creates a mask with the correct bits set. 
 
        This test checks the masks created by the from_surface function using 
        16 and 32 bit surfaces. Each alpha value (0-255) is tested against 
        several different threshold values. 
        Note: On 16 bit surface the requested alpha value can differ from what 
              is actually set. This test uses the value read from the surface. 
        &quot;&quot;&quot;</span>
        <span class="s1">threshold_count = </span><span class="s3">256</span>
        <span class="s1">surface_color = [</span><span class="s3">55</span><span class="s0">, </span><span class="s3">155</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">expected_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
        <span class="s1">all_set_count = expected_size[</span><span class="s3">0</span><span class="s1">] * expected_size[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">none_set_count = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s1">surface = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s1">depth)</span>

            <span class="s0">for </span><span class="s1">alpha </span><span class="s0">in </span><span class="s1">range(threshold_count):</span>
                <span class="s1">surface_color[</span><span class="s3">3</span><span class="s1">] = alpha</span>
                <span class="s1">surface.fill(surface_color)</span>

                <span class="s0">if </span><span class="s1">depth &lt; </span><span class="s3">32</span><span class="s1">:</span>
                    <span class="s5"># On surfaces with depths &lt; 32 the requested alpha can be</span>
                    <span class="s5"># different than what gets set. Use the value read from the</span>
                    <span class="s5"># surface.</span>
                    <span class="s1">alpha = surface.get_at((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))[</span><span class="s3">3</span><span class="s1">]</span>

                <span class="s5"># Test the mask created at threshold values low, high and</span>
                <span class="s5"># around alpha.</span>
                <span class="s1">threshold_test_values = {-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">alpha - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">alpha + </span><span class="s3">1</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">256</span><span class="s1">}</span>

                <span class="s0">for </span><span class="s1">threshold </span><span class="s0">in </span><span class="s1">threshold_test_values:</span>
                    <span class="s1">msg = </span><span class="s2">f&quot;depth=</span><span class="s0">{</span><span class="s1">depth</span><span class="s0">}</span><span class="s2">, alpha=</span><span class="s0">{</span><span class="s1">alpha</span><span class="s0">}</span><span class="s2">, threshold=</span><span class="s0">{</span><span class="s1">threshold</span><span class="s0">}</span><span class="s2">&quot;</span>

                    <span class="s0">if </span><span class="s1">alpha &gt; threshold:</span>
                        <span class="s1">expected_count = all_set_count</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">expected_count = none_set_count</span>

                    <span class="s1">mask = pygame.mask.from_surface(</span>
                        <span class="s1">surface=surface</span><span class="s0">, </span><span class="s1">threshold=threshold</span>
                    <span class="s1">)</span>

                    <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
                    <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_from_surface__different_alphas_32bit(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures from_surface creates a mask with the correct bits set 
        when pixels have different alpha values (32 bits surfaces). 
 
        This test checks the masks created by the from_surface function using 
        a 32 bit surface. The surface is created with each pixel having a 
        different alpha value (0-255). This surface is tested over a range 
        of threshold values (0-255). 
        &quot;&quot;&quot;</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">threshold_count = </span><span class="s3">256</span>
        <span class="s1">surface_color = [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">expected_size = (threshold_count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">expected_mask = pygame.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span>

        <span class="s5"># Give each pixel a different alpha.</span>
        <span class="s1">surface.lock()  </span><span class="s5"># Lock for possible speed up.</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">range(threshold_count):</span>
            <span class="s1">surface_color[</span><span class="s3">3</span><span class="s1">] = a</span>
            <span class="s1">surface.set_at((a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">surface_color)</span>
        <span class="s1">surface.unlock()</span>

        <span class="s5"># Test the mask created for each different alpha threshold.</span>
        <span class="s0">for </span><span class="s1">threshold </span><span class="s0">in </span><span class="s1">range(threshold_count):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;threshold=</span><span class="s0">{</span><span class="s1">threshold</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">expected_mask.set_at((threshold</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">expected_count = expected_mask.count()</span>

            <span class="s1">mask = pygame.mask.from_surface(surface</span><span class="s0">, </span><span class="s1">threshold)</span>

            <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">mask.overlap_area(expected_mask</span><span class="s0">, </span><span class="s1">offset)</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_from_surface__different_alphas_16bit(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures from_surface creates a mask with the correct bits set 
        when pixels have different alpha values (16 bit surfaces). 
 
        This test checks the masks created by the from_surface function using 
        a 16 bit surface. Each pixel of the surface is set with a different 
        alpha value (0-255), but since this is a 16 bit surface the requested 
        alpha value can differ from what is actually set. The resulting surface 
        will have groups of alpha values which complicates the test as the 
        alpha groups will all be set/unset at a given threshold. The setup 
        calculates these groups and an expected mask for each. This test data 
        is then used to test each alpha grouping over a range of threshold 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s1">threshold_count = </span><span class="s3">256</span>
        <span class="s1">surface_color = [</span><span class="s3">110</span><span class="s0">, </span><span class="s3">120</span><span class="s0">, </span><span class="s3">130</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">expected_size = (threshold_count</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">surface = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s1">SRCALPHA</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span>

        <span class="s5"># Give each pixel a different alpha.</span>
        <span class="s1">surface.lock()  </span><span class="s5"># Lock for possible speed up.</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">range(threshold_count):</span>
            <span class="s1">surface_color[</span><span class="s3">3</span><span class="s1">] = a</span>
            <span class="s1">surface.set_at((a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">surface_color)</span>
        <span class="s1">surface.unlock()</span>

        <span class="s1">alpha_thresholds = OrderedDict()</span>
        <span class="s1">special_thresholds = set()</span>

        <span class="s5"># Create the threshold ranges and identify any thresholds that need</span>
        <span class="s5"># special handling.</span>
        <span class="s0">for </span><span class="s1">threshold </span><span class="s0">in </span><span class="s1">range(threshold_count):</span>
            <span class="s5"># On surfaces with depths &lt; 32 the requested alpha can be different</span>
            <span class="s5"># than what gets set. Use the value read from the surface.</span>
            <span class="s1">alpha = surface.get_at((threshold</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))[</span><span class="s3">3</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">alpha </span><span class="s0">not in </span><span class="s1">alpha_thresholds:</span>
                <span class="s1">alpha_thresholds[alpha] = [threshold]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">alpha_thresholds[alpha].append(threshold)</span>

            <span class="s0">if </span><span class="s1">threshold &lt; alpha:</span>
                <span class="s1">special_thresholds.add(threshold)</span>

        <span class="s5"># Use each threshold group to create an expected mask.</span>
        <span class="s1">test_data = []  </span><span class="s5"># [(from_threshold, to_threshold, expected_mask), ...]</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">erase_mask = pygame.Mask(expected_size)</span>
        <span class="s1">exp_mask = pygame.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">thresholds </span><span class="s0">in </span><span class="s1">alpha_thresholds.values():</span>
            <span class="s0">for </span><span class="s1">threshold </span><span class="s0">in </span><span class="s1">thresholds:</span>
                <span class="s0">if </span><span class="s1">threshold </span><span class="s0">in </span><span class="s1">special_thresholds:</span>
                    <span class="s5"># Any special thresholds just reuse previous exp_mask.</span>
                    <span class="s1">test_data.append((threshold</span><span class="s0">, </span><span class="s1">threshold + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">exp_mask))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">to_threshold = thresholds[-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span>

                    <span class="s5"># Make the expected mask by erasing the unset bits.</span>
                    <span class="s0">for </span><span class="s1">thres </span><span class="s0">in </span><span class="s1">range(to_threshold):</span>
                        <span class="s1">erase_mask.set_at((thres</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

                    <span class="s1">exp_mask = pygame.Mask(expected_size</span><span class="s0">, </span><span class="s1">fill=</span><span class="s0">True</span><span class="s1">)</span>
                    <span class="s1">exp_mask.erase(erase_mask</span><span class="s0">, </span><span class="s1">offset)</span>
                    <span class="s1">test_data.append((threshold</span><span class="s0">, </span><span class="s1">to_threshold</span><span class="s0">, </span><span class="s1">exp_mask))</span>
                    <span class="s0">break</span>

        <span class="s5"># All the setup is done. Now test the masks created over the threshold</span>
        <span class="s5"># ranges.</span>
        <span class="s0">for </span><span class="s1">from_threshold</span><span class="s0">, </span><span class="s1">to_threshold</span><span class="s0">, </span><span class="s1">expected_mask </span><span class="s0">in </span><span class="s1">test_data:</span>
            <span class="s1">expected_count = expected_mask.count()</span>

            <span class="s0">for </span><span class="s1">threshold </span><span class="s0">in </span><span class="s1">range(from_threshold</span><span class="s0">, </span><span class="s1">to_threshold):</span>
                <span class="s1">msg = </span><span class="s2">f&quot;threshold=</span><span class="s0">{</span><span class="s1">threshold</span><span class="s0">}</span><span class="s2">&quot;</span>

                <span class="s1">mask = pygame.mask.from_surface(surface</span><span class="s0">, </span><span class="s1">threshold)</span>

                <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(</span>
                    <span class="s1">mask.overlap_area(expected_mask</span><span class="s0">, </span><span class="s1">offset)</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_from_surface__with_colorkey_mask_cleared(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures from_surface creates a mask with the correct bits set 
        when the surface uses a colorkey. 
 
        The surface is filled with the colorkey color so the resulting masks 
        are expected to have no bits set. 
        &quot;&quot;&quot;</span>
        <span class="s1">colorkeys = ((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">50</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">255</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">255</span><span class="s1">))</span>
        <span class="s1">expected_size = (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s1">)</span>
        <span class="s1">expected_count = </span><span class="s3">0</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">24</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;depth=</span><span class="s0">{</span><span class="s1">depth</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">surface = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">depth)</span>

            <span class="s0">for </span><span class="s1">colorkey </span><span class="s0">in </span><span class="s1">colorkeys:</span>
                <span class="s1">surface.set_colorkey(colorkey)</span>
                <span class="s5"># With some depths (i.e. 8 and 16) the actual colorkey can be</span>
                <span class="s5"># different than what was requested via the set.</span>
                <span class="s1">surface.fill(surface.get_colorkey())</span>

                <span class="s1">mask = pygame.mask.from_surface(surface)</span>

                <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_from_surface__with_colorkey_mask_filled(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures from_surface creates a mask with the correct bits set 
        when the surface uses a colorkey. 
 
        The surface is filled with a color that is not the colorkey color so 
        the resulting masks are expected to have all bits set. 
        &quot;&quot;&quot;</span>
        <span class="s1">colorkeys = ((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">255</span><span class="s0">, </span><span class="s3">255</span><span class="s0">, </span><span class="s3">255</span><span class="s1">))</span>
        <span class="s1">surface_color = (</span><span class="s3">50</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span>
        <span class="s1">expected_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">expected_count = expected_size[</span><span class="s3">0</span><span class="s1">] * expected_size[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">24</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;depth=</span><span class="s0">{</span><span class="s1">depth</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">surface = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">depth)</span>
            <span class="s1">surface.fill(surface_color)</span>

            <span class="s0">for </span><span class="s1">colorkey </span><span class="s0">in </span><span class="s1">colorkeys:</span>
                <span class="s1">surface.set_colorkey(colorkey)</span>

                <span class="s1">mask = pygame.mask.from_surface(surface)</span>

                <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s0">def </span><span class="s1">test_from_surface__with_colorkey_mask_pattern(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures from_surface creates a mask with the correct bits set 
        when the surface uses a colorkey. 
 
        The surface is filled with alternating pixels of colorkey and 
        non-colorkey colors, so the resulting masks are expected to have 
        alternating bits set. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">alternate(func</span><span class="s0">, </span><span class="s1">set_value</span><span class="s0">, </span><span class="s1">unset_value</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height):</span>
            <span class="s5"># Helper function to set alternating values.</span>
            <span class="s1">setbit = </span><span class="s0">False</span>
            <span class="s0">for </span><span class="s1">pos </span><span class="s0">in </span><span class="s1">((x</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(width) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">range(height)):</span>
                <span class="s1">func(pos</span><span class="s0">, </span><span class="s1">set_value </span><span class="s0">if </span><span class="s1">setbit </span><span class="s0">else </span><span class="s1">unset_value)</span>
                <span class="s1">setbit = </span><span class="s0">not </span><span class="s1">setbit</span>

        <span class="s1">surface_color = (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">colorkey = (</span><span class="s3">50</span><span class="s0">, </span><span class="s3">60</span><span class="s0">, </span><span class="s3">70</span><span class="s1">)</span>
        <span class="s1">expected_size = (</span><span class="s3">11</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">expected_mask = pygame.mask.Mask(expected_size)</span>
        <span class="s1">alternate(expected_mask.set_at</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">*expected_size)</span>
        <span class="s1">expected_count = expected_mask.count()</span>
        <span class="s1">offset = (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">depth </span><span class="s0">in </span><span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">24</span><span class="s0">, </span><span class="s3">32</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s2">f&quot;depth=</span><span class="s0">{</span><span class="s1">depth</span><span class="s0">}</span><span class="s2">&quot;</span>
            <span class="s1">surface = pygame.Surface(expected_size</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">depth)</span>
            <span class="s5"># Fill the surface with alternating colors.</span>
            <span class="s1">alternate(surface.set_at</span><span class="s0">, </span><span class="s1">surface_color</span><span class="s0">, </span><span class="s1">colorkey</span><span class="s0">, </span><span class="s1">*expected_size)</span>
            <span class="s1">surface.set_colorkey(colorkey)</span>

            <span class="s1">mask = pygame.mask.from_surface(surface)</span>

            <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">expected_size</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">mask.overlap_area(expected_mask</span><span class="s0">, </span><span class="s1">offset)</span><span class="s0">, </span><span class="s1">expected_count</span><span class="s0">, </span><span class="s1">msg</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_from_threshold(self):</span>
        <span class="s4">&quot;&quot;&quot;Does mask.from_threshold() work correctly?&quot;&quot;&quot;</span>

        <span class="s1">a = [</span><span class="s3">16</span><span class="s0">, </span><span class="s3">24</span><span class="s0">, </span><span class="s3">32</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">a:</span>
            <span class="s1">surf = pygame.surface.Surface((</span><span class="s3">70</span><span class="s0">, </span><span class="s3">70</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">surf.fill((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))</span>
            <span class="s1">mask = pygame.mask.from_threshold(</span>
                <span class="s1">surf</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s1">rects = mask.get_bounding_rects()</span>

            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s3">400</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(mask.get_bounding_rects()</span><span class="s0">, </span><span class="s1">[pygame.Rect((</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))])</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">a:</span>
            <span class="s1">surf = pygame.surface.Surface((</span><span class="s3">70</span><span class="s0">, </span><span class="s3">70</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">surf2 = pygame.surface.Surface((</span><span class="s3">70</span><span class="s0">, </span><span class="s3">70</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">surf.fill((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span>
            <span class="s1">surf2.fill((</span><span class="s3">150</span><span class="s0">, </span><span class="s3">150</span><span class="s0">, </span><span class="s3">150</span><span class="s1">))</span>
            <span class="s1">surf2.fill((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">40</span><span class="s0">, </span><span class="s3">40</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
            <span class="s1">mask = pygame.mask.from_threshold(</span>
                <span class="s1">surface=surf</span><span class="s0">,</span>
                <span class="s1">color=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">threshold=(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">othersurface=surf2</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
            <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(mask.get_bounding_rects()</span><span class="s0">, </span><span class="s1">[pygame.Rect((</span><span class="s3">40</span><span class="s0">, </span><span class="s3">40</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))])</span>

    <span class="s0">def </span><span class="s1">test_zero_size_from_surface(self):</span>
        <span class="s4">&quot;&quot;&quot;Ensures from_surface can create masks from zero sized surfaces.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">mask = pygame.mask.from_surface(pygame.Surface(size))</span>

            <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.MaskType</span><span class="s0">, </span><span class="s2">f&quot;size=</span><span class="s0">{</span><span class="s1">size</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s1">self.assertEqual(mask.get_size()</span><span class="s0">, </span><span class="s1">size)</span>

    <span class="s0">def </span><span class="s1">test_zero_size_from_threshold(self):</span>
        <span class="s1">a = [</span><span class="s3">16</span><span class="s0">, </span><span class="s3">24</span><span class="s0">, </span><span class="s3">32</span><span class="s1">]</span>
        <span class="s1">sizes = ((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s0">for </span><span class="s1">size </span><span class="s0">in </span><span class="s1">sizes:</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">a:</span>
                <span class="s1">surf = pygame.surface.Surface(size</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i)</span>
                <span class="s1">surf.fill((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))</span>
                <span class="s1">mask = pygame.mask.from_threshold(</span>
                    <span class="s1">surf</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span>
                <span class="s1">)</span>

                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                <span class="s1">rects = mask.get_bounding_rects()</span>
                <span class="s1">self.assertEqual(rects</span><span class="s0">, </span><span class="s1">[])</span>

            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">a:</span>
                <span class="s1">surf = pygame.surface.Surface(size</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i)</span>
                <span class="s1">surf2 = pygame.surface.Surface(size</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i)</span>
                <span class="s1">surf.fill((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">))</span>
                <span class="s1">surf2.fill((</span><span class="s3">150</span><span class="s0">, </span><span class="s3">150</span><span class="s0">, </span><span class="s3">150</span><span class="s1">))</span>
                <span class="s1">surf2.fill((</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">40</span><span class="s0">, </span><span class="s3">40</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
                <span class="s1">mask = pygame.mask.from_threshold(</span>
                    <span class="s1">surf</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">255</span><span class="s1">)</span><span class="s0">, </span><span class="s1">surf2</span>
                <span class="s1">)</span>

                <span class="s1">self.assertIsInstance(mask</span><span class="s0">, </span><span class="s1">pygame.mask.Mask)</span>
                <span class="s1">self.assertEqual(mask.count()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

                <span class="s1">rects = mask.get_bounding_rects()</span>
                <span class="s1">self.assertEqual(rects</span><span class="s0">, </span><span class="s1">[])</span>

    <span class="s0">def </span><span class="s1">test_buffer_interface(self):</span>
        <span class="s1">size = (</span><span class="s3">1000</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">pixels_set = ((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">173</span><span class="s0">, </span><span class="s3">90</span><span class="s1">))</span>
        <span class="s1">pixels_unset = ((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">101</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">173</span><span class="s0">, </span><span class="s3">91</span><span class="s1">))</span>

        <span class="s1">mask = pygame.Mask(size)</span>
        <span class="s0">for </span><span class="s1">point </span><span class="s0">in </span><span class="s1">pixels_set:</span>
            <span class="s1">mask.set_at(point</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">view = memoryview(mask)</span>
        <span class="s1">intwidth = </span><span class="s3">8 </span><span class="s1">* view.strides[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s0">for </span><span class="s1">point </span><span class="s0">in </span><span class="s1">pixels_set:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = point</span>
            <span class="s1">col = x // intwidth</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">(view[col</span><span class="s0">, </span><span class="s1">y] &gt;&gt; (x % intwidth)) &amp; </span><span class="s3">1</span><span class="s0">,</span>
                <span class="s3">1</span><span class="s0">,</span>
                <span class="s2">f&quot;the pixel at </span><span class="s0">{</span><span class="s1">point</span><span class="s0">} </span><span class="s2">is not set to 1&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">point </span><span class="s0">in </span><span class="s1">pixels_unset:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = point</span>
            <span class="s1">col = x // intwidth</span>
            <span class="s1">self.assertEqual(</span>
                <span class="s1">(view[col</span><span class="s0">, </span><span class="s1">y] &gt;&gt; (x % intwidth)) &amp; </span><span class="s3">1</span><span class="s0">,</span>
                <span class="s3">0</span><span class="s0">,</span>
                <span class="s2">f&quot;the pixel at </span><span class="s0">{</span><span class="s1">point</span><span class="s0">} </span><span class="s2">is not set to 0&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s2">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s1">unittest.main()</span>
</pre>
</body>
</html>